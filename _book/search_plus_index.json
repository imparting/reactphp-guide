{"./":{"url":"./","title":"简介","keywords":"","body":" 事件驱动,非阻塞I/O的PHP ReactPHP是PHP中用于事件驱动编程的底层库。它的核心是一个事件循环，在此基础上它提供了底层实用程序，例如：流抽象、异步DNS解析器、网络客户端/服务器、HTTP客户端/服务器以及进程间通信。第三方库可以使用这些组件创建异步网络客户端/服务器等。 $loop = React\\EventLoop\\Factory::create(); $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); $socket = new React\\Socket\\Server(8080, $loop); $server->listen($socket); echo \"Server running at http://127.0.0.1:8080\\n\"; $loop->run(); 这个用ReactPHP编写的简单的Web服务器对每个请求都响应 \"Hello World\" ReactPHP是PHP中用于事件驱动编程的底层库。 核心是一个事件循环，它在其上提供底层实用程序， 例如：流抽象，异步DNS解析器，网络客户端/服务器，HTTP客户机/服务器和与进程的交互。 第三方库可以使用这些用于创建异步网络客户端/服务器等的组件。 ReactPHP已经可用于生产环境，并且经过来自世界各地的各种项目数百万次的安装测试。 由于事件驱动架构，使它非常适合高效的网络服务器和处理数百或数千个并发连接，长期运行的应用程序和许多其他无阻塞I / O操作的协作多任务形式。 ReactPHP之所以与众不同，是因为其活跃的生态系统具有数百个第三方库，可让您与许多现有系统集成 ，例如公共网络服务、数据库系统和其他第三方API。 生产就绪，并经过了实战测试。 稳固的，具有稳定的长期支持（LTS）版本。 不需要扩展，并且可以在任何平台上运行-没有任何借口！ 利用可选扩展来获得更好的性能（如果可用）。 强烈建议使用最新版本的PHP 7 +，以获得最佳性能和支持。 支持旧版PHP 5.3+和HHVM，以实现最大兼容性。 精心设计的和可重复使用的组件。 分离的零件，因此可以用其他实现方式替换它们。 经过测试（单位和功能）。 尽可能采用标准PSR，以实现最大的互操作性。 旨在“技术中立”，因此您可以使用首选的应用程序堆栈。 小型核心专业团队由外部贡献者的大型网络支持。 默认情况下，ReactPHP是非阻塞的，workers阻止I / O。 事件循环基于反应堆模式（因此命名），并且强烈受诸如EventMachine（Ruby），Twisted（Python）和 Node.js（V8）。 核心组件 EventLoop ReactPHP的核心反应器event-loop 文档 Stream 事件驱动的可读写流，用于ReactPHP中的非阻塞I / O 文档 Promise Promises/A 的PHP实现 文档 网络组件 Socket 异步，流式传输纯文本TCP / IP以及安全TLS套接字服务器和客户端连接 文档 Datagram 事件驱动的UDP客户端和服务器套接字 文档 协议组件 HTTP 事件驱动的流式纯文本HTTP和安全HTTPS服务器 文档 HTTPClient 事件驱动的HTTP流客户端 文档 DNS 异步DNS解析器 文档 实用组件 Cache 异步缓存 文档 ChildProcess 执行子进程的库。 文档 PromiseTimer ReactPHP的Promise库的简单超时实现。 文档 PromiseStream 在ReactPHP之上构建的Promise和Stream之间的衔接环节。 文档 "},"1.Core-Components/EventLoop.html":{"url":"1.Core-Components/EventLoop.html","title":"EventLoop","keywords":"","body":"EventLoop ReactPHP的核心事件循环，用于事件I/O 为了使基于异步的库可互操作，它们需要使用相同的事件循环。 该组件提供了一个任何库都可以定位的通用公共LoopInterface， 这使它们可以在同一循环中使用，并由用户控制一个 run()调用。 目录 快速开始 用法 Factory create() Loop implementations StreamSelectLoop ExtEventLoop ExtLibeventLoop ExtLibevLoop ExtEvLoop ExtUvLoop LoopInterface run() stop() addTimer() addPeriodicTimer() cancelTimer() futureTick() addSignal() removeSignal() addReadStream() addWriteStream() removeReadStream() removeWriteStream() 安装 测试 License 快速开始 这里是一个仅使用事件循环构建的异步HTTP服务器。 $loop = React\\EventLoop\\Factory::create(); $server = stream_socket_server('tcp://127.0.0.1:8080'); stream_set_blocking($server, false); $loop->addReadStream($server, function ($server) use ($loop) { $conn = stream_socket_accept($server); $data = \"HTTP/1.1 200 OK\\r\\nContent-Length: 3\\r\\n\\r\\nHi\\n\"; $loop->addWriteStream($conn, function ($conn) use (&$data, $loop) { $written = fwrite($conn, $data); if ($written === strlen($data)) { fclose($conn); $loop->removeWriteStream($conn); } else { $data = substr($data, $written); } }); }); $loop->addPeriodicTimer(5, function () { $memory = memory_get_usage() / 1024; $formatted = number_format($memory, 3).'K'; echo \"Current memory usage: {$formatted}\\n\"; }); $loop->run(); 查看示例. 用法 典型的应用程序:开始时创建的单个事件循环，程序结束时运行。 // [1] $loop = React\\EventLoop\\Factory::create(); // [2] $loop->addPeriodicTimer(1, function () { echo \"Tick\\n\"; }); $stream = new React\\Stream\\ReadableResourceStream( fopen('file.txt', 'r'), $loop ); // [3] $loop->run(); 在程序开始时创建循环实例React\\EventLoop\\Factory::create() 并选择最佳的可用循环实现. 2.循环实例可直接使用或传递给库和应用程序代码。 在此示例中，向事件循环注册了一个定期定时器，该循环每秒输出一次 Tick ， 并使用ReactPHPstream组件 创建可读流进行演示。 3.循环在程序最后通过单个$loop->run()运行。 Factory Factory 类是一个提供便捷创建循环实例的最佳类 事件循环实现. create() create():LoopInterface 方法可用于创建新的事件循环 例子: $loop = React\\EventLoop\\Factory::create(); 该方法返回实现LoopInterface的实例，事件循环实现是一个具体实现。 该方法通常只能在程序开始时调用一次。 Loop implementations 除了LoopInterface之外，还有一些提供了事件循环实现。 所有事件循环都支持以下功能: 文件描述符轮询 一次性定时器 周期定时器 在未来循环中延迟执行 对于此软件包的大多数使用者而言，底层事件循环实现是具体实现。 您应该使用Factory自动创建一个新实例。 高级！ 如果您明确需要某个事件循环实现，则可以手动实例化以下类之一。 请注意，您可能必须为其安装相应的PHP扩展，否则它们将在创建时抛出 BadMethodCallException 异常。 StreamSelectLoop 基于stream_select()的事件循环。 使用stream_select() 函数，它是唯一一个使用PHP开箱即用的实现。 在php5.3到php7+和HHVM上，这个事件循环是开箱即用的。这意味着不需要额外安装其他扩展，而且这个库可以在所有支持的PHP的平台上工作。 因此，如果您没有安装下面列出的事件循环扩展， Factory将默认使用此事件循环。 在后台，它执行一个简单的 select 系统调用。 该系统调用限于 FD_SETSIZE 的最大文件描述符数量（取决于平台，通常为1024），并以 O(m) （ m 是传递的最大文件描述符数量）进行缩放。 这意味着在同时处理数千个流时，您可能会遇到问题，并且在这种情况下，您可能想研究使用下面列出的事件循环实现之一替代。 如果您的用例属于仅涉及一次处理数十个或几百个流，则此事件循环实现的执行效果非常好。 如果要使用信号处理（另请参阅下面的addSignal() ），此事件循环实现需要安装ext-pcntl扩展。 此扩展仅适用于类Unix平台，不支持Windows, 该扩展通常作为许多PHP发行版的一部分安装。 如果缺少此扩展名（或您正在Windows上运行），则不支持信号处理，将抛出BadMethodCallException异常。 PHP 7.3之前的版本，该事件循环都依赖于时钟时间来安排将来的定时器，因为单调时间源仅从PHP 7.3+ 可用（hrtime()）。 尽管这并不影响大部分应用程序，但这对于依赖于高时间精度的程序或受不连续时间调整（时间跳跃）影响的系统而言，是一个重要的区别。 这意味着，如果您安排一个定时器在PHP addTimer()。 ExtEventLoop 基于ext-event的事件循环。 使用event PECL extension 扩展，与libevent相同。 此循环可用于PHP 5.4到PHP 7+。 ExtEvLoop 基于ext-ev的事件循环。 使用 ev PECL extension 扩展，提供 libev 库的接口。 此循环可用于PHP 5.4到PHP 7+。 ExtUvLoop 基于ext-uv的事件循环。 使用 uv PECL extension 扩展， 提供 libuv 库的接口。 此循环可用于PHP 7+。 ExtLibeventLoop 基于ext-libevent的事件循环。 使用 libevent PECL extension 扩展。 libevent 本身支持许多特定于系统的后端（epoll，kqueue）。 此事件循环仅适用于PHP 5。 存在用于PHP 7 的版本 非正式更新 ，但已知由于SEGFAULT导致定期崩溃。 重申一下:不建议在PHP 7上使用此事件循环。 因此Factory将不会尝试在PHP 7上使用此事件循环。 已知只有在流变得可读（边缘触发）时才触发事件侦听器，并且如果从一开始就已经可读该流，则可能不会触发。 这也意味着，当数据仍留在PHP的内部流缓冲区中时，该流可能不被视为可读。 因此，在这种情况下，建议使用stream_set_read_buffer($stream, 0);禁用PHP的内部读取缓冲区。 另请参阅addReadStream()。 ExtLibevLoop 基于ext-libev的事件循环。 使用非正式的 libev 扩展名 扩展，与libevent相同。 此循环仅适用于PHP 5。 PHP 7的更新不太可能 LoopInterface run() 使用 run(): void 方法执行事件循环，直到没有任务执行为止。 对于大部分应用程序，该方法是事件循环上唯一直接可见的调用。 根据经验，通常建议将所有内容附加到同一循环实例，然后在应用程序的最底端运行一次循环。 $loop->run(); 此方法将使循环保持运行状态，直到没有其他任务可以执行为止。 换句话说:此方法将阻塞直到最后一个定时器，流 和/或 信号被删除为止。 同样，必须确保应用程序实际调用此方法一次。如果将侦听器添加到循环中而没有执行该方法，任何附加的监听器将不再等待，应用程序会直接退出。 循环已在运行时，不能调用此方法。此方法在显式调用stop()ped后或由于以前不再有任何操作而自动停止后，可能会被多次调用。 stop() 运行stop(): void方法将停止正在运行的事件循环。 此方法为高级用法，应小心使用。通常建议仅当循环不再有任何事情要做时才自动停止。 此方法用于显式指示事件循环停止: $loop->addTimer(3.0, function () use ($loop) { $loop->stop(); }); 对当前未运行的循环实例或已停止的循环实例调用此方法无效。 addTimer() addTimer(float $interval, callable $callback): TimerInterface 方法可用于将要在设定间隔（秒）后调用回调。 定时器回调函数必须能够接受单个参数，定时器实例也是由这个方法返回的，或者您可以使用一个完全没有参数的函数。 定时器回调函数不能抛出Exception。 定时器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 与addPeriodicTimer()不同，此方法将确保在设定间隔（秒）后只调用一次回调。 您可以调用cancelTimer来取消挂起的定时器。 $loop->addTimer(0.8, function () { echo 'world!' . PHP_EOL; }); $loop->addTimer(0.3, function () { echo 'hello '; }); 示例#1. 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示: function hello($name, LoopInterface $loop) { $loop->addTimer(1.0, function () use ($name) { echo \"hello $name\\n\"; }); } hello('Tester', $loop); 此接口不强制任意间隔的定时器，因此如果您依赖毫秒或以下的非常高的精度，可能需要特别小心。除非另有说明，否则事件循环实现应尽力提供高精度间隔，并应至少提供毫秒精度。 已知许多现有的事件循环实现提供微秒精度，但通常不建议依赖这种高精度。 类似地，不能保证在同一时间（在其可能的精度范围内）被调度执行的定时器的执行顺序。 此接口建议事件循环实现应使用单调时间源（如果可用）。假设单调时间源在默认情况下仅在php7.3中可用，那么事件循环实现可能会退回到使用挂钟时间。 虽然这不会影响许多常见的用例，但对于依赖高时间精度或受不连续时间调整（时间跳跃）影响的系统的程序来说，这是很重要的一点。 这意味着如果你安排一个定时器在30秒后触发，然后调整你的系统时间向前20秒，定时器仍应在30秒后触发。 有关详细信息，请参阅事件循环实现 addPeriodicTimer() addPeriodicTimer(float $interval, callable $callback): TimerInterface 方法可用于将要在设定间隔（秒）后重复调用的回调。 定时器回调函数必须能够接受单个参数，定时器实例也是由这个方法返回的，或者您可以使用一个完全没有参数的函数。 定时器回调函数不能抛出Exception。 定时器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 与addTimer()不同，此方法将确保在设定间隔（秒）后重复调用回调。 您可以调用cancelTimer来取消挂起的定时器。 $timer = $loop->addPeriodicTimer(0.1, function () { echo 'tick!' . PHP_EOL; }); $loop->addTimer(1.0, function () use ($loop, $timer) { $loop->cancelTimer($timer); echo 'Done' . PHP_EOL; }); 示例#2. 如果要限制执行次数，可以将控制变量通过use绑定的回调闭包中，如下所示: function hello($name, LoopInterface $loop) { $n = 3; $loop->addPeriodicTimer(1.0, function ($timer) use ($name, $loop, &$n) { if ($n > 0) { --$n; echo \"hello $name\\n\"; } else { $loop->cancelTimer($timer); } }); } hello('Tester', $loop); 此接口不强制任意间隔的定时器，因此如果您依赖毫秒或以下的非常高的精度，可能需要特别小心。除非另有说明，否则事件循环实现应尽力提供高精度间隔，并应至少提供毫秒精度。 已知许多现有的事件循环实现提供微秒精度，但通常不建议依赖这种高精度。 类似地，不能保证在同一时间（在其可能的精度范围内）被调度执行的定时器的执行顺序。 此接口建议事件循环实现应使用单调时间源（如果可用）。假设单调时间源在默认情况下仅在php7.3中可用，那么事件循环实现可能会退回到使用挂钟时间。 虽然这不会影响许多常见的用例，但对于依赖高时间精度或受不连续时间调整（时间跳跃）影响的系统的程序来说，这是很重要的一点。 这意味着如果你安排一个定时器在30秒后触发，然后调整你的系统时间向前20秒，定时器仍应在30秒后触发。 有关详细信息，请参阅事件循环实现 此外，由于每次调用后都要进行重新调度，周期性定时器可能会发生定时器漂移。 因此，通常不建议在毫秒级或以下的高精度间隔中使用此方法。 cancelTimer() cancelTimer(TimerInterface $timer): void 方法可用于取消待处理的定时器。 addPeriodicTimer() 示例#2. 对没有添加到循环实例的定时器或已取消的定时器调用此方法无效。 futureTick() futureTick(callable $listener): void 方法可用于安排在事件循环的未来时刻调用的回调。 这与间隔为 0 秒的定时器非常相似，但是它不会被插入定时器队列中，进而减少队列开销。 tick回调函数必须能够接受零参数。tick回调函数不抛出Exception。 tick回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示: function hello($name, LoopInterface $loop) { $loop->futureTick(function () use ($name) { echo \"hello $name\\n\"; }); } hello('Tester', $loop); 与定时器不同，tick回调保证按其入队的顺序执行。同样，一旦将回调放入队列，就无法取消此操作。 这通常用于将较大的任务分解为较小的步骤（一种协作式多任务处理形式）。 $loop->futureTick(function () { echo 'b'; }); $loop->futureTick(function () { echo 'c'; }); echo 'a'; 示例#3. addSignal() addSignal(int $signal, callable $listener): void 方法可用于注册一个侦听器，以便在此过程捕获到信号时得到通知。 这对于从supervisor 或 systemd之类的工具捕获用户中断信号或关闭信号很有用。 通过此方法添加的信号，侦听器回调函数必须能够接受单个参数或者您可以使用完全不带参数的函数。 侦听器回调函数不得抛出 Exception 监听器回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 $loop->addSignal(SIGINT, function (int $signal) { echo 'Caught user interrupt signal' . PHP_EOL; }); 示例#4. 信号仅在类似Unix的平台上可用，由于操作系统限制，不支持Windows。 如果此平台不支持信号，例如缺少所需的扩展名，则此方法可能抛出BadMethodCallException。 注意 :一个监听器只能添加到同一信号一次，多次添加将被忽略。 removeSignal() removeSignal(int $signal, callable $listener): void 方法可用于删除先前添加的信号监听器。 $loop->removeSignal(SIGINT, $listener); 删除未注册的监听器将被忽略。 addReadStream() 高级！ 请注意，此底层API被视为高级用法。 大多数用例可能应该使用更高级别的API来替代 可读流API addReadStream(resource $stream, callable $callback): void 方法可用于注册侦听器，以便在流准备好读取时收到通知。 第一个参数必须是一个有效的流资源，它支持检查循环实现是否可以读取它。 单个流资源不能添加多次。 但可以先调用removeReadStream()，或者使用单个侦听器对此事件做出反应，然后从此侦听器中进行调度。如果循环实现不支持给定的资源类型，则此方法可能引发Exception 添加的流资源侦听器回调函数必须能够接受单个参数或者您可以使用完全没有参数的函数。 侦听器回调函数不能抛出Exception 侦听器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示: $loop->addReadStream($stream, function ($stream) use ($name) { echo $name . ' said: ' . fread($stream); }); 示例#11. 您可以调用 removeReadStream() 删除此流的读取事件侦听器。 无法保证多个流同时准备就绪时侦听器的执行顺序。 某些事件循环实现仅在流变得可读（边缘触发）时才触发侦听器，并且如果从一开始就已经可读该流，则可能不会触发。 这也意味着，当数据仍留在PHP的内部流缓冲区中时，该流可能不被视为可读。 在这种情况下，建议使用stream_set_read_buffer($stream, 0);禁用PHP的内部读取缓冲区。 addWriteStream() 高级！ 请注意，此底层API被视为高级用法。大多数用例可能应该使用更高级别的API替代可写流API addWriteStream(resource $stream, callable $callback): void 方法可用于注册一个侦听器，以便在流准备好写入时得到通知。 第一个参数务必是有效的流资源，它支持检查是否已准备好通过此循环实现进行写入。 单个流资源不得多次添加。 相反，请先调用removeWriteStream()或使用单个侦听器对此事件做出反应，然后从该事件进行分派监听。 如果此循环实现不支持给定的资源类型，则此方法可以抛出 Exception 添加的流资源侦听器回调函数必须能够接受单个参数或者您可以使用完全没有参数的函数。 侦听器回调函数不得抛出Exception 监听器回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示: $loop->addWriteStream($stream, function ($stream) use ($name) { fwrite($stream, 'Hello ' . $name); }); 示例#12. 您可以调用 removeWriteStream() 删除此流的写入事件侦听器。 无法保证多个流同时准备就绪时侦听器的执行顺序。 removeReadStream() removeReadStream(resource $stream): void 方法可用于删除给定流的可读事件监听器。 从循环中删除已删除的流，或尝试删除从未添加过或无效的流时此方法无效。 removeWriteStream() removeWriteStream(resource $stream): void 方法可用于删除给定流的可写事件监听器。 从循环中删除已删除的流，或尝试删除从未添加过或无效的流时此方法无效。 安装 推荐安装 通过Composer. Composer新手? 该项目遵循 SemVer. 这将安装最新的受支持版本: $ composer require react/event-loop:^1.1.1 另请参阅 CHANGELOG ，以获取有关版本升级的详细信息。 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈建议在这个项目中使用PHP7+。 建议安装任何一个事件循环扩展，但完全是可选的。 有关详细信息，请参阅事件循环实现 测试 要运行测试套件，首先需要克隆此存储库，然后安装所有依赖项 通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"1.Core-Components/Promise.html":{"url":"1.Core-Components/Promise.html","title":"Promise","keywords":"","body":"Promise PHP的 CommonJS Promises/A 的轻量级实现。 主分支包含即将发布的3.0版本的代码。 对于当前稳定的2.x版本的代码，请检查 2.x分支 即将发布的3.0版本将是此软件包的主发展方向。 但是，对于尚未安装PHP 7+的用户，我们仍将积极支持2.0和1.0。 目录 简介 概念 Deferred（延迟） Promise（承诺） API Deferred Deferred::promise() Deferred::resolve() Deferred::reject() PromiseInterface PromiseInterface::then() PromiseInterface::done() PromiseInterface::otherwise() PromiseInterface::always() PromiseInterface::cancel() Promise Functions resolve() reject() all() race() any() some() map() reduce() PromisorInterface 示例 如何使用Deferred 承诺转发的工作原理 转发履行 转发拒绝 转发履行和拒绝 done() vs. then() Credits License 简介 Promise是一个为PHP实现CommonJS Promises/A 的库。 它还提供了其他一些与承诺相关的有用概念，例如加入多个承诺以及映射和减少承诺集合。 如果您以前从未听说过诺言，请先阅读此内容 概念 Deferred（延迟） Deferred 表示可能尚未完成的计算或工作单元。 通常（但并非总是）该计算将异步执行并在将来的某个时刻完成。 Promise（承诺） Deferred 表示计算本身，而 Promise 表示该计算的结果。 因此，每个Deferred 者都有一个承诺，可以充当其实际结果的占位符。 API Deferred Deferred 表示其解析挂起的操作。它有单独的promise和resolver部分。 $deferred = new React\\Promise\\Deferred(); $promise = $deferred->promise(); $deferred->resolve(mixed $value = null); $deferred->reject(\\Throwable $reason); promise 方法返回延迟的承诺。 resolve和reject 方法控制延迟状态。 Deferred的构造函数接受一个可选的$canceller参数。有关更多信息，请参阅Promise Deferred::promise() $promise = $deferred->promise(); 返回延期的承诺，您可以将其分发给其他人，同时保留自行修改其状态的权限。 Deferred::resolve() $deferred->resolve(mixed $value = null); 解决promise()返回的承诺。 $value调用 $onFulfilled来通知所有消费者（它们通过$promise->then() 注册）。 如果$value本身是一个承诺，那么一旦这个承诺被解决，它将转换到这个承诺的状态。 Deferred::reject() $deferred->reject(\\Throwable $reason); 拒绝promise()返回的承诺，表示延迟的计算失败。 所有消费者都会收到通知，方法是使用$reason调用$onRejected（它们通过$promise->then()注册）。 PromiseInterface PromiseInterface 为所有promise实现提供公共接口。 请参阅Promise以获取此包唯一公共实现。 一个承诺代表一个最终的结果，要么是实现（成功）和相关的结果，要么是拒绝（失败）和相关的原因。 一旦承诺处于履行或拒绝的状态，承诺就变得不可更改。 它的状态和结果（或错误）都不能修改。 PromiseInterface::then() $transformedPromise = $promise->then(callable $onFulfilled = null, callable $onRejected = null); 通过对承诺的履行或拒绝的结果，应用函数来转换承诺的状态值并返回转换结果的新承诺。 then() 方法用于一个promise注册新的已完成和拒绝处理程序（所有参数都是可选的）: 一旦承诺实现，其结果将作为第一个参数传递，就会调用$onFulfilled 一旦承诺被拒绝，其原因作为第一个参数传递，就会调用$onRejected $onFulfilled或$onRejected的返回一个新的promise，无论哪个被调用，或者其中一个抛出异常则抛出异常。 promise 对在then()的同一调用中注册的处理回调做出以下保证: 1.仅会调用$onFulfilled 或 $onRejected中的一个，两者不会都调用。 2.$onFulfilled 和 $onRejected 不会被调用一次以上。 另请参阅 resolve() - 创造承诺 reject() - 创建拒绝的承诺 PromiseInterface::done() done() vs. then() PromiseInterface::done() $promise->done(callable $onFulfilled = null, callable $onRejected = null); 如果承诺履行或拒绝，则耗费承诺的最终结果。 如果 $onFulfilled 或 $onRejected抛出或返回被拒绝的诺言，将导致致命错误(E_USER_ERROR) 由于done()的目的是消费而不是转换，所以done()总是返回null。 另请参阅 PromiseInterface::then() done() vs. then() PromiseInterface::otherwise() $promise->otherwise(callable $onRejected); 注册拒绝处理程序以进行承诺。 快捷操作方式如下: $promise->then(null, $onRejected); 另外，您可以传入提示$onRejected的$reason参数，仅捕获特定的错误。 $promise ->otherwise(function (\\RuntimeException $reason) { // Only catch \\RuntimeException instances // All other types of errors will propagate automatically }) ->otherwise(function (\\Throwable $reason) { // Catch other errors )}; PromiseInterface::always() $newPromise = $promise->always(callable $onFulfilledOrRejected); 允许您在承诺链中执行“清理”类型的任务。 当promise被履行或被拒绝时调用$onFulfilledOrRejected(不带任何参数)回调 如果$promise履行，并且$onFulfilledOrRejected成功返回，则$newPromise履行与$promise相同的值。 如果$promise履行，并且$onFulfilledOrRejected抛出或返回被拒绝的承诺，$newPromise将抛出的异常或拒绝的承诺的原因。 如果$promise拒绝，并且$onFulfilledOrRejected成功返回，则$newPromise与$promise以相同的原因拒绝。 如果$promise拒绝，并且$onFulfilledOrRejected抛出或返回被拒绝的承诺，$newPromise将抛出的异常或拒绝的承诺的原因。 always()的行为于synchronous finally语句类似。当与otherwise()结合使用时，always()允许您编写于熟悉的同步catch/finally类似的代码。 考虑以下同步代码: try { return doSomething(); } catch (\\Throwable $e) { return handleError($e); } finally { cleanup(); } 可以编写类似的异步代码（doSomething()返回承诺）: return doSomething() ->otherwise('handleError') ->always('cleanup'); PromiseInterface::cancel() $promise->cancel(); cancel() 方法通知承诺创建者对操作的结果不再感兴趣。 一旦兑现了承诺（无论是履行还是拒绝），对承诺调用cancel()无效。 Promise 创建一个promise，其状态由传$resolver函数控制。 $resolver = function (callable $resolve, callable $reject) { // Do some work, possibly asynchronously, and then // resolve or reject. $resolve($awesomeResult); // or throw new Exception('Promise rejected'); // or $resolve($anotherPromise); // or $reject($nastyError); }; $canceller = function () { // Cancel/abort any running operations like network connections, streams etc. // Reject promise by throwing an exception throw new Exception('Promise cancelled'); }; $promise = new React\\Promise\\Promise($resolver, $canceller); promise构造函数将接收一个resolver函数和一个可选的canceller函数，这两个函数都将使用3个参数进行调用: $resolve($value) - 包装返回的promise的主要函数。 接受非承诺值或其他承诺。 当用非承诺值调用时，用该值实现承诺。当以另一个承诺被调用时， 例如 $resolve($otherPromise)，包装返回的promise等同于$otherPromise。 $rejec($reason) - 拒绝承诺的函数。建议只抛出异常，而不要使用$reject()。 如果resolver或canceller抛出异常，则将以该抛出的异常作为拒绝原因来拒绝承诺。 resolver函数将立即被调用，只有当所有使用者调用promise的cancel()方法时，canceller函数才会被调用。 Functions 用于创建、连接、映射和减少承诺集合的有用函数。 所有处理承诺集合的功能（例如all()，race()，some()等）都支持取消。 这意味着，如果您对返回的诺言调用cancel()，则集合中的所有诺言都会被取消。 resolve() $promise = React\\Promise\\resolve(mixed $promiseOrValue); 为$promiseOrValue创建一个承诺。 如果$promiseOrValue是一个值，它将是返回承诺 如果$promiseOrValue拥有thenable能力（提供then()方法的对象），则返回跟随thenable状态的可信承诺。 如果$promiseOrValue是一个承诺，它将按原样返回。 reject() $promise = React\\Promise\\reject(\\Throwable $reason); 为$reason创建一个拒绝的promise。 注意\\Throwable PHP7中引入的接口包括两个用户区域 \\Exception 和 \\Error 内部PHP错误。 通过强制使用\\Throwable作为拒绝承诺的理由，任何语言错误或用户地异常都可以用来拒绝承诺。 all() $promise = React\\Promise\\all(array $promisesOrValues); 返回一个承诺，该承诺仅在$promisesOrValues中的所有项都已解析时才会解析。 返回的承诺的解析值将是一个数组，其中包含$promisesOrValues中每个项的解析值。 race() $promise = React\\Promise\\race(array $promisesOrValues); 发起一场允许一名获胜者参加的竞赛。返回一个承诺，该承诺的解决方式与第一个履行的承诺解决方式相同。 如果$promisesOrValues包含0项，则返回的承诺将无限挂起。 any() $promise = React\\Promise\\any(array $promisesOrValues); 返回将在$promisesOrValues中的任何一项兑现的承诺。返回的承诺的值将是触发项的值。 只有在$promisesOrValues中的 所有 项被拒绝时，返回的承诺才会被拒绝。 拒绝值将是React\\Promise\\Exception\\CompositeException，其中包含所有拒绝原因。 拒绝原因可以通过CompositeException::getThrowables()获得。 如果$promisesOrValues包含0项，则返回的承诺也将拒绝， 并带有React\\Promise\\Exception\\LengthException some() $promise = React\\Promise\\some(array $promisesOrValues, integer $howMany); 返回一个承诺，当$promisesOrValues中至少有$howMany个提供的项兑现时，该承诺将被兑现。 返回的承诺的值将是一个长度为$howMany的数组，该数组包含首先解析的$howMany已兑现承诺的值。 如果$howMany项无法兑现（即(count($promisesOrValues)-$howMany)+1项拒绝）， 则返回的承诺将拒绝。拒绝值将是一个React\\Promise\\Exception\\CompositeException, 其中包含(count($promisesOrValues)-$howMany)+1拒绝原因。 拒绝原因可以通过CompositeException::getExceptions()获得。 如果$promisesOrValues包含的项目少于$howMany，则返回的承诺也将被拒绝， 并带有React\\Promise\\Exception\\LengthException。 map() $promise = React\\Promise\\map(array $promisesOrValues, callable $mapFunc); 传统的map函数，类似于array_map()，但允许输入包含承诺 和/或 值，$mapFunc可以返回值或承诺。 map函数接收每个项作为参数，其中item是$promisesOrValues中的promise或value的完全解析值。 reduce() $promise = React\\Promise\\reduce(array $promisesOrValues, callable $reduceFunc, $initialValue = null); 传统的reduce函数，类似于array_reduce()，但输入可以包含承诺 和/或 值， $reduceFunc可以返回值或承诺 和 $initialValue可以是承诺或起始值。 PromisorInterface React\\Promise\\PromisorInterface提供实现承诺的公共接口。 React\\Promise\\Deferred实现了它，但是由于它是公共API的一部分，任何人都可以实现它。 示例 如何使用Deferred function getAwesomeResultPromise() { $deferred = new React\\Promise\\Deferred(); // Execute a Node.js-style function using the callback pattern computeAwesomeResultAsynchronously(function (\\Throwable $error, $result) use ($deferred) { if ($error) { $deferred->reject($error); } else { $deferred->resolve($result); } }); // Return the promise return $deferred->promise(); } getAwesomeResultPromise() ->then( function ($value) { // Deferred resolved, do something with $value }, function (\\Throwable $reason) { // Deferred rejected, do something with $reason } ); 承诺转发的工作原理 几个简单的例子来展示promise/A转发机制是如何工作的。 当然，这些示例是精心设计的，在实际使用中，承诺链通常会分布在几个函数调用中，甚至是应用程序架构的几个级别。 转发履行 已履行承诺将值转发给下一个承诺。 第一个承诺$deferred->promise()将用下面传递给$deferred->resolve()的值来进行解析。 每次调用then()都会返回一个新的承诺，该承诺将使用前一个处理程序的返回值进行解析。这里创建了一个承诺“管道”。 $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { // $x will be the value passed to $deferred->resolve() below // and returns a *new promise* for $x + 1 return $x + 1; }) ->then(function ($x) { // $x === 2 // This handler receives the return value of the // previous handler. return $x + 1; }) ->then(function ($x) { // $x === 3 // This handler receives the return value of the // previous handler. return $x + 1; }) ->then(function ($x) { // $x === 4 // This handler receives the return value of the // previous handler. echo 'Resolve ' . $x; }); $deferred->resolve(1); // Prints \"Resolve 4\" 转发拒绝 被拒绝的承诺的行为与try/catch类似，工作方式也与此类似:当你捕获一个异常时，你必须重新抛出进而继续向下传播。 同样，当您处理被拒绝的承诺时且传播拒绝，需通过返回被拒绝的承诺或实际抛出“重新抛出”它（因为promise将抛出的异常转换为拒绝） $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { throw new \\Exception($x + 1); }) ->otherwise(function (\\Exception $x) { // Propagate the rejection throw $x; }) ->otherwise(function (\\Exception $x) { // Can also propagate by returning another rejection return React\\Promise\\reject( new \\Exception($x->getMessage() + 1) ); }) ->otherwise(function ($x) { echo 'Reject ' . $x->getMessage(); // 3 }); $deferred->resolve(1); // Prints \"Reject 3\" 转发履行和拒绝 就像try/catch一样，您可以选择是否传播。转发履行和拒绝仍将以可预测的方式转发回调结果。 $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { return $x + 1; }) ->then(function ($x) { throw new \\Exception($x + 1); }) ->otherwise(function (\\Exception $x) { // Handle the rejection, and don't propagate. // This is like catch without a rethrow return $x->getMessage() + 1; }) ->then(function ($x) { echo 'Mixed ' . $x; // 4 }); $deferred->resolve(1); // Prints \"Mixed 4\" done() vs. then() 黄金法则是: 返回您的诺言，或调用done()方法. 乍一看，then() 和 done()看起来非常相似。 但是，有重要的区别。 then()的目的是转换promise的值，并将转换后的值传递或返回一个新的promise到代码的其他部分。 done()的目的是消费promise的值，并将转换后的值转移到代码中。 除了转换值之外，then()还允许您从中间错误中恢复或传播。 未处理的任何错误都将由Promise机制捕获，并用于拒绝then()返回的承诺。 调用done()将错误的所有责任转移到代码中。 如果错误（抛出的异常或返回的拒绝）未能在您提供done()的$onFulfilled 或 $onRejected回调中捕获，它将导致致命错误。 function getJsonResult() { return queryApi() ->then( // Transform API results to an object function ($jsonResultString) { return json_decode($jsonResultString); }, // Transform API errors to an exception function ($jsonErrorString) { $object = json_decode($jsonErrorString); throw new ApiErrorException($object->errorMessage); } ); } // Here we provide no rejection handler. If the promise returned has been // rejected, the ApiErrorException will be thrown getJsonResult() ->done( // Consume transformed object function ($jsonResultObject) { // Do something with $jsonResultObject } ); // Here we provide a rejection handler which will either throw while debugging // or log the exception getJsonResult() ->done( function ($jsonResultObject) { // Do something with $jsonResultObject }, function (ApiErrorException $exception) { if (isDebug()) { throw $exception; } else { logException($exception); } } ); Credits 承诺是 when.js 的一部分，作者Brian Cavalier. 而且，大部分文档都是来源于when.js Wiki 和 API docs. License Released under the MIT license. "},"1.Core-Components/Stream.html":{"url":"1.Core-Components/Stream.html","title":"Stream","keywords":"","body":"Stream 事件驱动的可读流和可写流，用于 ReactPHP 中的非阻塞I/O 为了使 EventLoop 更容易使用，该组件引入了强大的“流”概念。 流允许您以小块的方式高效地处理大量数据(比如一个多GB的文件下载)，而不必一次将所有数据存储在内存中。 与PHP中的流非常相似，但有一个更适合异步、非阻塞I/O的接口。 目录 Stream用法 ReadableStreamInterface data事件 end事件 error事件 close事件 isReadable() pause() resume() pipe() close() WritableStreamInterface drain事件 pipe事件 error事件 close事件 isWritable() write() end() close() DuplexStreamInterface Creating streams ReadableResourceStream WritableResourceStream DuplexResourceStream ThroughStream CompositeStream 用法 安装 测试 License More stream用法 ReactPHP在其整个生态系统中使用“流”的概念，为处理任意数据内容和大小的流提供一致的高级抽象。 虽然流本身是一个非常底层的概念，但它可以作为一个强大的抽象来构建更高级的组件和协议。 如果你不熟悉这个概念，可以把它们想象成水管(pipe): 你可以从一个水源中取水，也可以产生水并将其输送到任何目的地水槽(sink)。 同样，流可以是 可读(如STDIN终端输入)或 可写(如STDOUT终端输出)或 双工(既可读又可写，例如TCP/IP连接) 因此，这个包定义了以下三个接口 ReadableStreamInterface WritableStreamInterface DuplexStreamInterface ReadableStreamInterface ReadableStreamInterface 负责为只读流和双工流的可读端。 除了定义一些方法之外，这个接口还实现了EventEmitterInterface允许你对特定的事件做出响应。 事件回调函数必须是一个有效的 callable ，遵守严格的参数定义，并且必须完全按照文档中描述的那样接受事件参数。 事件回调函数绝不能抛出Exception。 事件回调函数的返回值将被忽略，并且没有任何效果，因此出于性能原因，建议您不要返回任何过多的数据结构。 这个接口的每个实现都必须遵循这些事件语义，才能被认为是合法的流。 请注意，此接口的高级实现可能会选择使用专用语义来定义附加事件， 这些专用语义未定义为此低级流规范的一部分。 与这些事件语义的一致性超出了此接口的范围， 因此您可能还必须参考此类更高级别实现的文档。 data事件 当从该源流读取/接收数据时，将触发data事件。事件接收传入数据的单个混合参数。 $stream->on('data', function ($data) { echo $data; }); 该事件可能被触发任意次，如果该流根本不发送任何数据，则可能为零次。 在end或close事件之后不应该触发它。 给定的$data参数可能是混合类型，但通常建议它应该是string值， 或者可以使用允许表示为string的类型，以实现最大的兼容性。 许多常见流(如TCP/IP连接或基于文件的流)将发出原始(二进制)有效负载数据， 这些数据通过网络接收为string值块。 由于这种基于流的特性，发送方可以发送任意数量不同大小的块。 不能保证接收到的数据块与发送方打算发送的帧完全相同。 换句话说，许多底层协议(如TCP/IP)以块的形式传输数据， 这些块可能介于单字节到几十千字节之间。 为了实现正确的消息帧，您可能需要对这些数据块应用更高级别的协议。 end事件 源流成功到达流尾(EOF)后，将触发end事件。 $stream->on('end', function () { echo 'END'; }); 该事件最多触发一次，或者根本不触发，这取决于是否检测到成功结束。 它不应该在前一个end或close事件之后触发。 如果流未成功结束而关闭（例如在前一个close事件之后），则不能触发该事件。 流结束后，必须切换到不可读模式，另请参见isReadable() 只有成功到达end时才会触发此事件，如果流被不可恢复的错误中断或显式关闭则不会触发此事件。 并不是所有的流都知道“成功的结束”这个概念。 许多用例涉及检测流何时关闭(终止)，在这种情况下，您应该使用close事件。 流发出end事件后，通常应该跟在close事件后面。 如果远程端关闭连接或成功读取文件句柄直到其结束(EOF)，许多公共流（如TCP/IP连接或基于文件的流）都将发出此事件。 请注意，不应将此事件与end()方法混淆。 此事件定义从源流读取的成功结束，而end()方法定义向目标流写入的成功结束。 error事件 通常是在尝试从该流读取时发生致命错误，则会触发error事件。 事件为错误实例接收一个Exception参数。 $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); 一旦流检测到致命错误（如致命的传输错误）或意外的data或过早的end事件之后，就会触发此事件。 它不应在前一个error, end 或 close事件之后触发。 如果这不是致命的错误情况，例如没有导致任何数据丢失的临时网络问题，则不会触此事件。 出现流错误后，它必须关闭流，因此后面应该有一个close事件， 然后切换到不可读模式，另请参见close()和isReadable()。 许多常见的流（例如TCP/IP连接或基于文件的流）只处理数据传输， 并不对数据边界进行假设（例如意外的data或过早的end事件）。 换言之，许多较底层的协议（例如TCP/IP）可能会选择只在出现致命传输错误时触发事件，并在响应时关闭(终止)流。 如果这个流是DuplexStreamInterface，你也应该注意到流的可写端也实现了error事件。 换句话说，在读取或写入流时可能发生错误，这应该导致相同的错误处理。 close事件 一旦流关闭（终止），将触发close事件。 $stream->on('close', function () { echo 'CLOSED'; }); 根据流是否终止，这个事件应该被触发一次，或者根本不触发。 它不应该在前一个close事件之后触发。 流关闭后，必须切换到不可读模式， 另请参见isReadable()。 与end事件不同，每当流关闭时都应触发此事件，而不管此事件是由于不可恢复的错误隐式发生的，还是在任何一方关闭流时显式发生的。 如果只想检测成功结束，则应改用end事件。 许多常见的流（例如TCP / IP连接或基于文件的流）很可能在读取成功结束事件或致命的传输错误事件之后选择触发此事件。 如果此流是DuplexStreamInterface，则您还应该注意该流的可写端close事件的实现。 换句话说，在接收到该事件之后，流必须切换到不可写和不可读取模式，另请参见 isWritable()。 注意，该事件不应与end事件混淆。 isReadable() isReadable(): bool方法可用于检查此流是否处于可读状态（尚未关闭）。 此方法可用于检查流是否仍然接受传入的数据事件，或者它是否已结束或关闭。 一旦流不可读，就不再发出data或end事件。 assert($stream->isReadable() === false); $stream->on('data', assertNeverCalled()); $stream->on('end', assertNeverCalled()); 成功打开的流始终必须以可读模式启动。 一旦流结束或关闭，它必须切换到非可读模式。 这可以随时发生，通过close()显式地发生，或者由于远程关闭或不可恢复的传输错误而隐式地发生。 流一旦切换到非可读模式，就绝不能回到可读模式。 如果此流是DuplexStreamInterface，则您还应该注意该流的可写端isWritable()方法的实现。 除非这是一个半开双工流，否则它们通常应该具有相同的返回值。 pause() pause(): void方法可用于暂停读取传入的数据事件。 从事件循环中删除数据源文件描述符。 这使您可以限制传入的数据。 除非另有说明，否则成功打开的流不应暂停。 流暂停后，就不应再触发data或end事件 $stream->pause(); $stream->on('data', assertShouldNeverCalled()); $stream->on('end', assertShouldNeverCalled()); 该方法仅是建议性的，通常不建议调用，但该流可以继续emit(发出)data事件。 您可以通过再次调用resume()来继续处理事件。 注意，这两种方法都可以被调用多次，多次调用pause()无效。 另见resume() resume() resume(): void 方法可用于恢复data事件。 在pause()之后重新连接数据源。 $stream->pause(); $loop->addTimer(1.0, function () use ($stream) { $stream->resume(); }); 请注意，这两个方法都可以被调用任意次数，在没有pause()的情况下调用resume()无效。 请参见pause() pipe() pipe(WritableStreamInterface $dest, array $options = []) 方法可将此可读源中的所有数据通过管道传输到给定的可写目标源。 自动将所有传入数据发送到目标源。根据目标源可以处理的内容自动限制源。 $source->pipe($dest); 同样，您也可以通过管道将实现DuplexStreamInterface的实例导入自身，以便回写接收到的所有数据。 对于TCP/IP echo服务，这是一个有用的特性: $connection->pipe($connection); 这个方法按原样返回目标流，可以用来建立管道流链: $source->pipe($decodeGzip)->pipe($filterBadWords)->pipe($dest); 默认情况下，一旦源流发出end()事件，就会对目标流调用end()。可以这样禁用: $source->pipe($dest, array('end' => false)); 请注意，这只适用于end事件。 如果源流上发生 error 或显式close事件，则您必须手动关闭目标流: $source->pipe($dest); $source->on('close', function () use ($dest) { $dest->end('BYE!'); }); 如果源流不可读（关闭状态），则这是不可操作的。 $source->close(); $source->pipe($dest); // 禁止操作 如果目标流不可写（关闭状态），则这将简单地限制（暂停）源流: $dest->close(); $source->pipe($dest); // calls $source->pause() 同样，如果目标流在管道仍处于活动状态时关闭，它还将限制（暂停）源流: $source->pipe($dest); $dest->close(); // calls $source->pause() 一旦管道成功设置，目标流必须发出一个pipe事件，源流必须有一个 event 参数。 close() close(): void 方法可以用来关闭流(强制)。 $stream->close(); 一旦流被关闭，它应该触发一个close事件。 请注意，此事件不应触发多次。 调用此方法后，流必须切换到不可读模式，另请参见isReadable()。 这意味着不应再触发data或end事件。 $stream->close(); assert($stream->isReadable() === false); $stream->on('data', assertNeverCalled()); $stream->on('end', assertNeverCalled()); 如果此流是DuplexStreamInterface，则还应该注意流的可写端close()方法的实现。 换句话说，调用此方法后，流必须切换到不可写和不可读模式，另请参见iswriteable()。 请注意，此方法不应与end()方法混淆。 WritableStreamInterface WritableStreamInterface 为只写流和双工流的可写端接口。 除了定义一些方法外，这个接口还实现了EventEmitterInterface，它允许您对某些事件做出反应。 事件回调函数必须是一个有效的callable，它遵循严格的参数定义，并且必须完全按照文档所示接受事件参数。 事件回调函数不能抛出Exception。 事件回调函数的返回值将被忽略并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 此接口的每个实现都必须遵循这些事件语义，才能被视为合法的流。 请注意，此接口的更高级别的实现可以选择使用未定义为该底层级别流规范一部分的专用语义来定义其他事件。 与这些事件语义的一致性超出了此接口的范围，因此您可能还必须参考此类更高级别的实现的文档。 drain事件 每写入缓冲区满时且有更多数据到达时，就会发出drain事件。 $stream->on('drain', function () use ($stream) { echo 'Stream is now ready to accept more data'; }); 每写入缓冲区满时且有更多数据到达时，就会发出drain事件。 换句话说，这个事件可以被触发多次，如果缓冲区不满，则该事件可能是零次。 如果缓冲区不满，则不应触发此事件。 该事件主要在内部使用，有关更多详细信息，请参见write() pipe事件 当一个可读流pipe()进入数据时，pipe事件将被触发。 事件接收源流的一个ReadableStreamInterface参数。 $stream->on('pipe', function (ReadableStreamInterface $source) use ($stream) { echo 'Now receiving piped data'; // explicitly close target if source emits an error $source->on('error', function () use ($stream) { $stream->close(); }); }); $source->pipe($stream); 对于每个成功导入目标流的可读流，此事件必须触发一次。 换句话说，这个事件可以被触发多次，如果没有数据流通过管道进入这个流，则可能是零次。 如果源不可读(已经关闭)或目标不可写(已经关闭)，则绝不能触发此事件。 此事件主要在内部使用，请参阅pipe()了解更多细节。 error 事件 一旦发生致命错误，则会触发error事件，通常是在试图写入该流时。 事件为错误实例接收一个Exception对象参数。 $stream->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); 一旦流检测到致命错误(例如致命传输错误)，就会触发此事件。 它不应该在前一个error 或 close事件之后触发。 如果不出现一个致命的错误情况，例如没有导致任何数据丢失的临时网络问题，则不会触发。 在流出错后，它必须关闭流，因此应该紧跟着一个close事件，然后切换到非可写模式，参见close()和isWritable()。 许多常见流（例如TCP / IP连接或基于文件的流）仅处理数据传输，并且可能会选择仅针对致命的传输错误触发一次，然后将其关闭（终止）作为响应。 如果这个流是一个DuplexStreamInterface，您还应该注意流的可读端error事件的实现。 换句话说，在读取或写入流时可能发生错误，这将导致相同的错误处理。 close 事件 一旦流关闭（终止），将发出close事件。 $stream->on('close', function () { echo 'CLOSED'; }); 根据流是否终止，此事件应触发一次或从不触发。 它不会在前一个close事件之后触发。 流关闭后，必须切换到不可写模式， 另请参见isWritable() 无论是由于不可恢复的错误而隐式触发还是在任何一方关闭流时显式触发，只要流关闭，都应触发此事件。 许多常见的流(例如TCP/IP连接或基于文件的流)可能会选择在end()方法刷新缓冲区后、在接收到成功 end 事件或致命的传输error事件后触发此事件。 如果此流是DuplexStreamInterface，则还应注意该流的可读端close事件的实现。 换句话说，接收到该事件后，流必须切换到不可写和不可读取模式，另请参见isReadable()。 注意，该事件不应与end事件混淆。 isWritable() isWritable(): bool方法可用于检查此流是否处于可写状态（尚未关闭）。 此方法可用于检查流是否仍接受写入数据，或者是否已结束或关闭。 将数据写入不可写流是不可操作的: assert($stream->isWritable() === false); $stream->write('end'); // NO-OP $stream->end('end'); // NO-OP 成功打开的流必须始终以可写模式。 一旦流结束或关闭，它必须切换到不可写模式。 这种情况随时可能发生，可以通过end()或close()显式发生，也可以由于远程关闭或不可恢复的传输错误而隐式发生。 一旦流切换到不可写模式，它就不能转换回可写模式。 如果此流是DuplexStreamInterface实现，则还应该注意流的可读端isReadable()方法的实现。除非这是半开放双工流，否则它们通常应该具有相同的返回值。 write() 使用write(mixed $data): bool方法将数据写入流。 必须使用布尔值true来确认成功写入，这意味着要么立即写入（刷新）数据，要么对数据进行缓冲和调度以备将来写入。 请注意，这个接口无法控制显式刷新缓冲数据，因为寻找合适的刷新时间超出了这个接口的范围，要由这个接口的实现来决定。 许多常见的流（例如TCP / IP连接或基于文件的流）可以选择缓冲所有给定的数据，并通过使用底层的EventLoop来检查资源何时实际可写来计划将来的刷新。 如果流不能处理写入（或刷新）数据的操作，它应该发出一个error事件，如果流不能从这个错误中恢复，则可能close()该流。 如果在添加$data后内部缓冲区已满，那么write()应该返回false，表明调用者应该停止发送数据，直到缓冲区耗尽。 一旦缓冲区准备好接受更多数据，流应该发送drain事件。 同样，如果流是不可写的(已经处于关闭状态)，它一定不能处理给定的$data，并且应该返回false，表明调用者应该停止发送数据。 给定的$data参数可能是混合类型，但通常建议它应该是一个string值，或者使用允许转化为string的类型，以最大限度地兼容。 许多常见的流（例如TCP / IP连接或基于文件的流）仅接受原始（二进制）有效载荷数据，这些数据通过网络作为string值的块传输。 由于这种基于流的特性，发送方可以发送任意数量大小不同的块。无法保证这些数据块将以发送方打算发送的完全相同的顺序接收。 换言之，许多较底层的协议（如TCP/IP）以块的形式传输数据，这些块的大小可能介于单个字节到几十千字节之间。 您需要对这些数据块应用更高级的协议，以便实现正确的消息帧。 end() end(mixed $data = null): void方法可用于成功结束流（可选地发送一些最终数据）。 这个方法可以用来成功地结束流，例如，在发送出所有当前缓存的数据后关闭流。 $stream->write('hello'); $stream->write('world'); $stream->end(); 如果当前没有缓冲的数据，也没有需要刷新的数据，那么这个方法可以立即close()流。 如果缓冲区中仍有需要首先刷新的数据，则该方法应该尝试写出这些数据，然后才使用close()关闭流。 一旦流关闭，它会触发close事件。 请注意，这个接口无法控制显式刷新缓冲数据，因为寻找合适的刷新时间超出了这个接口的范围，要由这个接口的实现来决定。 许多常见的流（例如TCP / IP连接或基于文件的流）可以选择缓冲所有给定的数据，并通过使用底层的EventLoop来检查资源何时实际可写来计划将来的刷新。 您可以选择在结束流之前将一些最终数据传递给流。 如果将非null值指定为$data，则此方法的行为就像在没有结束之前调用write($data)一样。 // shorter version $stream->end('bye'); // same as longer version $stream->write('bye'); $stream->end(); 调用此方法后，流必须切换到不可写模式，另请参见isWritable()。 这意味着不可能再进行写操作，因此任何其他的write()或end()调用均无效。 $stream->end(); assert($stream->isWritable() === false); $stream->write('nope'); // NO-OP $stream->end(); // NO-OP 如果此流是DuplexStreamInterface实现，则调用此方法也应结束其可读端，除非该流支持半开模式。 换句话说，调用此方法后，这些流应该切换到不可写和不可读取的模式，另请参见isReadable() 这意味着在这种情况下，流不再应该发出任何data或end事件。 流可能会选择使用pause()方法逻辑，但必须特别注意确保对resume()方法的后续调用不应继续发出可读事件。 注意，该方法不应与close()方法混淆。 close() close(): void 方法可用于（强制）关闭流。 此方法可用于强制关闭流，即在不等待刷新任何缓冲数据的情况下关闭流。 如果缓冲区中仍有数据，则会丢弃此数据。 $stream->close(); 一旦流关闭，它应该发出一个close事件。 请注意，不应多次触发此事件。 调用此方法后，流必须切换到不可写模式，另请参见isWritable()。 这意味着不可能再进行写操作，因此任何其他的write()或end()调用均无效。 $stream->close(); assert($stream->isWritable() === false); $stream->write('nope'); // NO-OP $stream->end(); // NO-OP 注意，该方法不应与end()方法混淆。 与end()方法不同，此方法不处理任何现有缓冲区，而只是丢弃缓冲区内容。 同样，也可以在对流调用end()之后调用此方法，以停止等待流刷新其最终数据。 同样，为了停止等待流刷新其最终数据，也可以在流上调用end()之后调用此方法。 $stream->end(); $loop->addTimer(1.0, function () use ($stream) { $stream->close(); }); 如果此流是DuplexStreamInterface，则还应该注意流的可读端如何实现close() 方法。 换句话说，调用此方法后，流必须切换到不可写和不可读模式，另请参见isReadable()。 DuplexStreamInterface DuplexStreamInterface为双工流（可读写）提供接口。 它建立在用于可读和可写流的现有接口之上，并遵循完全相同的方法和事件语义。 如果您是这个概念的新手，则应该先阅读ReadableStreamInterface和WritableStreamInterface。 除了定义一些方法外，该接口还实现了EventEmitterInterface， 它使您能够对ReadbleStreamInterface和WritableStreamInterface上定义的相同事件做出反应。 事件回调函数必须是一个有效的callable，遵守严格的参数定义，并且必须完全按照文档中描述接受事件参数。 事件回调函数绝不能抛出Exception。 事件回调函数的返回值将被忽略，并且没有任何效果，因此出于性能原因，建议您不要返回任何过多的数据结构。 这个接口的每个实现都必须遵循这些事件语义，才能被认为是合法流。 请注意，此接口的高级实现可能会选择使用专用语义来定义附加事件， 这些专用语义未定义为此低级流规范的一部分。 与这些事件语义的一致性超出了此接口的范围， 因此您可能还必须参考此类更高级别实现的文档。 另请参阅 ReadableStreamInterface和WritableStreamInterface。 Creating streams ReactPHP在其整个生态系统中都使用streams的概念，所以这个包的许多高级用户只处理流使用。 流实例通常是在一些更高级别的组件中创建的，许多用户实际上从来不需要处理创建流实例的问题。 如果你想接受传入或建立传出的明文TCP/IP或安全TLS socket连接流，使用react/socket 如果你想接收一个http请求体流，请使用react/http 如果你想通过诸如STDIN, STDOUT, STDERR等进程管道与子进程通信，请使用react/child-process 如果你想对文件系统进行读写操作，请使用 react/filesystem 参见最后一章更多真实应用。 但是，如果您正在编写一个底层组件，或者想要从一个流资源创建一个流实例，那么下面的章节就是为您准备的。 请注意，以下示例使用fopen()和stream_socket_client()只是为了说明。 这些函数不应该在真正的异步程序中使用，因为每个调用可能需要几秒钟才能完成，否则将阻塞EventLoop。 此外，fopen() 调用将在某些平台上返回一个文件句柄，这可能是所有EventLoop实现所支持的，也可能不是。 作为一种替代方案，您可能希望使用上面列出的高级库。 ReadableResourceStream ReadableResourceStream是PHP流资源ReadableStreamInterface的具体实现。 这可以用来表示只读资源，比如以可读模式打开的文件流，或者像STDIN这样的流: $stream = new ReadableResourceStream(STDIN, $loop); $stream->on('data', function ($chunk) { echo $chunk; }); $stream->on('end', function () { echo 'END'; }); 请参阅ReadableStreamInterface. 构造函数的第一个参数必须是一个以读取模式打开的有效的流资源(例如:fopen()的模式r)。 否则，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException $stream = new ReadableResourceStream(false, $loop); 另请参阅DuplexResourceStream了解读写流资源。 该类内部试图在流资源上启用非阻塞模式，这可能不支持所有的流资源。 最值得注意的是，Windows上的管道(STDIN等)不支持这一点。 如果失败，它将抛出RuntimeException: // throws RuntimeException on Windows $stream = new ReadableResourceStream(STDIN, $loop); 一旦使用有效的流资源调用构造函数，该类将负责底层的流资源。 您应该只使用它的公共API，而不应该手动干扰底层的流资源。 该类接受一个可选参数int|null $readChunkSize，该参数控制一次从流中读取的最大缓冲区大小(以字节为单位)。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 这可以是一个正数，这意味着一次最多可以从底层流资源读取X个字节。注意，如果流资源当前可用的字节数小于X字节，则实际读取的字节数可能更低。 这可以是-1，表示从底层流资源中读取所有可用的内容。 这应该读取直到流资源不再可读(即底层缓冲区耗尽)，注意这并不一定意味着它到达了EOF。 $stream = new ReadableResourceStream(STDIN, $loop, 8192); PHP bug警告:如果PHP进程在没有STDIN流的情况下显式启动， 那么尝试从STDIN读取数据可能会从其他流资源返回数据。 如果以空流(如php test.php 而不是php test.php )开始，则不会发生这种情况。 请参阅#81 了解更多细节。 WritableResourceStream WritableResourceStream是PHP流资源的WritableStreamInterface的具体实现。 这可以用来表示只写的资源，比如以可写模式打开的文件流，或者像STDOUT或STDERR这样的流: $stream = new WritableResourceStream(STDOUT, $loop); $stream->write('hello!'); $stream->end(); 请参阅WritableStreamInterface 构造函数的第一个参数必须是打开用于写入的有效流资源。 否则，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException $stream = new WritableResourceStream(false, $loop); 另请参阅DuplexResourceStream了解读写流资源。 该类内部试图在流资源上启用非阻塞模式，这可能不支持所有的流资源。 最值得注意的是，Windows上的管道(STDOUT、STDERR等)不支持这一点。 如果失败，它将抛出RuntimeException: // throws RuntimeException on Windows $stream = new WritableResourceStream(STDOUT, $loop); 一旦使用有效的流资源调用构造函数，该类将负责底层的流资源。 您应该只使用它的公共API，而不应该手动干扰底层的流资源。 对这个类的任何write()调用都不会立即执行，而是在EventLoop报告流资源准备好接受数据后异步执行。 为此，它使用一个内存缓冲区字符串来收集所有未完成的写操作。 这个缓冲区应用了一个软限制，它定义了在调用者停止发送进一步数据之前，它愿意接受多少数据。 该类接受一个可选参数int|null $writeBufferSoftLimit，以字节为单位控制最大缓冲区大小。 您可以在这里使用null值来应用其默认值。 否则不应该更改此值，除非您知道自己在做什么。 $stream = new WritableResourceStream(STDOUT, $loop, 8192); 该类接受一个可选参数int|null $writeChunkSize，该参数以字节为单位控制一次写入流的最大缓冲区大小。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 这可以是一个正数，这意味着一次最多将写入X个字节到底层流资源。注意，如果流资源当前可用的字节数小于X字节，则实际写入的字节数可能更低。 这可以是-1，意思是将所有可用的内容写入底层流资源。 $stream = new WritableResourceStream(STDOUT, $loop, null, 8192); 请参阅write()了解更多细节。 DuplexResourceStream DuplexResourceStream是PHP流资源DuplexStreamInterface的具体实现。 用来表示读写资源，比如以读写模式打开的文件流，或者像TCP/IP连接这样的流: $conn = stream_socket_client('tcp://google.com:80'); $stream = new DuplexResourceStream($conn, $loop); $stream->write('hello!'); $stream->end(); 请参阅DuplexStreamInterface 了解更多细节。 构造函数的第一个参数必须是一个有效的流资源，该流资源被打开用于读取和写入。 否则，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException $stream = new DuplexResourceStream(false, $loop); 另请参阅只读的ReadableResourceStream和只写流资源的WritableResourceStream。 该类内部试图在流资源上启用非阻塞模式，这可能不支持所有的流资源。 最值得注意的是，Windows上的管道(STDOUT、STDERR等)不支持这一点。 如果失败，它将抛出RuntimeException: // throws RuntimeException on Windows $stream = new DuplexResourceStream(STDOUT, $loop); 一旦使用有效的流资源调用构造函数，该类将负责底层的流资源。 您应该只使用它的公共API，而不应该手动干扰底层的流资源。 该类接受一个可选参数int|null $readChunkSize，该参数控制一次从流中读取的最大缓冲区大小(以字节为单位)。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 这可以是一个正数，这意味着一次最多可以从底层流资源读取X个字节。注意，如果流资源当前可用的字节数小于X字节，则实际读取的字节数可能更低。 这可以是-1，表示从底层流资源中读取所有可用的内容。 这应该读取直到流资源不再可读(即底层缓冲区耗尽)，注意这并不一定意味着它到达了EOF。 $conn = stream_socket_client('tcp://google.com:80'); $stream = new DuplexResourceStream($conn, $loop, 8192); 对这个类的任何write()调用都不会立即执行，而是在EventLoop报告流资源准备好接受数据后异步执行。 为此，它使用一个内存缓冲区字符串来收集所有未完成的写操作。 这个缓冲区应用了一个软限制，它定义了在调用者停止发送进一步数据之前，它愿意接受多少数据。 这个类接受另一个可选参数WritableStreamInterface|null $buffer，控制这个流的写行为。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 如果你想改变写缓冲区软限制，你可以传递一个WritableResourceStream 的实例，像这样: $conn = stream_socket_client('tcp://google.com:80'); $buffer = new WritableResourceStream($conn, $loop, 8192); $stream = new DuplexResourceStream($conn, $loop, null, $buffer); 参见 WritableResourceStream 了解更多细节。 ThroughStream ThroughStream实现了DuplexStreamInterface ，并将任何你写入它的数据传递到它的可读端。 $through = new ThroughStream(); $through->on('data', $this->expectCallableOnceWith('hello')); $through->write('hello'); 同样，end() 方法将结束流并触发end，然后close()流。 close() 方法 将关闭流并发出close. 相应地，这也可以像这样在pipe()上下文中使用: $through = new ThroughStream(); $source->pipe($through)->pipe($dest); 可选，它的构造函数接受任何可调用的函数，然后这些函数将被用来 filter（过滤） 任何写入它的数据。 此函数在传递到可写端时接收单个数据参数，并且在传递到可读端时必须返回数据: $through = new ThroughStream('strtoupper'); $source->pipe($through)->pipe($dest); 请注意，这个类不假设任何数据类型。这可用于转换数据，例如将任何结构化数据转换为换行符分隔的JSON（NDJSON）流，如下所示: $through = new ThroughStream(function ($data) { return json_encode($data) . PHP_EOL; }); $through->on('data', $this->expectCallableOnceWith(\"[2, true]\\n\")); $through->write(array(2, true)); 允许回调函数抛出Exception。在这种情况下，流将发出一个error事件，然后close()流。 $through = new ThroughStream(function ($data) { if (!is_string($data)) { throw new \\UnexpectedValueException('Only strings allowed'); } return $data; }); $through->on('error', $this->expectCallableOnce())); $through->on('close', $this->expectCallableOnce())); $through->on('data', $this->expectCallableNever())); $through->write(2); CompositeStream CompositeStream实现了DuplexStreamInterface， 并可用于从两个分别实现ReadableStreamInterface和 WritableStreamInterface的单独流中创建一个双工流。 这对于一些可能需要单个DuplexStreamInterface 的api很有用， 或者只是因为像这样使用单个流实例通常更方便: $stdin = new ReadableResourceStream(STDIN, $loop); $stdout = new WritableResourceStream(STDOUT, $loop); $stdio = new CompositeStream($stdin, $stdout); $stdio->on('data', function ($chunk) use ($stdio) { $stdio->write('You said: ' . $chunk); }); 这是一个合法流，它从底层流转发所有的流事件，并将所有的流调用转发给底层流。 如果你 write() 写入双工流，它将简单地将 write() 写入可写端并返回其状态。 如果end()双工流，则可写流将end()，可读流将pause()。 如果close()双工流，两个输入流都将被关闭。 如果两个输入流中的任何一个发出close事件，双工流也将关闭。 如果两个输入流中的任何一个在构造双工流时已经关闭，它将close()另一端并返回一个关闭的流。 用法 下面的例子可以用来将源文件的内容管道到目标文件中，而不必将整个文件读入内存: $loop = new React\\EventLoop\\StreamSelectLoop; $source = new React\\Stream\\ReadableResourceStream(fopen('source.txt', 'r'), $loop); $dest = new React\\Stream\\WritableResourceStream(fopen('destination.txt', 'w'), $loop); $source->pipe($dest); $loop->run(); 注意，这个例子使用fopen()只是为了说明。 在真正的异步程序中不应该使用这种方法，因为文件系统本身就是阻塞的，而且每次调用都可能需要几秒钟的时间。 参见创建流获取更复杂的示例。 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/stream:^1.1.1 有关版本升级的详细信息，请参见CHANGELOG 。 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈推荐在这个项目中使用PHP 7+。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit 该测试套件还包含许多依赖稳定internet连接的功能集成测试。 如果您不想运行这些，则可以像这样跳过它们: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. More 有关在实际应用程序中如何创建流的更多信息，请参见创建流。 请参阅我们的用户Wiki 和Packagist依赖项 在实际应用程序中使用流的软件包列表。 "},"2.Network-Components/Datagram.html":{"url":"2.Network-Components/Datagram.html","title":"Datagram","keywords":"","body":"Datagram ReactPHP的事件驱动UDP数据报套接字客户端和服务器。 快速开始 安装后，可以使用以下代码连接到正在侦听localhost:1234的UDP服务器，发送和接收UDP数据报: $loop = React\\EventLoop\\Factory::create(); $factory = new React\\Datagram\\Factory($loop); $factory->createClient('localhost:1234')->then(function (React\\Datagram\\Socket $client) { $client->send('first'); $client->on('message', function($message, $serverAddress, $client) { echo 'received \"' . $message . '\" from ' . $serverAddress. PHP_EOL; }); }); $loop->run(); 参阅 示例. 用法 这个库的API是按照node建模的。UDP / Datagram Sockets (dgram.Socket) 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/datagram:^1.5 有关版本升级的详细信息，请参阅CHANGELOG 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过当前PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈建议对此项目使用PHP 7+。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"2.Network-Components/Socket.html":{"url":"2.Network-Components/Socket.html","title":"Socket","keywords":"","body":"Socket ReactPHP 的异步，流式纯文本TCP / IP以及安全的TLS套接字服务器和客户端连接。 套接字库基于EventLoop 和 Stream 组件为套接字层服务器和客户端提供了可重用的接口。 服务器组件允许您构建接受来自网络客户端连接的网络服务器(如HTTP服务器)。 客户端组件允许您构建建立到网络服务器外发连接的网络客户端(例如HTTP或数据库客户端)。 这个库为这些提供了异步、流的方式，因此您可以在不阻塞的情况下处理多个并发连接。 目录 快速开始 连接用法 ConnectionInterface getRemoteAddress() getLocalAddress() 服务端用法 ServerInterface connection event error event getAddress() pause() resume() close() Server 高级服务端使用 TcpServer SecureServer UnixServer LimitingServer getConnections() 客服端用法 ConnectorInterface connect() Connector 高级客户端使用 TcpConnector HappyEyeBallsConnector DnsConnector SecureConnector TimeoutConnector UnixConnector FixUriConnector 安装 测试 License 快速开始 如果您发送任何连接，这是一个关闭连接的服务器: $loop = React\\EventLoop\\Factory::create(); $socket = new React\\Socket\\Server('127.0.0.1:8080', $loop); $socket->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"Hello \" . $connection->getRemoteAddress() . \"!\\n\"); $connection->write(\"Welcome to this amazing server!\\n\"); $connection->write(\"Here's a tip: don't say anything.\\n\"); $connection->on('data', function ($data) use ($connection) { $connection->close(); }); }); $loop->run(); 另请参阅示例 这是一个客户端，该客户端输出服务器的输出，然后尝试向其发送字符串: $loop = React\\EventLoop\\Factory::create(); $connector = new React\\Socket\\Connector($loop); $connector->connect('127.0.0.1:8080')->then(function (React\\Socket\\ConnectionInterface $connection) use ($loop) { $connection->pipe(new React\\Stream\\WritableResourceStream(STDOUT, $loop)); $connection->write(\"Hello World!\\n\"); }); $loop->run(); 连接用法 ConnectionInterface ConnectionInterface 用于表示任何传入和传出的连接，例如普通的TCP / IP连接。 传入或传出连接是实现React DuplexStreamInterface 的双工流（可读和可写）。 它包含已建立到/来自此连接的本地和远程地址（客户端IP）的附加属性。 最常见的情况是，所有实现ServerInterface的类都会触发实现这个ConnectionInterface的实例， 并由所有实现ConnectorInterface的类使用。 因为ConnectionInterface实现了底层的DuplexStreamInterface 所以你可以像往常一样使用它的所有事件和方法: $connection->on('data', function ($chunk) { echo $chunk; }); $connection->on('end', function () { echo 'ended'; }); $connection->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage(); }); $connection->on('close', function () { echo 'closed'; }); $connection->write($data); $connection->end($data = null); $connection->close(); // … 更多细节，请参阅DuplexStreamInterface. getRemoteAddress() getRemoteAddress(): ?string 方法返回已经建立连接的完整远程地址(URI)。 $address = $connection->getRemoteAddress(); echo 'Connection with ' . $address . PHP_EOL; 如果此时无法确定或未知远程地址(比如在连接关闭后)，它可能会返回一个NULL值。 否则，它将返回完整地址(URI)作为字符串值，例如tcp://127.0.0.1:8080， tcp://[::1]:80， tls://127.0.0.1:443， unix://example.sock 或 unix:///path/to/example.sock 请注意，单个URI组件是特定于应用程序的，并依赖于底层传输协议。 如果这是一个基于TCP/IP的连接，而你只想要远程IP，你可以这样使用: $address = $connection->getRemoteAddress(); $ip = trim(parse_url($address, PHP_URL_HOST), '[]'); echo 'Connection with ' . $ip . PHP_EOL; getLocalAddress() getLocalAddress(): ?string 方法返回已经建立连接的完整本地地址(URI)。 $address = $connection->getLocalAddress(); echo 'Connection with ' . $address . PHP_EOL; 如果此时无法确定或未知本地地址(比如在连接关闭后)，它可能会返回一个NULL值。 否则，它将返回完整地址(URI)作为字符串值，例如tcp://127.0.0.1:8080， tcp://[::1]:80， tls://127.0.0.1:443， unix://example.sock 或 unix:///path/to/example.sock 请注意，单个URI组件是特定于应用程序的，并依赖于底层传输协议。 这个方法是getRemoteAddress() 方法的补充，所以不应该混淆它们。 如果你的TcpServer实例正在监听多个接口(例如使用地址0.0.0.0)， 你可以使用这个方法找出哪个接口实际上接受了这个连接(例如一个公共的或本地的接口)。 如果您的系统具有多个接口（例如WAN和LAN接口），则可以使用此方法找出实际用于该连接的接口。 服务端用法 ServerInterface ServerInterface 提供一个接收流连接的接口，比如一个正常的TCP/IP连接。 大多数更高级别的组件（例如HTTP服务器）都接受实现此接口的实例，以接受传入的流连接。 通常这是通过依赖项注入完成的，便于你将该实现替换为该接口的其他实现。 这意味着您应该对此接口进行类型提示，而不是对此接口的具体实现。 除了定义一些方法之外，这个接口还实现了EventEmitterInterface ，它允许您对某些事件作出反应。 connection event 当建立了一个新的连接时，就会触发connection事件，例如，一个新的客户端连接到这个服务器套接字: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'new connection' . PHP_EOL; }); 请参阅ConnectionInterface以获得有关处理传入连接的更多细节。 error event 当从客户端接收新连接时发生错误时，将触发error事件。 $server->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage() . PHP_EOL; }); 注意，这不是一个致命错误事件，也就是说，即使在这个事件之后，服务器仍然在监听新的连接。 getAddress() getAddress(): ?string 方法可以用来返回服务器当前正在监听的完整地址(URI)。 $address = $server->getAddress(); echo 'Server listening on ' . $address . PHP_EOL; 如果此时地址无法确定或未知(例如在套接字关闭后)，它可能会返回一个NULL值。 否则，它将返回完整地址(URI)作为字符串值，例如tcp://127.0.0.1:8080, tcp://[::1]:80, tls://127.0.0.1:443，unix://example.sock 或 unix:///path/to/example.sock 请注意，单个URI组件是特定于应用程序的，并依赖于底层传输协议。 如果这是一个基于TCP/IP的服务器，你只需要本地端口，你可以这样使用: $address = $server->getAddress(); $port = parse_url($address, PHP_URL_PORT); echo 'Server listening on port ' . $port . PHP_EOL; pause() pause(): void方法可以用于暂停接受新的传入连接。 从EventLoop中删除套接字资源，从而停止接受新连接。注意，监听套接字保持活动并不是关闭了。 这意味着新的传入连接将在操作系统backlog中保持挂起状态，直到其可配置的backlog被填满为止。 一旦积压被填满，操作系统可能会拒绝新传入的连接，直到再次通过恢复接受新的连接来耗尽积压。 一旦服务器暂停，就不应该触发更多的connection事件。 $server->pause(); $server->on('connection', assertShouldNeverCalled()); 此方法仅供参考，但通常不推荐使用，服务器可以继续触发connection事件。 除非另有说明，成功打开的服务器不应在暂停状态下启动。 您可以通过再次调用resume()继续处理事件。 请注意，这两个方法都可以被调用多次，特别是多次调用pause()无效。 同样，在close()之后调用这个函数也是无效操作。 resume() resume(): void方法可以用来恢复接收新的连接。 在前一个pause()之后重新将套接字资源附加到EventLoop。 $server->pause(); $loop->addTimer(1.0, function () use ($server) { $server->resume(); }); 请注意，这两个方法都可以被多次调用，之前没有调用pause()函数，调用resume()无效。 同样，在close()之后调用这个函数也是一个无效操作。 close() close(): void方法可以用来关闭这个监听套接字。 这将停止侦听这个套接字上的新传入连接。 echo 'Shutting down server socket' . PHP_EOL; $server->close(); 在同一个实例上多次调用这个方法是无效的。 Server Server类是这个包中的主要类，它实现了ServerInterface， 并允许您接受传入的流连接，例如明文TCP/IP或安全TLS连接流。 Unix域套接字也可以接受连接。 $server = new React\\Socket\\Server(8080, $loop); 如上所示，$uri参数可以只包含一个端口，在这种情况下，服务器将默认侦听本地主机地址127.0.0.1，这意味着从系统外部无法访问该地址。 为了使用一个随机的端口分配，你可以使用端口0: $server = new React\\Socket\\Server(0, $loop); $address = $server->getAddress(); 为了改变套接字正在监听的主机，你可以给构造函数的第一个参数提供一个IP地址，可以在IP前面加上tcp://方案: $server = new React\\Socket\\Server('192.168.0.1:8080', $loop); 如果你想监听一个IPv6地址，你必须用方括号括起主机: $server = new React\\Socket\\Server('[::1]:8080', $loop); 要在Unix域套接字(UDS)路径上监听，必须在URI前面加上Unix://方案: $server = new React\\Socket\\Server('unix:///tmp/server.sock', $loop); 如果给定的URI无效，不包含端口，任何其他方案，或者包含主机名，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException due to missing port $server = new React\\Socket\\Server('127.0.0.1', $loop); 如果给定的URI看起来是有效的，但是监听失败(比如端口已经被使用或者端口低于1024可能需要root访问等等)， 它将抛出一个RuntimeException: $first = new React\\Socket\\Server(8080, $loop); // throws RuntimeException because port is already in use $second = new React\\Socket\\Server(8080, $loop); 请注意，这些错误条件可能因您的系统和/或配置而异。 有关实际错误条件的详细信息，请参阅异常消息和代码。 您还可以为底层流套接字资源指定TCP socket context options 如下所示: $server = new React\\Socket\\Server('[::1]:8080', $loop, array( 'tcp' => array( 'backlog' => 200, 'so_reuseport' => true, 'ipv6_v6only' => true ) )); 请注意，可用的socket context options, 它们的默认值和更改这些选项的效果可能会根据您的系统和/或PHP版本而有所不同，传递未知的上下文选项没有效果。 除非明确给出，否则backlog上下文选项默认为511。 出于BC原因，您还可以将TCP套接字上下文选项作为一个简单的数组传递，而不必将其包装在TCP键下的另一个数组中。 您可以启动一个安全TLS(以前称为SSL)服务器，只需在TLS:// URI前添加一个前缀。 它内部将等待明文TCP/IP连接，然后对每个连接执行TLS握手。 因此，它需要有效的TLS上下文选项 , 如果您使用PEM编码的证书文件,它在其最基本的形式可能看起来像这样: $server = new React\\Socket\\Server('tls://127.0.0.1:8080', $loop, array( 'tls' => array( 'local_cert' => 'server.pem' ) )); 注意，证书文件不会在实例化时加载，而是在传入连接初始化其TLS上下文时加载。 这意味着任何无效的证书文件路径或内容只会在以后的时间导致error事件。 如果您的私钥已使用密码加密，则必须像这样指定它: $server = new React\\Socket\\Server('tls://127.0.0.1:8000', $loop, array( 'tls' => array( 'local_cert' => 'server.pem', 'passphrase' => 'secret' ) )); 默认情况下，此服务器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本: $server = new React\\Socket\\Server('tls://127.0.0.1:8000', $loop, array( 'tls' => array( 'local_cert' => 'server.pem', 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_SERVER ) )); 请注意，使用TLS context options, 它们的默认值和更改这些值的效果可能会因您的系统和/或PHP版本而异。 外部上下文数组允许您同时使用tcp（可能还有更多）上下文选项。 传递未知的上下文选项无效。 如果您不使用tls://方案，那么传递tls上下文选项将无效。 每当客户端连接时，它将通过实现ConnectionInterface的连接实例触发connection事件: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Plaintext connection from ' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 另请参阅 ServerInterface 注意，Server类是TCP / IP套接字的具体实现。 如果要在更高级别的协议实现中类型提示，则应改用通用的 ServerInterface 高级服务端使用 TcpServer TcpServer类实现 ServerInterface，并负责接受明文TCP/IP连接。 $server = new React\\Socket\\TcpServer(8080, $loop); 如上所示，$uri参数可以只包含一个端口，在这种情况下，服务器将默认侦听本地主机地址127.0.0.1，这意味着从系统外部无法访问该地址。 为了使用一个随机的端口分配，你可以使用端口0: $server = new React\\Socket\\TcpServer(0, $loop); $address = $server->getAddress(); 为了改变套接字正在监听的主机，你可以通过提供给构造函数的第一个参数提供一个IP地址，在此参数之前有一个tcp://方案: $server = new React\\Socket\\TcpServer('192.168.0.1:8080', $loop); 如果你想监听一个IPv6地址，你必须用方括号括起主机: $server = new React\\Socket\\TcpServer('[::1]:8080', $loop); 如果给定的URI无效，不包含端口，任何其他方案，或者包含主机名，则将抛出InvalidArgumentException: // throws InvalidArgumentException due to missing port $server = new React\\Socket\\TcpServer('127.0.0.1', $loop); 如果给定的URI似乎有效，但是对其进行侦听失败（例如，如果端口已在使用中，或者端口低于1024，则可能需要root用户访问权限等）， 它将抛出RuntimeException: $first = new React\\Socket\\TcpServer(8080, $loop); // throws RuntimeException because port is already in use $second = new React\\Socket\\TcpServer(8080, $loop); 请注意，这些错误情况可能会因您的系统和/或配置而异。 有关实际错误情况的更多详细信息，请参阅异常消息和代码。 您还可以为底层流套接字资源指定socket context options ，如下所示: $server = new React\\Socket\\TcpServer('[::1]:8080', $loop, array( 'backlog' => 200, 'so_reuseport' => true, 'ipv6_v6only' => true )); 请注意，可用的socket context options, 它们的默认值和更改这些选项的效果可能会根据您的系统和/或PHP版本而有所不同，传递未知的上下文选项没有效果。 除非明确给出，否则backlog上下文选项默认为511。 当客户端连接时，它将发出一个connection事件，该事件的连接实例实现了 ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Plaintext connection from ' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 更多细节请参阅ServerInterface SecureServer SecureServer类实现了ServerInterface，负责提供安全的TLS(以前称为SSL)服务器。 它通过包装一个TcpServer实例实现，该实例等待明文TCP/IP连接，然后对每个连接执行TLS握手。 因此，它需要有效的TLS context options ， 如果您使用PEM编码的证书文件,其最基本的形式可能看起来像这样，: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem' )); 注意，证书文件不会在实例化时加载，而是在传入连接初始化其TLS上下文时加载。 这意味着任何无效的证书文件路径或内容只会在以后的时间导致error事件。 如果你的私钥是用密码加密的，你必须这样指定: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem', 'passphrase' => 'secret' )); 默认情况下，此服务器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem', 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_SERVER )); 请注意，使用TLS context options ， 它们的默认值和更改它们的效果可能会因系统和/或PHP版本而异。 传递未知的上下文选项无效。 每当客户端完成TLS握手时，它将发出带有实现ConnectionInterface的连接实例的connection事件: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Secure connection from' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 每当客户端未能成功执行TLS握手时，客户端都会触发error事件，然后关闭基础TCP / IP连接: $server->on('error', function (Exception $e) { echo 'Error' . $e->getMessage() . PHP_EOL; }); 另请参阅ServerInterface 请注意，SecureServer类是TLS套接字的具体实现。 如果你想在高级协议实现中类型提示，你应该使用通用的ServerInterface来代替。 高级用法:尽管允许将任何ServerInterface作为第一个参数，但应该将TcpServer实例作为第一个参数传递，除非您知道自己在做什么。 SecureServer内部必须在底层流资源上设置所需的TLS上下文选项。 这些资源不会通过此包中定义的任何接口，而只能通过内部Connection类公开。 TcpServer类保证发出实现ConnectionInterface的连接，并使用内部Connection类来公开这些底层资源。 如果使用自定义ServerInterface且其connection事件不满足此要求，SecureServer将触发error事件，然后关闭连接。 UnixServer UnixServer类实现了ServerInterface，并负责接受Unix域套接字(UDS)上的连接。 $server = new React\\Socket\\UnixServer('/tmp/server.sock', $loop); 如上所示，$uri参数只能由一个套接字路径或以unix://方案为前缀的套接字。 如果给定的URI看起来是有效的，但是监听失败(比如socket已经在使用或者文件不能访问等等)， 它将抛出一个RuntimeException: $first = new React\\Socket\\UnixServer('/tmp/same.sock', $loop); // throws RuntimeException because socket is already in use $second = new React\\Socket\\UnixServer('/tmp/same.sock', $loop); 请注意，这些错误条件可能因您的系统和/或配置而异。 特别是，当UDS路径已经存在且不能被绑定时，Zend PHP只会报告\"Unknown error\"。 在这种情况下，您可能需要检查指定UDS路径上的is_file()，以报告更友好的错误消息。 有关实际错误条件的详细信息，请参阅异常消息和代码。 当客户端连接时，它将发出一个connection事件，该事件的连接实例实现了 ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'New connection' . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 更多细节请参阅 ServerInterface LimitingServer LimitingServer装饰器包装了一个给定的ServerInterface，并负责限制和跟踪到这个服务器实例的打开连接。 每当底层服务器发出connection事件时，将检查其限制，做出以下两种情况之一 通过将该连接添加到打开的连接列表中来跟踪该连接，然后触发connection事件 或者当连接超出限制时拒绝(关闭)连接，并将触发error事件。 当一个连接关闭时，它将从打开的连接列表中删除该连接。 $server = new React\\Socket\\LimitingServer($server, 100); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); 更多细节请参阅第二个示例 您必须传递打开连接的最大数量，以确保一旦超过这个限制，服务器将自动拒绝(关闭)连接。 在本例中，它将发出一个error事件来通知此情况，而不会触发connection事件。 $server = new React\\Socket\\LimitingServer($server, 100); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); 您可以传递一个null限制，以便不限制打开连接的数量，并一直接受新连接，直到耗尽操作系统资源(例如打开的文件句柄)。 如果您不想注意应用限制，但仍然想使用getConnections()方法，这很有用。 您可以配置服务器连接限制上限设置，到达上限就暂停接受新连接。在这种情况下，它将暂停底层服务器，不再处理任何新连接，因此也不再关闭任何过多的连接。 底层操作系统负责保持等待连接的积压，直到达到极限为止，此时它将开始拒绝新的连接。 当服务器低于连接限制，它将继续使用backlog中的连接，并在每个连接上处理未完成的数据。 这种模式对于一些设计为等待响应消息的协议(比如HTTP)可能很有用，但是对于要求立即响应的其他协议(比如交互式聊天中的“welcome”消息)就不适用了。 $server = new React\\Socket\\LimitingServer($server, 100, true); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); getConnections() getConnections(): ConnectionInterface[]方法可以用来返回一个包含所有当前活动连接的数组。 foreach ($server->getConnection() as $connection) { $connection->write('Hi!'); } 客服端用法 ConnectorInterface ConnectorInterface 提供一个用于建立流连接的接口，例如普通的TCP / IP连接。 这是此包中定义的主要接口，并且在整个React的广阔生态系统中使用。 大多数更高级别的组件（例如HTTP，数据库或其他网络服务客户端）都接受实现此接口的实例，创建其与基础网络服务的TCP / IP连接。 通常这是通过依赖项注入完成的，便于你将该实现替换为该接口的其他实现。 该接口仅提供一种方法: connect() connect(string $uri): PromiseInterface方法可用于创建到给定远程地址的流式连接。 返回一个Promise ， 它在成功时以实现ConnectionInterface的流来实现， 或者在连接不成功时以Exception拒绝。 : $connector->connect('google.com:443')->then( function (React\\Socket\\ConnectionInterface $connection) { // connection successfully established }, function (Exception $error) { // failed to connect due to $error } ); 另请参阅ConnectionInterface 返回的Promise必须以这样的方式实现:在尚待处理时可以将其取消。 取消未决的承诺必须以Exception拒绝其值。 它应清理所有适用的基础资源和参考: $promise = $connector->connect($uri); $promise->cancel(); Connector Connector类是这个包中的主要类，它实现了ConnectorInterface接口，并允许您创建流连接。 您可以使用此连接器创建任何类型的流连接，例如明文TCP/IP、安全TLS或本地Unix连接流。 它绑定到主事件循环，可以像这样使用: $loop = React\\EventLoop\\Factory::create(); $connector = new React\\Socket\\Connector($loop); $connector->connect($uri)->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 为了创建一个明文TCP/IP连接，你可以简单地传递一个主机和端口组合: $connector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 如果你没有在目标URI中指定一个URI方案，它将假定tcp://为默认值，并建立一个明文TCP/IP连接。 注意，TCP/IP连接需要目的地主机和端口 像上面一样，所有其他URI组件都是可选的。 In order to create a secure TLS connection, you can use the tls:// URI scheme like this: 创建一个安全的TLS连接，你可以使用tls:// URI方案: $connector->connect('tls://www.google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 创建一个本地的Unix域套接字连接，你可以使用unix:// URI方案: $connector->connect('unix:///tmp/demo.sock')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); getRemoteAddress()方法将返回给定给connect()方法的目标Unix域套接字(UDS)路径， 包括unix://方案，例如unix:///tmp/demo.sock。 getLocalAddress()方法很可能返回一个null值，因为这个值不适用于这里的UDS连接。 在底层，Connector被实现为此软件包中实现的较低层连接器的高层门面。 这意味着它还共享所有功能和实现细节。 如果要在更高级别的协议实现中类型提示，则应改用通用的ConnectorInterface 从v1.4.0开始，Connector类默认使用happy eyeballs algorithm 在指定主机名时自动通过IPv4或IPv6连接。 它会自动尝试同时使用IPv4和IPv6连接(更偏向IPv6)，从而避免用户使用不完善的IPv6连接或设置所面临的常见问题。 如果你想恢复到只做一个IPv4查找并且只尝试一个IPv4连接的旧行为，你可以这样设置Connector: $connector = new React\\Socket\\Connector($loop, array( 'happy_eyeballs' => false )); 同样，您还可以如下影响默认的DNS行为。 Connector类将尝试检测您的系统DNS设置（如果无法确定您的系统设置，并使用Google的公共DNS服务器8.8.8.8作为备用）， 默认情况下会将所有公共主机名解析为基础IP地址。 如果您确定要使用自定义DNS服务器（例如本地DNS中继或公司范围的DNS服务器），则可以按以下方式设置Connector: $connector = new React\\Socket\\Connector($loop, array( 'dns' => '127.0.1.1' )); $connector->connect('localhost:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 如果您想直接连接IP地址，不使用DNS解析器，可以这样设置Connector: $connector = new React\\Socket\\Connector($loop, array( 'dns' => false )); $connector->connect('127.0.0.1:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 高级:如果你需要一个自定义的DNS React\\Dns\\Resolver\\ResolverInterface实例，你也可以这样设置你的连接器: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $resolver = $dnsResolverFactory->createCached('127.0.1.1', $loop); $connector = new React\\Socket\\Connector($loop, array( 'dns' => $resolver )); $connector->connect('localhost:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 默认情况下，tcp:// 和 tls:// URI方案将使用超时值，遵循default_socket_timeout ini 设置(默认为60s)。 如果你想要一个自定义的超时值，你可以这样设置: $connector = new React\\Socket\\Connector($loop, array( 'timeout' => 10.0 )); 同样，如果你不想使用超时，并让操作系统处理它，你可以传递一个bool标志，像这样: $connector = new React\\Socket\\Connector($loop, array( 'timeout' => false )); 默认情况下，Connector支持tcp://, tls:// 和 unix:// URI模式。 如果你想禁止用，你可以这样设置: // 只允许安全的TLS连接 $connector = new React\\Socket\\Connector($loop, array( 'tcp' => false, 'tls' => true, 'unix' => false, )); $connector->connect('tls://google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); tcp:// 和 tls://也接受传递给底层连接器附加的上下文选项。 如果你想显式地传递额外的上下文选项，你可以想这样传递上下文选项数组: // 允许不安全的TLS连接 $connector = new React\\Socket\\Connector($loop, array( 'tcp' => array( 'bindto' => '192.168.0.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ), )); $connector->connect('tls://localhost:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 默认情况下，此连接器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本: $connector = new React\\Socket\\Connector($loop, array( 'tls' => array( 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT ) )); 有关上下文选项的更多详细信息，请参阅有关socket context options 和SSL context options 高级:默认情况下，Connector支持tcp://, tls:// 和 unix:// URI方案。 为此，它会自动设置所需的连接器类。如果您想显式传递自定义连接器， 则可以传递一个实现ConnectorInterface的实例，如下所示: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $resolver = $dnsResolverFactory->createCached('127.0.1.1', $loop); $tcp = new React\\Socket\\HappyEyeBallsConnector($loop, new React\\Socket\\TcpConnector($loop), $resolver); $tls = new React\\Socket\\SecureConnector($tcp, $loop); $unix = new React\\Socket\\UnixConnector($loop); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $tcp, 'tls' => $tls, 'unix' => $unix, 'dns' => false, 'timeout' => false, )); $connector->connect('google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); tcp://连接器将始终由DNS解析器包装，禁用DNS除外。 在这种情况下，tcp://连接器将接收实际的主机名执行查找，而不是仅接收解析的IP地址。 在内部，自动创建的tls://连接器始终包装基础的tcp://连接器， 以在启用安全TLS模式之前建立基础的纯文本TCP / IP连接。 如果您只想将自定义基础tcp://连接器仅用于安全的TLS连接，则可以像上面那样显式地传递tls://连接器。 tcp://和tls://连接器将始终由TimeoutConnector包装，禁用超时除外。 高级客户端使用 TcpConnector TcpConnector类实现ConnectorInterface，并允许您创建到任何IP端口组合的纯文本TCP / IP连接: $tcpConnector = new React\\Socket\\TcpConnector($loop); $tcpConnector->connect('127.0.0.1:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 参阅 示例. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示: $promise = $tcpConnector->connect('127.0.0.1:80'); $promise->cancel(); 对挂起的承诺调用cancel()将关闭底层套接字资源，从而取消挂起的TCP/IP连接，并拒绝生成的承诺。 您可以选择将其他socket context options 传递给构造函数，如下所示: $tcpConnector = new React\\Socket\\TcpConnector($loop, array( 'bindto' => '192.168.0.1:0' )); 请注意，此类仅允许您连接到IP端口组合。 如果给定的URI无效，不包含有效的IP地址和端口或包含任何其他方案，则它将以InvalidArgumentException拒绝: 如果给定的URI似乎有效，但是连接失败（例如，远程主机拒绝连接等），它将以RuntimeException拒绝。 如果要连接到主机名-端口组合，请参见以下章节。 高级用法:TcpConnector内部为每个流资源分配一个空的context资源。 如果目标URI包含一个hostname查询参数，则它的值将用于设置TLS对等名称。 SecureConnector和DnsConnector会使用它来验证对端名称，如果您想要自定义TLS对端名称，也可以使用它。 HappyEyeBallsConnector HappyEyeBallsConnector类实现了ConnectorInterface， 并允许您创建到任何主机名-端口组合的纯文本TCP/IP连接。 内部实现了happy eyeballs算法RFC6555 和RFC8305 来支持IPv6和IPv4主机名。 它通过装饰给定的TcpConnector实例来实现， 首先通过DNS(如果适用的话)查找给定的域名，然后建立到已解析的目标IP地址的底层TCP/IP连接。 设置你的DNS解析器和底层TCP连接器: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $dns = $dnsResolverFactory->createCached('8.8.8.8', $loop); $dnsConnector = new React\\Socket\\HappyEyeBallsConnector($loop, $tcpConnector, $dns); $dnsConnector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 参阅 示例. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示: $promise = $dnsConnector->connect('www.google.com:80'); $promise->cancel(); 对挂起的承诺调用cancel()将取消基础DNS查找和/或基础TCP/IP连接，并拒绝产生的承诺。 高级用法:HappyEyeBallsConnector内部依赖于一个Resolver(解析器)来查找给定主机名的IP地址。 然后，它将用这个IP的主机名替换目标URI中的主机名，并附加一个hostname查询参数，并将这个更新后的URI传递给底层连接器。 Happy Eye Balls算法描述为给定的主机名查找IPv6和IPv4地址，因此该连接器发送两个DNS查找A和AAAA记录。 然后，它使用所有IP地址(包括v6和v4)，并尝试以50ms的间隔连接到所有IP地址。在IPv6和IPv4地址之间切换。 当连接建立时，所有其他DNS查找和连接尝试都被取消。 DnsConnector DnsConnector类实现了ConnectorInterface，并允许您创建到任何主机名-端口组合的纯文本TCP/IP连接。 它通过装饰给定的TcpConnector实例来实现，首先通过DNS(如果适用的话)查找给定的域名，然后建立到已解析的目标IP地址的底层TCP/IP连接。 这样设置你的DNS解析器和底层TCP连接器: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $dns = $dnsResolverFactory->createCached('8.8.8.8', $loop); $dnsConnector = new React\\Socket\\DnsConnector($tcpConnector, $dns); $dnsConnector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 参阅 示例. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示: $promise = $dnsConnector->connect('www.google.com:80'); $promise->cancel(); 对挂起的承诺调用cancel()将取消基础DNS查找和/或基础TCP/IP连接，并拒绝产生的承诺。 高级用法:DnsConnector内部依赖于React\\Dns\\Resolver\\ResolverInterface来查找给定主机名的IP地址。 然后，它将用这个IP替换目标URI中的主机名，并附加一个hostname查询参数，并将这个更新后的URI传递给底层连接器。 因此，底层连接器负责创建到目标IP地址的连接，而此查询参数可用于检查原始主机名，并由TcpConnector用于设置TLS对等名称。 如果显式地给出了hostname，则不会修改此查询参数，如果您想要自定义TLS对等端名称会，这会很有用。 SecureConnector SecureConnector类实现了ConnectorInterface，并允许您创建到任何主机名-端口组合的安全TLS(以前称为SSL)连接。 通过装饰给定的DnsConnector实例来实现，首先创建一个明文TCP/IP连接，然后在此流上启用TLS加密。 $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop); $secureConnector->connect('www.google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"GET / HTTP/1.0\\r\\nHost: www.google.com\\r\\n\\r\\n\"); ... }); $loop->run(); 参阅 示例. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示: $promise = $secureConnector->connect('www.google.com:443'); $promise->cancel(); 对挂起的承诺调用cancel()将取消底层TCP/IP连接和/或SSL/TLS协商，并拒绝产生的承诺。 您可以选择传递额外的SSL context options 到构造函数，像这样: $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop, array( 'verify_peer' => false, 'verify_peer_name' => false )); 默认情况下，此连接器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本: $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop, array( 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT )); 高级用法:SecureConnector 内部依赖于在基础流资源上设置所需的context options。 因此，它应该与连接器堆栈中某处的TcpConnector一起使用，以便它可以为每个流资源分配一个空的context资源并验证对等名称 否则所有流资源都将使用单个共享的default context资源，可能会导致TLS对等名称不匹配错误或某些难以跟踪的竞争条件。 TimeoutConnector TimeoutConnector类实现了ConnectorInterface，并允许您将超时处理添加到现有的连接器实例中。 通过装饰给定的 ConnectorInterface实例并启动一个计时器来完成，如果时间太长，该计时器将自动拒绝并中止连接尝试。 $timeoutConnector = new React\\Socket\\TimeoutConnector($connector, 3.0, $loop); $timeoutConnector->connect('google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { // connection succeeded within 3.0 seconds }); 另请参阅 示例. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示: $promise = $timeoutConnector->connect('google.com:80'); $promise->cancel(); 对挂起的承诺调用cancel()将取消基础连接尝试，中止计时器并拒绝产生的承诺。 UnixConnector UnixConnector类实现了ConnectorInterface ，并允许你连接到Unix域套接字(UDS)路径，如下所示: $connector = new React\\Socket\\UnixConnector($loop); $connector->connect('/tmp/demo.sock')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"HELLO\\n\"); }); $loop->run(); 连接到Unix域套接字是一个原子操作，即它的承诺将立即兑现(履行或拒绝)。 因此，对产生的promise调用cancel()不起作用。 getRemoteAddress()方法将返回与connect()方法相同的目标Unix域套接字(UDS)路径， 前面加上unix://方案，例如unix:///tmp/demo.sock。 [getLocalAddress()]方法很可能返回一个null值，因为这个值不适用于这里的UDS连接。 FixedUriConnector FixedUriConnector类实现了ConnectorInterface， 并装饰现有的连接器，以始终使用固定的、预先配置的URI。 这对于不支持特定uri的用户很有用，比如当你想显式连接到Unix域套接字(UDS)路径，而不是连接到高级API假设的默认地址: $connector = new React\\Socket\\FixedUriConnector( 'unix:///var/run/docker.sock', new React\\Socket\\UnixConnector($loop) ); // destination will be ignored, actually connects to Unix domain socket $promise = $connector->connect('localhost:80'); 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/socket:^1.6 有关版本升级的详细信息，请参阅CHANGELOG 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过当前PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈建议对此项目使用PHP 7+，一是因为它的性能得到了很大的提高，二是因为旧版PHP版本需要采取以下几种解决方法。 安全TLS连接从PHP 5.6开始进行了一些重大升级，默认设置更加安全，而旧版本则需要显式设置上下文选项。 该库对这些上下文选项不承担任何责任，因此，由该库的使用者负责设置适当的上下文选项。 PHP PHP 这个项目也支持在HHVM上运行。 注意，HHVM stream_socket_enable_crypto()函数。 因此，尝试在受影响的版本上创建安全TLS连接将返回一个被拒绝的承诺。 我们的测试套件也涉及此问题，它将跳过受影响版本的相关测试。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit 该测试套件还包含许多依赖稳定internet连接的功能集成测试。 如果您不想运行这些，则可以像这样跳过它们: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"3.Protocol-Components/Dns.html":{"url":"3.Protocol-Components/Dns.html","title":"Dns","keywords":"","body":"Dns 用于ReactPHP 的异步DNS解析器。 DNS组件的重点是提供异步DNS解析。 但是，它实际上是用于处理DNS消息的工具包，可以轻松地用于创建DNS服务器。 目录 基本用法 Caching Custom cache adapter ResolverInterface resolve() resolveAll() 高级用法 UdpTransportExecutor TcpTransportExecutor SelectiveTransportExecutor HostsFileExecutor 安装 测试 License 参考文献 基本用法 最基本的用法是通过解析器工厂创建解析器。你只需要给它一个nameserver，然后你就可以开始解析了。 $loop = React\\EventLoop\\Factory::create(); $config = React\\Dns\\Config\\Config::loadSystemConfigBlocking(); $server = $config->nameservers ? reset($config->nameservers) : '8.8.8.8'; $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->create($server, $loop); $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); $loop->run(); 请参阅示例 Config类可用于加载系统默认配置。这是一个可以访问文件系统和块的操作。 理想情况下，这个方法应该在循环开始前只执行一次，而不是在循环运行时重复执行。 请注意，如果无法加载系统配置，则此类可能会返回一个empty配置。 因此，如果找不到默认nameserver，您可能希望像上面那样应用默认nameserver。 请注意，工厂在创建解析器实例时会从文件系统加载hosts文件一次。 理想情况下，这个方法应该在循环开始前只执行一次，而不是在循环运行时重复执行。 Caching 通过将解析程序配置为使用CachedExecutor来缓存结果: $loop = React\\EventLoop\\Factory::create(); $config = React\\Dns\\Config\\Config::loadSystemConfigBlocking(); $server = $config->nameservers ? reset($config->nameservers) : '8.8.8.8'; $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->createCached($server, $loop); $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); ... $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); $loop->run(); 如果第一个调用在第二个调用之前返回，则将仅执行一个查询。 第二个结果将从内存中的缓存中提供。 这对于需要多次查找相同主机名的长时间运行的脚本特别有用。 请参阅示例3. Custom cache adapter 默认情况下，上述操作将使用内存缓存。 你也可以指定一个自定义缓存实现CacheInterface来缓存: $cache = new React\\Cache\\ArrayCache(); $loop = React\\EventLoop\\Factory::create(); $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->createCached('8.8.8.8', $loop, $cache); 另请参阅wiki了解更多其他缓存实现 cache实现. ResolverInterface resolve() resolve(string $domain): PromiseInterface 方法可以用于将给定的$domain解析为单个IPv4地址(键入A查询)。 $resolver->resolve('reactphp.org')->then(function ($ip) { echo 'IP for reactphp.org is ' . $ip . PHP_EOL; }); 向DNS服务器发送给定$domain的DNS查询，成功后返回单个IP地址。 如果DNS服务器为该查询发送一个包含多个IP地址的DNS响应消息，它将从响应中随机选择一个IP地址。 如果你想要完整的IP地址列表或者想要发送不同类型的查询，你可使用resolveAll() 方法。 如果DNS服务器发送指示错误代码的DNS响应消息，则此方法将拒绝并返回RecordNotFoundException。 它的消息和代码可用于检查响应代码。 如果DNS通信失败，并且服务器没有以有效的响应消息进行响应，则该消息将以Exception拒绝。 可以通过取消其待处理的承诺来取消待处理的DNS查询，如下所示: $promise = $resolver->resolve('reactphp.org'); $promise->cancel(); resolveAll() resolveAll(string $host, int $type): PromiseInterface方法可用于解析给定$domain的所有记录值并查询$type。 $resolver->resolveAll('reactphp.org', Message::TYPE_A)->then(function ($ips) { echo 'IPv4 addresses for reactphp.org ' . implode(', ', $ips) . PHP_EOL; }); $resolver->resolveAll('reactphp.org', Message::TYPE_AAAA)->then(function ($ips) { echo 'IPv6 addresses for reactphp.org ' . implode(', ', $ips) . PHP_EOL; }); 这是此程序包中的主要方法之一。它会将给定$domain的DNS查询发送到您的DNS服务器， 并在成功后返回一个包含所有记录值的列表。 如果DNS服务器发送的DNS响应消息包含此查询的一个或多个记录，它将返回一个列表，其中包含响应中的所有记录值。 您可以使用Message :: TYPE_ *常量来控制将发送哪种查询类型。 请注意，此方法始终返回记录值列表，但是每种记录值类型取决于查询类型。 例如，它返回用于A型查询的IPv4地址，用于AAAA型查询的IPv6地址，用于NS型，CNAME和PTR型查询的主机名以及用于其他查询的结构化数据。 有关更多详细信息，请参见Record文档。 如果DNS服务器发送指示错误代码的DNS响应消息，则此方法将拒绝并返回RecordNotFoundException。它的消息和代码可用于检查响应代码。 如果DNS通信失败，并且服务器没有以有效的响应消息进行响应，则该消息将以Exception拒绝。 可以通过取消其待处理的承诺来取消待处理的DNS查询，如下所示: $promise = $resolver->resolveAll('reactphp.org', Message::TYPE_AAAA); $promise->cancel(); 高级用法 UdpTransportExecutor UdpTransportExecutor可用于通过UDP传输发送DNS查询。 这是发送一个DNS查询到您的DNS服务器的主类，由Resolver内部用于实际的消息传输。 对于更高级的用法，可以直接使用这个类。 下面的示例查找igor.io的IPv6地址。 $loop = Factory::create(); $executor = new UdpTransportExecutor('8.8.8.8:53', $loop); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); $loop->run(); 请参阅 示例4. 请注意，此执行器未实现超时机制，您可能希望与TimeoutExecutor结合使用，如下所示: $executor = new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ); 另请注意，此执行器使用不可靠的UDP传输，并且它不实现任何重试逻辑，因此您可能希望与RetryExecutor结合使用，如下所示: $executor = new RetryExecutor( new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ) ); 注意，这个执行器是完全异步的，因此允许并发执行任意数量的查询。 您应该限制应用程序中并发查询的数量，否则很可能会在解析器端面临速率限制和禁令。 对于许多常见的应用程序，当第一个查询仍然挂起时，你可能想要避免多次发送相同的查询， 所以你可能想要结合使用CoopExecutor: $executor = new CoopExecutor( new RetryExecutor( new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ) ) ); 此类仅出于组织原因而使用PHP的UDP套接字，并且没有利用 react/datagram 的优势，以避免两个包之间的循环依赖。 高级组件应该利用数据报组件，而不是从头重新实现这个套接字逻辑。 TcpTransportExecutor TcpTransportExecutor类可用于通过TCP / IP流传输发送DNS查询。 这是将DNS查询发送到DNS服务器的主要类之一。 对于更高级的用法，可以直接使用此类。 以下示例查询reactphp.org的IPv6地址。 $loop = Factory::create(); $executor = new TcpTransportExecutor('8.8.8.8:53', $loop); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); $loop->run(); 请参阅示例#92 请注意，此执行器未实现超时机制，您可能希望与TimeoutExecutor结合使用，如下所示: $executor = new TimeoutExecutor( new TcpTransportExecutor($nameserver, $loop), 3.0, $loop ); 与UdpTransportExecutor不同，该类使用可靠的TCP/IP传输，因此不必实现任何重试逻辑。 注意，这个执行器是完全异步的，因此允许并发执行查询。第一个查询将建立到DNS服务器的TCP/IP套接字连接，该连接将在短时间内保持打开状态。 其他查询将自动重用到DNS服务器的这个现有套接字连接，将在这个连接上管道多个请求，并将在短时间内保持空闲连接打开。 如果您只是偶尔发送查询，初始TCP/IP连接开销可能会导致轻微的延迟 - 当在现有连接上发送大量并发查询时， 它会变得越来越高效，并避免创建许多并发套接字(如基于udp的executor)。 您可能仍然希望限制应用程序中的(并发)查询数量，或者您可能面临解析器端的速率限制和禁令。 对于许多常见的应用程序，当第一个查询仍然挂起时，你可能想要避免多次发送相同的查询，所以你可能想要结合使用CoopExecutor: $executor = new CoopExecutor( new TimeoutExecutor( new TcpTransportExecutor($nameserver, $loop), 3.0, $loop ) ); 这个类使用PHP的TCP/IP套接字，并且没有利用 react/socket 的优势，以避免两个包之间的循环依赖。高级组件应该利用套接字组件，而不是从头重新实现这个套接字逻辑。 SelectiveTransportExecutor SelectiveTransportExecutor类可用于通过UDP或TCP/IP流传输发送DNS查询。 此类将自动选择正确的传输协议向DNS服务器发送DNS查询。它总是首先尝试通过更有效的UDP传输发送它。 如果此查询产生与大小相关的问题(截断消息)，则它将通过TCP/IP传输重试。 对于更高级的用法，可以直接使用此类。 以下示例查询reactphp.org的IPv6地址。 $executor = new SelectiveTransportExecutor($udpExecutor, $tcpExecutor); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); 注意，这个执行器仅实现为给定DNS查询选择正确传输的逻辑。 实现正确的传输逻辑、实现超时和任何重试逻辑都由给定的executor决定， 更多细节请参见 UdpTransportExecutor 和 TcpTransportExecutor 注意，这个执行器是完全异步的，因此允许并发执行任意数量的查询。 您应该限制应用程序中并发查询的数量，否则很可能会在解析器端面临速率限制和禁令。 对于许多常见的应用程序，当第一个查询仍然挂起时，你可能想要避免多次发送相同的查询， 所以你可能想要像这样结合使用CoopExecutor: $executor = new CoopExecutor( new SelectiveTransportExecutor( $datagramExecutor, $streamExecutor ) ); HostsFileExecutor 注意，上面的UdpTransportExecutor类总是执行一个实际的DNS查询。 如果你还想从你的hosts文件中获取条目，你可以使用以下代码: $hosts = \\React\\Dns\\Config\\HostsFile::loadFromPathBlocking(); $executor = new UdpTransportExecutor('8.8.8.8:53', $loop); $executor = new HostsFileExecutor($hosts, $executor); $executor->query( new Query('localhost', Message::TYPE_A, Message::CLASS_IN) ); 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/dns:^1.4 有关版本升级的详细信息，请参见CHANGELOG 。 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈推荐在这个项目中使用PHP 7+。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit 该测试套件还包含许多依赖稳定internet连接的功能集成测试。 如果您不想运行这些，则可以像这样跳过它们: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. 参考文献 RFC 1034 域名-概念和设施 RFC 1035 域名-实现和规范 "},"3.Protocol-Components/Http.html":{"url":"3.Protocol-Components/Http.html","title":"Http","keywords":"","body":"HTTP ReactPHP 的事件驱动的流HTTP客户端和服务器实现。 HTTP库是基于ReactPHP的Socket组件和 EventLoop 组件为HTTP客户端和服务器提供了可重用的实现。 它的客户端组件允许您并发发送任意数量的异步HTTP/HTTPS请求。 它的服务器组件允许您构建明文HTTP和安全HTTPS服务器，接受来自HTTP客户端(如web浏览器)的传入HTTP请求。 这个库提供了异步、流的方式，因此您可以在不阻塞的情况下处理多个并发HTTP请求。 目录 快速开始 客户端用法 Request methods Promises Cancellation Timeouts Authentication Redirects Blocking Concurrency Streaming response Streaming request HTTP proxy SOCKS proxy SSH proxy Unix domain sockets 服务端用法 Server listen() Server Request Request parameters Query parameters Request body Streaming incoming request Request method Cookie parameters Invalid request Server Response Deferred response Streaming outgoing response Response length Invalid response Default response headers Middleware Custom middleware Third-Party Middleware API Browser get() post() head() patch() put() delete() request() requestStreaming() withTimeout() withFollowRedirects() withRejectErrorResponse() withBase() withProtocolVersion() withResponseBuffer() React\\Http\\Message Response ServerRequest ResponseException React\\Http\\Middleware StreamingRequestMiddleware LimitConcurrentRequestsMiddleware RequestBodyBufferMiddleware RequestBodyParserMiddleware 安装 测试 License 快速开始 安装后，您可以使用以下代码访问HTTP网络服务器并发送一些简单的HTTP GET请求: $loop = React\\EventLoop\\Factory::create(); $client = new React\\Http\\Browser($loop); $client->get('http://www.google.com/')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders(), (string)$response->getBody()); }); $loop->run(); 这是一个HTTP服务器，它对每个请求均以 Hello World! 响应。 $loop = React\\EventLoop\\Factory::create(); $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); $socket = new React\\Socket\\Server(8080, $loop); $server->listen($socket); $loop->run(); 参阅示例. 客户端用法 Request methods 最重要的是，该项目提供了一个Browser对象，它提供了几个类似HTTP协议方法的方法: $browser->get($url, array $headers = array()); $browser->head($url, array $headers = array()); $browser->post($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->delete($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->put($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->patch($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); 每个方法都需要一个$url和一些可选参数来发送HTTP请求。 每个方法名称都匹配相应的HTTP请求方法，例如get()方法发送一个HTTP get请求。 您可以选择传递一个附加的 $headers 关联数组，该数组将与此HTTP请求一起发送。 此外，如果给出了传出请求主体且其大小已知且为非空，则每个方法将自动添加匹配的Content-Length请求标头。 对于空的请求正文，如果请求方法通常需要请求正文（仅适用于POST，PUT和PATCH HTTP请求方法）， 则仅包含Content-Length:0请求标头。 如果您使用的是streaming request body，默认使用Transfer-Encoding:chunked， 除非您明确传递匹配的Content-Length请求标头。 另请参阅streaming request。 默认情况下上述所有方法使用HTTP / 1.1协议版本发送请求。 如果要显式使用旧版HTTP / 1.0协议版本，则可以使用withProtocolVersion()方法。 如果要使用任何其他甚至自定义的HTTP请求方法，则可以使用request()方法。 以上每种方法都支持异步操作，并且使用PSR-7 ResponseInterface 实现或Exception拒绝。 有关更多详细信息，请参见以下有关Promises的章节。 Promises 发送请求是异步的(非阻塞的)，所以实际上可以并发发送多个请求。 Browser将用PSR-7 ResponseInterface 消息响应每个请求，但不能保证顺序。 发送请求使用Promises 的接口， 该接口可以轻松响应HTTP请求完成时（即成功完成或因错误而被拒绝）: $browser->get($url)->then( function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump('Response received', $response); }, function (Exception $error) { var_dump('There was an error', $error->getMessage()); } ); 如果您觉得这很奇怪，也可以使用更传统的 blocking API. 请记住，使用完整的响应消息来解决Promise意味着整个响应主体都必须保留在内存中。 这很容易上手，并且对于较小的响应（例如常见的HTML页面或RESTful或JSON API请求）相当有效。 您可能还需要研究 streaming API: 如果你正在处理大量的并发请求(100+)或 如果你想在数据块发生时处理单个数据块(而不需要等待完整的响应体)或 如果你期望一个较大的响应体大小(例如下载二进制文件时，1 MiB或更多)或 如果您不确定响应正文的大小(在访问任意远程HTTP端点时，安全第一，而且响应正文的大小事先是未知的)。 Cancellation 返回的承诺以这样一种方式实现:当它仍然挂起时，它可以被取消。 取消挂起的承诺将以异常拒绝其值，并清除所有底层资源。 $promise = $browser->get($url); $loop->addTimer(2.0, function () use ($promise) { $promise->cancel(); }); Timeouts 该库使用非常有效的HTTP实现，因此大多数HTTP请求通常应在几毫秒内完成。 但是，当通过不可靠的网络(Internet)发送HTTP请求时，可能会发生许多错误，并且一段时间后可能导致请求失败。 这样，该库将PHP的default_socket_timeout设置（默认为60s）视为发送外发HTTP请求和等待成功响应的超时， 否则将取消待处理的请求并拒绝其值（带有Exception）。 请注意，此超时值包括创建基础传输连接，发送HTTP请求， 接收HTTP响应标头及其完整的响应主体以及任何最终的redirects 。 另请参阅下面的redirects ，以配置要遵循的重定向数（或完全禁用后续重定向）， 还可以在下面的streaming中，不考虑将较大的响应主体纳入此超时范围。 您可以使用withTimeout() method以秒为单位传递自定义超时值，如下所示: $browser = $browser->withTimeout(10.0); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // response received within 10 seconds maximum var_dump($response->getHeaders()); }); 同样，您可以使用boolfalse 不超时，也可以使用booltrue值来恢复默认处理。 有关更多详细信息，请参阅withTimeout() 如果您使用的是streaming response body ， 则接收响应主体流所花费的时间将不包含在超时中。 这使您可以长时间保持此传入流的打开状态，例如在下载非常大的流或通过长期连接流式传输数据时。 如果您使用的是streaming request body ， 则发送请求主体流所花费的时间将不包含在超时中。 这使您可以长时间保持此传出流的打开状态，例如在上传非常大的流时。 请注意，此超时处理适用于更高级别的HTTP层。 较低的层（例如套接字和DNS）也可以应用（不同的）超时值。 具体而言，基础套接字连接使用相同的default_socket_timeout设置来建立基础传输连接。 要控制此连接超时行为，您可以像这样注入自定义Connector: $browser = new React\\Http\\Browser( $loop, new React\\Socket\\Connector( $loop, array( 'timeout' => 5 ) ) ); Authentication 该库使用 Authorization: Basic … 请求标头 支持HTTP Basic Authentication 或允许您设置显式的Authorization请求标头。 默认情况下，该库不包含传出的Authorization请求标头。 如果服务器需要身份验证，则可能会返回401（未经授权）状态代码， 默认情况下该状态代码将拒绝请求（另请参阅下面的withRejectErrorResponse() method）。 为了传递身份验证详细信息，您可以简单地将用户名和密码作为请求URL的一部分传递，如下所示: $promise = $browser->get('https://user:pass@example.com/api'); 请注意，身份验证详细信息中的特殊字符必须进行编码，另请参阅 rawurlencode() 此示例将使用传出的Authorization: Basic …请求标头自动传递base64编码的身份验证详细信息。 如果您要与之通信的HTTP端点需要任何其他身份验证方案，则也可以显式传递此标头。 使用(RESTful)HTTP API使用OAuth访问令牌或JSON Web令牌(JWT) : $token = 'abc123'; $promise = $browser->get( 'https://example.com/api', array( 'Authorization' => 'Bearer ' . $token ) ); 在执行重定向时，默认情况下，Authorization请求头永远不会发送到任何远程主机。 当遵循Location响应头包含身份验证详细信息的重定向时，将为以下请求发送这些详细信息。 另请参阅下面的redirects Redirects 默认情况下，此库遵循任何重定向，并使用来自远程服务器的Location响应头遵守3xx（重定向）状态代码。 这个承诺将通过重定向链的最后一个响应来实现。 $browser->get($url, $headers)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // the final response will end up here var_dump($response->getHeaders()); }); 任何重定向的请求都将遵循原始请求的语义，并将包含与原始请求相同的请求头，但下面列出的请求头除外。 如果原始请求包含请求正文，则此请求正文永远不会传递给重定向的请求。 因此，每个重定向的请求都将删除所有Content-Length和Content-Type请求头。 如果原始请求使用带有Authorization请求标头的HTTP身份验证， 则仅当重定向URL使用同一主机时，此请求标头才作为重定向请求的一部分传递。 换句话说，由于可能的隐私/安全问题，Authorization请求标头将不会转发给其他外部主机。 当遵循重定向时，其中Location响应头包含身份验证详细信息时，将为后续请求发送这些详细信息。 您可以使用withFollowRedirects() 方法来控制要跟踪的最大重定向数， 或按原样返回任何重定向响应，并应用如下自定义重定向逻辑: $browser = $browser->withFollowRedirects(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any redirects will now end up here var_dump($response->getHeaders()); }); 有关详细信息，请参阅 withFollowRedirects() Blocking 如上所示，默认情况下，该库为您提供了功能强大的异步API。 但是，如果您想要将其集成到传统的阻塞环境中， 您应该考虑使用clue/reactphp-block 生成的阻塞代码可能如下所示: use Clue\\React\\Block; $loop = React\\EventLoop\\Factory::create(); $browser = new React\\Http\\Browser($loop); $promise = $browser->get('http://example.com/'); try { $response = Block\\await($promise, $loop); // response successfully received } catch (Exception $e) { // an error occured while performing the request } 同样，您也可以同时处理多个请求并等待Response对象数组: $promises = array( $browser->get('http://example.com/'), $browser->get('http://www.example.org/'), ); $responses = Block\\awaitAll($promises, $loop); 有关更多详细信息，请参阅 clue/reactphp-block 记住上面关于在内存中缓冲整个响应消息的注释。你可能还会看到以下章节中的streaming API Concurrency 如上所示，这个库为您提供了一个强大的异步API。能够一次发送大量请求是这个项目的核心特性之一。 例如，您可以轻松地同时并发发送100个SQL请求查询处理。 记住，能力越大，责任越大。发送过多的请求可能会占用你过多的资源， 或者如果远程端看到来自您这边的请求数量不合理，甚至可能会禁止您。 // 如果数组包含很多元素，请特别注意 foreach ($urls as $url) { $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); } 因此，通常建议将发送方的并发限制为合理的值。 通常使用一个很小的限制， 因为一次执行十多个事情可能很容易使接收端不堪重负。 您可以将clue/reactphp-mq 用作轻量级的内存队列， 以同时并行执行很多（但不是太多）的事情: // 将浏览器包装在一个队列对象中，该对象一次执行不超过10个操作 $q = new Clue\\React\\Mq\\Queue(10, null, function ($url) use ($browser) { return $browser->get($url); }); foreach ($urls as $url) { $q($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); } 超过并发性限制的其他请求将自动进入队列，直到其中一个挂起的请求完成。 这与现有的Promise-based API 很好地集成在一起。 有关更多详细信息，请参考clue/reactphp-mq 对于数以千计的未完成请求，此内存方法相当有效。 如果要处理很大的输入列表（请考虑CSV或NDJSON文件中的数百万行），则可能需要考虑使用流方法。 了解更多细节，请参阅clue/reactphp-flux Streaming response 以上所有示例均假设您要将整个响应主体存储在内存中。 这很容易上手，并且对于较小的响应也相当有效。 但是，在某些情况下，使用流方法通常是一个更好的方法，只需要占用一小块内存: 如果你正在处理大量的并发请求(100+)或 如果你想在数据块发生时处理单个数据块(而不需要等待完整的响应体)或 如果你期望一个较大的响应体大小(例如下载二进制文件时，1 MiB或更多)或 如果您不确定响应正文的大小(在访问任意远程HTTP端点时，安全第一，而且响应正文的大小事先是未知的)。 您可以使用requestStreaming() 方法发送任意HTTP请求并接收流式响应。 它使用相同的HTTP消息API，但不将响应主体缓存在内存中。 它仅在接收到数据时以小块形式处理响应主体， 并通过ReactPHP's Stream API 转发此数据。 这适用于（任意数量）任意大小的响应。 这意味着它使用一个正常的 PSR-7 ResponseInterface 进行解析， 可以像往常一样使用它来访问响应消息参数。 你可以像往常一样访问消息体，但是它现在也实现了 ReactPHP's ReadableStreamInterface 以及部分PSR-7 StreamInterface $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { $body = $response->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); $body->on('data', function ($chunk) { echo $chunk; }); $body->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage() . PHP_EOL; }); $body->on('close', function () { echo '[DONE]' . PHP_EOL; }); }); 另请参阅stream download benchmark example 和stream forwarding example 你可以在消息体上调用以下方法: $body->on($event, $callback); $body->eof(); $body->isReadable(); $body->pipe(React\\Stream\\WritableStreamInterface $dest, array $options = array()); $body->close(); $body->pause(); $body->resume(); 由于消息体处于流状态，调用以下方法没有多大意义: $body->__toString(); // '' $body->detach(); // throws BadMethodCallException $body->getSize(); // null $body->tell(); // throws BadMethodCallException $body->isSeekable(); // false $body->seek(); // throws BadMethodCallException $body->rewind(); // throws BadMethodCallException $body->isWritable(); // false $body->write(); // throws BadMethodCallException $body->read(); // throws BadMethodCallException $body->getContents(); // throws BadMethodCallException 请注意，使用流传输时，timeouts的应用方式略有不同。 在流传输模式下，超时值包括创建基础传输连接，发送HTTP请求， 接收HTTP响应标头以及任何可能的redirects 。 特别是，超时值不考虑接收（可能很大）的响应主体。 如果要将流响应集成到更高级别的API中，则使用由Stream对象解析的Promise对象通常很不方便。 考虑考虑也使用react/promise-stream 生成的流代码可能看起来像这样: use React\\Promise\\Stream; function download(Browser $browser, string $url): React\\Stream\\ReadableStreamInterface { return Stream\\unwrapReadable( $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { return $response->getBody(); }) ); } $stream = download($browser, $url); $stream->on('data', function ($data) { echo $data; }); 更多细节请参见requestStreaming() 方法。 Streaming request 除了流化响应体之外，您还可以流化请求体。 如果你想发送较大的POST请求(上传文件等)或同时处理许多传出的流，这将非常有用。 不需要将body作为字符串传递，你可以简单地将一个实现 ReactPHP's ReadableStreamInterface 的实例传递给request methods ，如下所示: $browser->post($url, array(), $stream)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { echo 'Successfully sent.'; }); 如果你正在使用一个流请求体(React\\Stream\\ReadableStreamInterface)， 它将默认使用Transfer-Encoding: chunked， 或者你必须显式地传入匹配的Content-Length请求头，如下所示: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->post($url, array('Content-Length' => '11'), $body); 如果流式处理请求主体发出error事件或显式关闭而未首先发出成功的end事件，则请求将自动关闭并被拒绝。 HTTP proxy 您还可以通过添加依赖项 clue/reactphp-http-proxy 来建立HTTP连接代理服务器外发连接。 HTTP连接代理服务器（通常也称为HTTPS代理或SSL代理）通常用于通过中介（proxy）对HTTPS流量进行隧道传输， 以隐藏源地址（匿名）或绕过地址阻塞（地理阻塞）。 虽然许多（公共）HTTP连接代理服务器通常仅将此限制为HTTPS端口443， 但从技术上讲，它可以用于隧道任何基于TCP/IP的协议，例如纯HTTP和TLS加密的HTTPS。 $proxy = new Clue\\React\\HttpProxy\\ProxyConnector( 'http://127.0.0.1:8080', new React\\Socket\\Connector($loop) ); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); 另请参阅HTTP连接代理示例 SOCKS proxy 您还可以通过添加依赖项 clue/reactphp-socks 来建立SOCKS代理服务器外发连接。 SOCKS代理协议家族（SOCKS5、SOCKS4和SOCKS4a）通常用于通过中介（proxy）对HTTP（S）流量进行隧道传输， 以隐藏源地址（匿名性）或绕过地址阻塞（地理阻塞）。 虽然许多（公共）SOCKS代理服务器通常仅将此限制为HTTP（S）端口80和443，但从技术上讲，它可以用于任何基于TCP/IP的协议隧道传输。 $proxy = new Clue\\React\\Socks\\Client( 'socks://127.0.0.1:1080', new React\\Socket\\Connector($loop) ); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); 另请参阅SOCKS连接代理示例. SSH proxy 通过添加依赖项clue/reactphp-ssh-proxy 建立通过SSH服务器外发连接。 Secure Shell (SSH) 是一种安全的网络协议，最常用来访问远程服务器上的登录Shell。 它的架构允许它在单个连接上使用多个安全通道。此外， 这还可以用于创建“SSH隧道”，该隧道通常用于通过中介(“代理”)对HTTP(S)流量进行隧道， 以隐藏源地址(匿名)或绕过地址阻塞(地理阻塞)。 这可以用于隧道任何基于TCP/ ip的协议(HTTP, SMTP, IMAP等)， 允许您访问本地服务，否则无法从外部访问(防火墙后的数据库)，因此也可以用于纯HTTP和tls加密的HTTPS。 $proxy = new Clue\\React\\SshProxy\\SshSocksConnector('me@localhost:22', $loop); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); 请参阅 SSH代理示例 Unix domain sockets 默认情况下，这个库分别支持http://和https://URL模式的明文TCP/IP传输和安全TLS连接。 当显式配置时，此库还支持Unix域套接字(UDS)。 为了使用UDS路径，您必须显式配置连接器以覆盖目标URL，这样请求URL中给出的主机名将不再用于建立连接: $connector = new React\\Socket\\FixedUriConnector( 'unix:///var/run/docker.sock', new React\\Socket\\UnixConnector($loop) ); $browser = new Browser($loop, $connector); $client->get('http://localhost/info')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders(), (string)$response->getBody()); }); 请参阅Unix域套接字(UDS)示例 服务端用法 Server React\\Http\\Server类负责处理传入的连接，然后处理每个传入的Http请求。 当接收到一个完整的HTTP请求时，它将调用给定的请求处理程序函数。 这个请求处理函数需要传递给构造函数，并将被相应的 request 对象调用， 并期望返回一个 response 对象: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); 每个传入的HTTP请求消息始终由 PSR-7ServerRequestInterface 表示， 有关详细信息，请参见下面的 request 章节。 每个传出的HTTP响应消息始终由 PSR-7 ResponseInterface 表示, 有关更多详细信息，请参见下面的 response 章节。 需要通过' listen() '方法将Server附加到 ' React\\Socket\\ServerInterface ' 的实例上开始监听任何传入的连接，这将在下一章中描述。 在最简单的形式中，你可以将它附加到 ' React\\Socket\\Server ' ， 以便启动一个明文HTTP服务器，如下所示: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('0.0.0.0:8080', $loop); $server->listen($socket); 更多细节请参阅' listen() '方法和 hello world server 示例 默认情况下，Server会在内存中缓冲并解析完整的传入HTTP请求。 当接收到完整的请求头和请求体时，它将调用给定的请求处理程序函数。 这意味着传递给请求处理函数的request对象将与PSR-7 (http-message)完全兼容。 这为80%的用例提供了正常的默认值，并且推荐使用这个库，除非您确定自己知道自己在做什么。 另一方面，将完整的HTTP请求缓冲到内存中，直到您的请求处理程序函数能够处理它们， 这意味着该类必须采用许多限制，以避免消耗过多的内存。为了获得更高级的配置， 使用php.ini 中的设置默认值。 这是一个PHP设置列表，这个类使用它们各自的默认值: memory_limit 128M post_max_size 8M // capped at 64K enable_post_data_reading 1 max_input_nesting_level 64 max_input_vars 1000 file_uploads 1 upload_max_filesize 2M max_file_uploads 20 特别是，post_max_size设置限制了单个HTTP请求在缓冲其请求体时允许消耗多少内存。 这需要加以限制，因为服务器可以并发处理大量请求，否则服务器可能会潜在地消耗大量内存。 为了在默认情况下支持更高的并发性，这个值被限制为64K。 如果你指定一个更高的值，默认情况下它只允许64K。 如果一个请求超过了这个限制，它的请求主体将被忽略，它将像一个没有请求主体的请求一样被处理。 有关覆盖此设置的显式配置，请参见下面的内容。 默认情况下，该类会尽量避免为缓冲多个并发的HTTP请求而消耗超过memory_limit的一半。 因此，使用上面的默认设置最大128M，它将尝试不超过64M来缓冲多个并发的HTTP请求。 因此，在上述默认设置下，它将把HTTP请求的并发性限制为1024。 必须为您的PHP ini设置分配合理的值。 通常建议不支持使用大型HTTP请求正文（例如，大文件上传）来缓冲传入的HTTP请求。 如果要增加此缓冲区的大小，则还必须增加总内存限制，以允许更多并发请求（设置memory_limit 512M或更多）或显式限制并发性。 为了覆盖上面的默认缓冲，你可以显式地配置Server。 你可以使用LimitConcurrentRequestsMiddleware 和RequestBodyBufferMiddleware(见下面)来显式地配置一次可以处理的请求的总数: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100个并发缓冲处理程序 new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 每请求2 MiB new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); 在这个例子中，我们允许一次最多处理100个并发请求，每个请求最多可以缓冲2M。 这意味着您可能必须为传入的请求体缓冲区保留最大的200M内存。 相应地，您需要调整memory_limit ini设置， 以允许这些缓冲区加上您实际的应用程序逻辑内存需求(考虑512M或更多)。 当内部没有给出StreamingRequestMiddleware 时， 此类会自动分配这些中间件处理程序。因此，可以使用此示例覆盖所有默认设置以实现自定义限制。 作为在内存中缓冲整个请求主体的一种替代方法，您还可以使用流传输方法，其中仅一小部分数据必须保留在内存中: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), $handler ); 在这个例子中，接收到HTTP请求头之后，接收到可能更大的HTTP请求体之前，将调用request handler函数。 这意味着传递给请求处理函数的request可能与PSR-7不完全兼容。 这是专门为帮助处理更高级的用例而设计的，在这些用例中，您希望完全控制使用传入的HTTP请求主体和并发设置。 有关更多详细信息，请参阅下面的流式传入请求 listen() 使用 listen(React\\Socket\\ServerInterface $socket): void 方法侦听给定Socket服务器实例上的HTTP请求。 给定的React\\Socket\\ServerInterface 负责发出基础的流连接。 需要将此HTTP服务器连接到该服务器，以便处理任何连接并将传入的流数据作为传入的HTTP请求消息进行处理。 您可以将其以最常见的形式附加到React\\Socket\\Server 以便启动纯文本HTTP服务器: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('0.0.0.0:8080', $loop); $server->listen($socket); 另请参阅hello world server示例 此示例将开始在所有接口（公开）上的备用HTTP端口8080上侦听HTTP请求。 作为替代方案，使用反向代理并让此HTTP服务器仅通过使用侦听地址127.0.0.1:8080来在localhost（环回）接口上侦听是常见做法。 这样，您可以将应用程序托管在默认的HTTP端口80上，并且仅将特定的请求路由到此HTTP服务器。 同样，通常建议使用反向代理设置来接受默认HTTPS端口443（TLS终止）上的安全HTTPS请求，并且仅将纯文本请求路由到此HTTP服务器。 另外，您也可以使用安全的TLS侦听地址将此HTTP服务器附加到React\\Socket\\Server 上， 从而对此HTTP服务器接受安全的HTTPS请求，证书文件和可选的passphrase，如下所示: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('tls://0.0.0.0:8443', $loop, array( 'local_cert' => __DIR__ . '/localhost.pem' )); $server->listen($socket); 另请参阅hello world HTTPS示例 Server Request 如上所示，Server 类负责处理传入的连接，然后处理每个传入的HTTP请求。 一旦请求被服务端接收，请求对象将被处理。 这个请求对象实现了 PSR-7 ServerRequestInterface ， 这反过来扩展了 PSR-7 RequestInterface ， 并将其传递给回调函数。 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = \"The method of the request is: \" . $request->getMethod(); $body .= \"The requested path is: \" . $request->getUri()->getPath(); return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); }); 有关请求对象的更多细节，请参阅 PSR-7 ' ServerRequestInterface ' 和PSR-7 ' RequestInterface ' 的文档。 Request parameters getServerParams(): mixed[]方法可以用于获取类似于$_SERVER变量的服务器端参数。 目前有以下参数: REMOTE_ADDR 请求发送者的IP地址 REMOTE_PORT 请求发送者的端口 SERVER_ADDR 服务器IP地址 SERVER_PORT 服务器的端口 REQUEST_TIME 当收到完整的请求头时的Unix时间戳(整数)，类似于time() REQUEST_TIME_FLOAT 当收到完整的请求头时的Unix时间戳， 类似于microtime(true) HTTPS 如果请求使用HTTPS，则设置为on，否则不会设置 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = \"Your IP is: \" . $request->getServerParams()['REMOTE_ADDR']; return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); }); 请参阅 whatsmyip server示例. 高级:注意，如果您正在侦听Unix域套接字(UDS)路径，则不会设置地址参数，因为该协议缺乏主机/端口的概念。 Query parameters getQueryParams(): array 方法可以用于获取$_GET变量的查询参数。 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $queryParams = $request->getQueryParams(); $body = 'The query parameter \"foo\" is not set. Click the following link '; $body .= 'to use query parameter in your request'; if (isset($queryParams['foo'])) { $body = 'The value of \"foo\" is: ' . htmlspecialchars($queryParams['foo']); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/html' ), $body ); }); 上面示例中的响应将返回一个带有链接的响应体。URL包含查询参数foo，值为bar。 使用 htmlentities ， 如本例中防止跨站点脚本(缩写为XSS) 请参阅 server query parameters示例. Request body 默认情况下，Server将在内存中缓冲并解析完整的请求体。这意味着给定的请求对象包括已解析的请求主体和上传的文件。 作为默认缓冲逻辑的替代，你也可以使用 StreamingRequestMiddleware 。 跳转到下一章，学习更多关于如何处理 流式传入请求。 如上所示，每个传入的HTTP请求总是由 PSR-7 ServerRequestInterface 表示。 这个接口提供了几个在处理传入请求体时很有用的方法，如下所示。 getParsedBody(): null|array|object 方法可以用来获取解析的请求体， 类似于PHP的$_POST变量. 如果不能解析请求体，这个方法可能返回一个(可能是嵌套的)包含所有体参数的数组结构，或者返回一个null值。 默认情况下，该方法只会返回使用 Content-Type: application/x-www-form-urlencoded或Content-Type: multipart/form-data 请求头(通常用于HTML表单提交数据的POST请求)的解析数据。 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $name = $request->getParsedBody()['name'] ?? 'anonymous'; return new React\\Http\\Message\\Response( 200, array(), \"Hello $name!\\n\" ); }); 更多细节请参阅 form upload示例 getBody(): StreamInterface 方法可以用来从请求体中获取原始数据，类似于 PHP's php://input stream. 该方法返回由 PSR-7 StreamInterface 表示的请求体的实例。 这是特别有用,当使用自定义请求主体,否则不会被解析在默认情况下, 比如一个JSON(Content-Type: application/json)或XML(Content-Type: application/xml) 请求主体(通常用于POST, PUT 或 PATCH请求基于JSON或RESTful/RESTish APIs)。 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $data = json_decode((string)$request->getBody()); $name = $data->name ?? 'anonymous'; return new React\\Http\\Message\\Response( 200, array('Content-Type' => 'application/json'), json_encode(['message' => \"Hello $name!\"]) ); }); 更多细节请参阅 JSON API 服务示例 getUploadedFiles(): array方法可以用于在这个请求中获取上传的文件，类似于 PHP的$_FILES变量 这个方法返回一个(可能是嵌套的)包含所有文件上传的数组结构，每个文件都由 PSR-7 UploadedFileInterface 表示。 这个数组只有在使用Content-Type: multipart/form-data请求头(通常用于HTML文件上传的POST请求)时才会被填充。 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $files = $request->getUploadedFiles(); $name = isset($files['avatar']) ? $files['avatar']->getClientFilename() : 'nothing'; return new React\\Http\\Message\\Response( 200, array(), \"Uploaded $name\\n\" ); }); 更多细节请参阅 form upload服务示例 getSize(): ?int方法可以用来获取请求体的大小，类似于PHP的$_SERVER['CONTENT_LENGTH']变量。 此方法返回以字节数衡量的请求体的完整大小，该大小由消息边界定义。 如果请求消息不包含请求正文(如简单的GET请求)，则该值可以为0。 这个方法操作缓冲的请求体，即请求体的大小总是已知的， 即使请求没有指定Content-Length请求头或当使用Transfer-Encoding: chunked HTTP/1.1请求。 注意:Server会自动处理带有附加的Expect: 100-continue请求头的请求。 当HTTP/1.1客户端想要发送更大的请求体时，他们可能只发送带有附加的Expect: 100-continue请求头的请求头， 并在发送实际的(更大的)消息体之前等待。在这种情况下，服务器将自动向客户端发送一个中间的HTTP/1.1 100 Continue响应。 这样可以确保您将收到请求正文，而不会出现预期的延迟。 Streaming incoming request 如果你使用高级的StreamingRequestMiddleware ，请求对象将在收到请求头后被处理。 这意味着这种情况的发生与接收(可能更大的)请求体无关(例如before)。 注意，这是被认为是高级使用的非标准行为。跳到上一章了解更多关于如何处理缓冲的 request body 虽然这在PHP生态系统中可能并不常见，但实际上这是一种非常强大的方法，它为您提供了一些其他方法无法实现的优势: 在接收到一个较大的请求体之前对请求进行响应，例如拒绝一个未经认证的请求或一个超过允许的消息长度的请求(文件上传)。 在请求正文的其余部分到达之前，或者发送者正在缓慢地流数据时，开始处理请求正文的部分。 处理一个大的请求体而不需要在内存中缓冲任何东西，例如接受一个巨大的文件上传或可能无限的请求体流。 getBody(): StreamInterface方法可以用于访问请求体流。 在流模式下，这个方法返回一个流实例，它实现了 PSR-7 StreamInterface 和ReactPHP ReadableStreamInterface 。 然而，大多数PSR-7 StreamInterface 方法都是在控制同步请求体的假设下设计的。 鉴于这并不适用于此服务器，以下 PSR-7 StreamInterface 方法不会被使用，也不应该被调用:tell(), eof(), seek(), rewind(), write() 和 read()。 如果这是一个问题，你的用例和/或你想访问上传的文件，它是强烈建议使用bufferedrequest body 或使用RequestBodyBufferMiddleware 代替。 ReactPHP ReadableStreamInterface 让你访问传入的请求体作为单独的块: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = $request->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); return new React\\Promise\\Promise(function ($resolve, $reject) use ($body) { $bytes = 0; $body->on('data', function ($data) use (&$bytes) { $bytes += strlen($data); }); $body->on('end', function () use ($resolve, &$bytes){ $resolve(new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Received $bytes bytes\\n\" )); }); // an error occures e.g. on invalid chunked encoded data or an unexpected 'end' event $body->on('error', function (\\Exception $exception) use ($resolve, &$bytes) { $resolve(new React\\Http\\Message\\Response( 400, array( 'Content-Type' => 'text/plain' ), \"Encountered error after $bytes bytes: {$exception->getMessage()}\\n\" )); }); }); } ); 上面的示例只是计算在请求体中接收到的字节数。这可以用作缓冲或处理请求主体的框架。 更多细节请参阅 streaming request服务示例 只要请求体流上有新数据可用，就会触发data事件。 服务器还会自动使用Transfer-Encoding: chunked处理任何传入请求的解码，并且只会将实际负载作为数据发出。 当请求体流成功终止时，将触发end事件，也就是说，它被读取到预期的结束。 如果请求流包含Transfer-Encoding: chunked的无效数据，或者在接收到完整的请求流之前连接关闭，则会触发error事件。 服务器将自动停止读取连接，并丢弃所有传入的数据，而不是关闭连接。 响应消息仍然可以发送(除非连接已经关闭)。 close事件将在error或end事件之后触发。 有关请求体流的更多细节，请参阅ReactPHP ReadableStreamInterface getSize(): ?int方法可以用来获取请求体的大小，类似于PHP的$_SERVER['CONTENT_LENGTH']变量。 此方法返回以字节数衡量的请求体的完整大小，该大小由消息边界定义。 如果请求消息不包含请求正文(如简单的GET请求)，则该值可以为0。 该方法操作流请求体，即当使用Transfer-Encoding: chunked HTTP/1.1请求时，请求体大小可能是未知的(null)。 $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $size = $request->getBody()->getSize(); if ($size === null) { $body = 'The request does not contain an explicit length.'; $body .= 'This example does not accept chunked transfer encoding.'; return new React\\Http\\Message\\Response( 411, array( 'Content-Type' => 'text/plain' ), $body ); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Request body size: \" . $size . \" bytes\\n\" ); } ); 注意: Server 会自动处理带有附加的Expect: 100-continue请求头的请求。 当HTTP/1.1客户端想要发送一个更大的请求体时，他们可能只发送带有附加的Expect: 100-continue请求头的请求头， 并在发送实际的(更大的)消息体之前等待。在这种情况下，服务器将自动向客户端发送一个中间的HTTP/1.1 100 Continue响应。 这样可以确保您将收到请求正文，而不会出现预期的延迟。 Request method 请注意，服务器支持any请求方法(包括自定义和非标准方法)， 以及HTTP规范中为每种方法定义的所有请求目标格式， 包括normalorigin-form请求以及absolute-form和authority-form的代理请求。 getUri(): UriInterface方法可以用来获得有效的请求URI，它提供了对各个URI组件的访问。 注意(取决于给定的request-target(请求目标))某些URI组件可能存在也可能不存在， 例如，getPath(): string方法将为asterisk-form或authority-form的请求返回一个空字符串。 getHost(): string方法将返回由有效请求URI确定的主机，如果HTTP/1.0客户端没有指定，则默认为本地套接字地址(即没有host报头)。 getScheme(): string方法将返回http或https，这取决于请求是否通过到目标主机的安全TLS连接进行。 仅当此URI方案非标准时，才会清理Host头标头值以匹配此主机组件和端口组件。 您可以使用getMethod(): string和getRequestTarget(): string来检查此请求是否被接受， 并且可能希望拒绝带有适当错误代码的其他请求，例如400（错误请求）或405（不允许使用方法）。 CONNECT方法在隧道设置(HTTPS代理)中是有用的，而不是大多数HTTP服务器想要关心的东西。 请注意，如果您想处理这个方法，客户端可能会发送一个不同于Host报头值的请求目标(比如删除默认端口)， 并且请求目标在转发时必须优先。 Cookie parameters getCookieParams(): string[] 方法可以用来获取当前请求发送的所有cookie。 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $key = 'react\\php'; if (isset($request->getCookieParams()[$key])) { $body = \"Your cookie value is: \" . $request->getCookieParams()[$key]; return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain', 'Set-Cookie' => urlencode($key) . '=' . urlencode('test;more') ), \"Your cookie has been set.\" ); }); 上面的例子将尝试在第一次访问时设置cookie，并尝试在所有后续尝试时打印cookie值。 请注意这个例子是如何使用urlencode()函数来编码非字母数字字符的。 内部解码cookie的名称和值时也使用这种编码(这与其他实现一致，比如PHP的cookie函数)。 更多细节请参阅 cookie server示例 Invalid request Server类同时支持HTTP/1.1和HTTP/1.0请求消息。如果客户端发送了一个无效的请求消息， 使用了一个无效的HTTP协议版本或发送了一个无效的Transfer-Encoding请求头值， 服务器将自动发送一个400(Bad Request)HTTP错误响应到客户端并关闭连接。 除此之外，它将发出一个error事件，可以用于日志记录: $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); 请注意，如果您没有从请求处理程序函数返回一个有效的响应对象，服务器也将发出一个error事件。 另请参阅invalid response Server Response 传递给Server构造函数的回调函数负责处理请求并返回响应，该响应将被传递给客户端。 这个函数必须要返回一个实例实现 PSR-7 ResponseInterface 对象或(ReactPHP承诺)(/1.Core-Components/Promise.md),解决了用 PSR-7 ResponseInterface 对象。 这个项目提供了一个Response class，它实现了 PSR-7 ResponseInterface 最简单的使用方式: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); 我们在整个项目示例中都使用这个Response class，但也可以随意使用 PSR-7 ResponseInterface 另请参阅 Response class Deferred response 上面的示例直接返回响应，因为它不需要处理时间。 使用数据库、文件系统或长时间计算(实际上每个操作都需要>=1ms)来创建响应，将降低服务器的速度。 为了防止这种情况发生，你应该使用ReactPHP Promise 。 这个例子展示了一个长期的运行的服务: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { return new Promise(function ($resolve, $reject) use ($loop) { $loop->addTimer(1.5, function() use ($resolve) { $response = new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello world\" ); $resolve($response); }); }); }); 上面的示例将在1.5秒后创建响应。 这个例子表明，如果您的响应需要时间来创建，那么您需要Promise。 当请求体结束时，ReactPHP Promise将在Response对象中解析。 如果客户端在承诺仍然挂起时关闭连接，承诺将自动被取消。 promise cancel处理程序可用于清除在这种情况下分配的任何挂起的资源(如果适用的话)。 如果一个承诺在客户端关闭后被解析，它将被忽略。 Streaming outgoing response 这个项目中的Response类支持为响应体添加一个实现 ReactPHP ReadableStreamInterface 的实例。 因此，您可以将数据流直接输入响应体。 请注意PSR-7 ResponseInterface 的其他实现可能只支持字符串。 $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { $stream = new ThroughStream(); $timer = $loop->addPeriodicTimer(0.5, function () use ($stream) { $stream->write(microtime(true) . PHP_EOL); }); $loop->addTimer(5, function() use ($loop, $timer, $stream) { $loop->cancelTimer($timer); $stream->end(); }); return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $stream ); }); 上面的示例将每0.5秒向客户端发送当前的Unix时间戳(以微秒为浮点数)，并在5秒后结束。 这只是一个您可以使用流的示例，您也可以通过小块发送大量数据，或将其用于需要计算的主体数据。 如果请求处理程序使用一个已经关闭的响应流进行解析，它将简单地发送一个空响应体。 如果客户端在流仍然打开的情况下关闭连接，则响应流将自动关闭。 如果在客户端关闭后使用流体解析Promise，则响应流将自动关闭。 close事件可以用来清理在这种情况下分配的任何挂起的资源(如果适用的话)。 请注意，如果你使用一个实现ReactPHP的 ' DuplexStreamInterface ' 的体流实例(例如上面例子中的ThroughStream)，必须特别小心。 在大多数情况下，这只会消耗流的可读端，并转发(发送)流发出的任何数据，从而完全忽略流的可写端。 然而，如果这是对CONNECT方法的101(交换协议)响应或2xx(成功)响应，它也将写入数据到流的可写端。 这可以通过拒绝所有使用CONNECT方法的请求(这是大多数正常源HTTP服务器可能会做的) 或确保只使用ReactPHP's ReadableStreamInterface 来避免。 101(交换协议)响应代码对于更高级的升级请求很有用，比如升级到WebSocket协议，或者实现超出HTTP规范和HTTP库范围的自定义协议逻辑。 如果你想处理Upgrade: WebSocket头文件，你可能需要考虑使用Ratchet 来代替。 如果你想处理一个自定义协议，你可能需要查看HTTP specs ， 也可以查看示例 #81和#82 了解更多细节。 特别是，101(交换协议)响应代码不能被使用，除非你发送一个Upgrade响应头值，这个值也出现在HTTP/1.1的Upgrade请求头值中。 在这种情况下，服务器会自动发送Connection: upgrade报头值，所以你不必这么做。 CONNECT方法在隧道设置(HTTPS代理)中是有用的，而不是大多数原始HTTP服务器想要关心的东西。 HTTP规范为这个方法定义了一个不透明的隧道模式，并且没有使用消息体。 出于一致性原因，该库在响应体中使用了DuplexStreamInterface，用于隧道化的应用程序数据。 这意味着对CONNECT请求的2xx(成功)响应实际上可以为隧道化的应用程序数据使用流响应体， 这样客户端通过连接发送的任何原始数据都将通过管道通过可写流进行消费。 请注意，虽然HTTP规范没有使用CONNECT请求的请求体，但可能仍然存在一个请求体。 正常的请求体处理在这里适用，只有在请求体被处理之后(在大多数情况下应该是空的)连接才会转向隧道模式。 更多细节请参阅HTTP CONNECT服务示例 Response length 如果知道响应正文的大小，则会自动添加一个Content-Length响应头。这是最常见的用例，例如当像这样使用string响应体时: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); 如果响应正文大小未知，则无法自动添加Content-Length响应标头。当使用没有显式Content Length响应头的 streaming -outgoing response 时，HTTP/1.1 响应消息将自动使用Transfer Encoding:chunked， 而旧版HTTP/1.0 响应消息将包含普通响应正文。 如果您知道流式处理响应主体的长度，则可能需要像下面这样显式指定它: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { $stream = new ThroughStream(); $loop->addTimer(2.0, function () use ($stream) { $stream->end(\"Hello World!\\n\"); }); return new React\\Http\\Message\\Response( 200, array( 'Content-Length' => '13', 'Content-Type' => 'text/plain', ), $stream ); }); 根据HTTP规范，对HEAD请求的任何响应以及任何带有1xx(信息)、 204(无内容)或304(未修改)状态码的响应都将不包含消息体。 这意味着你的回调不需要特别注意这个，任何响应体都会被忽略。 同样，对CONNECT请求的任何2xx(成功)响应，任何带有1xx(信息) 或204(无内容)状态码的响应将不包含Content- length或Transfer-Encoding头， 因为这些不适用于这些消息。 请注意，对HEAD请求的响应和带有304（未修改）状态码的任何响应可能包括这些头，即使消息不包含响应正文， 因为如果相同的请求使用（无条件的）GET，那么这些头将应用于消息。 Invalid response 如上所示，每个传出的HTTP响应始终由 PSR-7 ResponseInterface 表示。 如果您的请求处理函数返回无效值或引发未处理的 Exception 或 Throwable ，则服务器将自动向客户端发送500（内部服务器错误）HTTP错误响应。 最重要的是，它将发出一个error事件，可用于记录，如下所示: $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; if ($e->getPrevious() !== null) { echo 'Previous: ' . $e->getPrevious()->getMessage() . PHP_EOL; } }); 请注意，如果客户端发送的无效HTTP请求从未到达您的请求处理程序函数，服务器也将发出“error”事件。 有关详细信息，请参见invalid request 。 此外，streaming incoming request 主体还可以在请求主体上发出error 事件。 如果发生未处理的错误，服务器只会发送一个非常通用的500 (Interval Server Error) HTTP错误响应， 而不会向客户端发送任何其他详细信息。虽然我们知道这可能会使初始调试更加困难， 但这也意味着服务器在默认情况下不会向外部泄漏任何应用程序细节或堆栈跟踪信息。 通常建议在请求处理函数中捕获任何Exception或Throwable，或者使用middleware 中创建自己的HTTP响应信息来避免这种通用错误处理。 Default response headers 当请求处理程序函数返回响应时，响应将由Server处理，然后发送回客户端。 Server: ReactPHP/1 响应头将被自动添加。 您可以像这样添加自定义的Server响应标头: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Server' => 'PHP/3' ) ); }); 如果您根本不想发送此Sever响应标头（例如，当您不想公开底层服务器软件时），则可以使用如下所示的空字符串值: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Server' => '' ) ); }); 如果未指定日期和时间，则会自动添加一个Date响应标题和当前系统日期和时间。 您也可以添加自定义的Date响应标头，如下所示: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Date' => gmdate('D, d M Y H:i:s \\G\\M\\T') ) ); }); 如果您不想发送此Date响应标头（例如，当您没有适当的时钟依赖时）， 则可以使用如下所示的空字符串值: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Date' => '' ) ); }); Server类会自动添加请求的协议版本，所以你不必自己添加。 例如，如果客户端使用HTTP/1.1协议版本发送请求，无论请求处理程序函数返回的是什么版本， 响应消息也将使用相同的协议版本， 注意，目前不支持持久连接(Connection: keep-alive)。 因此不管您设置的是什么头值，HTTP/1.1响应消息将自动包含Connection: close头。 Middleware 如上所示，Server接受一个请求处理程序参数， 该参数负责处理传入的HTTP请求，然后创建并返回传出的HTTP响应。 许多常见的用例都涉及到在将传入的HTTP请求传递给最终的业务逻辑请求处理程序之前对其进行验证、处理和操作。 因此，该项目支持中间件请求处理程序的概念。 Custom middleware 中间件请求处理程序应该遵循以下规则: 它是一个有效的callable。 接受一个实现 PSR-7 ServerRequestInterface 的实例作为第一个参数和一个可选的callable作为第二个参数。 它返回以下任意一个: 一个实例实现Promise\\resolve() 直接消费。 任何可以被Promise\\resolve() 消费的承诺， 解析为PSR-7 ResponseInterface 延迟消费。 它可能会抛出一个Exception(或者返回一个被拒绝的promise)来表示一个错误条件并中止。 它调用$next($request)继续处理下一个中间件请求处理程序，或显式返回而不调用$next中止。 $next请求处理程序(递归地)调用链上的下一个请求处理程序，并返回(或抛出)如上所示。 在调用$next($request)来更改下一个中间件操作的传入请求之前，可以修改$request。 $next返回值可能被用来修改输出响应。 如果你想实现自定义retry逻辑等，$next请求处理程序可能会被多次调用。 注意，这个非常简单的定义允许您使用匿名函数或使用魔术类__invoke()的任何类。 这使您可以轻松动态地创建自定义的中间件请求处理程序，或使用基于类的方法轻松使用现有的中间件实现。 尽管此项目确实提供了使用中间件实现的方法，但它的目标并不是定义中间件实现应该是什么样子。 我们意识到存在一个生动的中间件实现生态系统，并且正在努力通过 PSR-15 (HTTP Server Request Handlers) 标准化它们之间的接口并支持它。 因此，这个项目只捆绑了一些中间件实现，这些实现是匹配PHP的请求行为所必需的（见下文）， 并积极鼓励Third-Party Middleware 实现。 为了使用中间件请求处理程序，只需将上面定义的所有可调用对象的数组传递给Server 。 下面的示例添加了一个中间件请求处理程序，它将当前时间作为头添加到请求中（request time）， 并添加了一个最终的请求处理程序，它总是返回一个不带正文的200代码: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $request = $request->withHeader('Request-Time', time()); return $next($request); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response(200); } ); 请注意，中间件请求处理程序和最终请求处理程序有一个非常简单(且类似)的接口。 唯一的区别是最终的请求处理程序没有接收到$next处理程序。 同样，您可以使用$next中间件请求处理程序函数的结果来修改传出响应。 请注意，根据上面的文档，$next中间件请求处理程序可以直接返回 PSR-7 ResponseInterface 或者返回一个包装在延迟解决承诺中的。 为了简化这两个路径的处理，你可以简单地把它包装在Promise\\resolve() 调用中，像这样: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $promise = React\\Promise\\resolve($next($request)); return $promise->then(function (ResponseInterface $response) { return $response->withHeader('Content-Type', 'text/html'); }); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response(200); } ); 请注意，$next中间件请求处理程序也可能抛出一个Exception(或返回一个被拒绝的承诺)，如上所示。 前面的例子没有捕获任何异常，因此会向Server发出一个错误条件信号。 另外，你也可以捕获任何Exception来实现自定义错误处理逻辑(或日志记录等)，方法是将其包装在 Promise中，如下所示: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $promise = new React\\Promise\\Promise(function ($resolve) use ($next, $request) { $resolve($next($request)); }); return $promise->then(null, function (Exception $e) { return new React\\Http\\Message\\Response( 500, array(), 'Internal error: ' . $e->getMessage() ); }); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { if (mt_rand(0, 1) === 1) { throw new RuntimeException('Database error'); } return new React\\Http\\Message\\Response(200); } ); Third-Party Middleware 尽管此项目确实提供了使用中间件实现的方法，但它的目标并不是定义中间件实现应该是什么样子。 我们意识到存在一个生动的中间件实现生态系统，并且正在努力通过 PSR-15 (HTTP Server Request Handlers) 标准化它们之间的接口并支持它。 因此，这个项目只捆绑了一些中间件实现，这些实现是匹配PHP的请求行为所必需的（见下文）， 并积极鼓励Third-Party Middleware 实现。 虽然我们希望在react/http中直接支持PSR-15，但我们知道这个接口并不是专门针对async api的， 因此也没有利用deferred responses 的承诺。要点在于，当PSR-15强制使用 PSR-7 ResponseInterface 返回值时，我们也接受PromiseInterface。因此，我们建议使用外部 PSR-15 middleware adapter ， 它使用这些返回值的fly monkey补丁，这使得在这个包中使用大多数PSR-15中间件成为可能，而不需要任何更改。 除此之外，您还可以使用上面的middleware definition 来创建定制的中间件。第三方中间件的非详尽列表可以在 middleware wiki 中找到。如果你创建了一个自定义中间件，请确保让所有人都知道并将其添加到这个列表中。 API Browser React\\Http\\Browser 负责发送Http请求到您的Http服务器，并保持跟踪等待返回的Http响应。 它还将所有内容注册到主EventLoop $loop = React\\EventLoop\\Factory::create(); $browser = new React\\Http\\Browser($loop); 如果您需要自定义连接器设置(DNS解析、TLS参数、超时、代理服务器等)，您可以显式地传递 ConnectorInterface 的自定义实例: $connector = new React\\Socket\\Connector($loop, array( 'dns' => '127.0.0.1', 'tcp' => array( 'bindto' => '192.168.10.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ) )); $browser = new React\\Http\\Browser($loop, $connector); 请注意，browser类是final类，不应该被继承，它很可能在将来的版本中被标记为final。 get() get(string $url, array $headers = array()): PromiseInterface方法可用于发送HTTP GET请求 $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); 请参阅 GET request client示例. post() post(string $url, array $headers = array(), string|ReadableStreamInterface $contents = ''): PromiseInterface 方法可用于发送HTTP POST请求 $browser->post( $url, [ 'Content-Type' => 'application/json' ], json_encode($data) )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump(json_decode((string)$response->getBody())); }); 请参阅 POST JSON client示例. 这种方法也常用来提交HTML表单数据: $data = [ 'user' => 'Alice', 'password' => 'secret' ]; $browser->post( $url, [ 'Content-Type' => 'application/x-www-form-urlencoded' ], http_build_query($data) ); 如果发出的请求主体是一个string，该方法将自动添加一个匹配的Content-Length请求头。 如果你正在使用一个流请求体(ReadableStreamInterface)，它将默认使用Transfer-Encoding: chunked， 或者你必须显式地传递一个匹配的Content-Length请求头，如下所示: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->post($url, array('Content-Length' => '11'), $body); head() head(string $url, array $headers = array()): PromiseInterface 方法可用于发送HTTP HEAD请求 $browser->head($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); patch() patch(string $url, array $headers = array(), string|ReadableStreamInterface $contents = ''): PromiseInterface 方法可用于发送HTTP PATCH请求 $browser->patch( $url, [ 'Content-Type' => 'application/json' ], json_encode($data) )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump(json_decode((string)$response->getBody())); }); 如果发出的请求主体是一个string，该方法将自动添加一个匹配的Content-Length请求头。 如果你正在使用一个流请求体(ReadableStreamInterface)，它将默认使用Transfer-Encoding: chunked， 或者你必须显式地传递一个匹配的Content-Length请求头，如下所示: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->patch($url, array('Content-Length' => '11'), $body); put() put(string $url, array $headers = array()): PromiseInterface 方法可用于发送HTTP PUT请求 $browser->put( $url, [ 'Content-Type' => 'text/xml' ], $xml->asXML() )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); 请参阅PUT XML client示例. 如果发出的请求主体是一个string，该方法将自动添加一个匹配的Content-Length请求头。 如果你正在使用一个流请求体(ReadableStreamInterface)，它将默认使用Transfer-Encoding: chunked， 或者你必须显式地传递一个匹配的Content-Length请求头，如下所示: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->put($url, array('Content-Length' => '11'), $body); delete() delete(string $url, array $headers = array()): PromiseInterface 方法可用于发送HTTP DELETE请求 $browser->delete($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); request() request(string $method, string $url, array $headers = array(), string|ReadableStreamInterface $body = ''): PromiseInterface 方法发送一个任意的HTTP请求。 发送HTTP请求的首选方法是使用上面的request methods ， 例如get()方法发送HTTP GET请求。 另外，如果你想使用一个自定义的HTTP请求方法，你可以使用这个方法: $browser->request('OPTIONS', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); 如果请求正文的大小已知且非空，此方法将自动添加一个匹配的Content-Length请求头。 对于一个空的请求正文，如果请求方法通常需要一个请求正文(仅适用于POST， PUT和PATCH)， 则如果将只包含一个Content-Length: 0的请求头。 如果你正在使用一个流请求体(ReadableStreamInterface)， 它将默认使用Transfer-Encoding: chunked， 或者你必须显式地传递一个匹配的Content-Length请求头， 如下所示: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->request('POST', $url, array('Content-Length' => '11'), $body); requestStreaming() requestStreaming(string $method, string $url, array $headers = array(), string|ReadableStreamInterface $body = ''): PromiseInterface 方法可以用来发送任意的HTTP请求和接收流响应，而不需要缓冲响应体。 发送HTTP请求的首选方法是使用上述request methods ， 例如get()方法发送HTTPGET请求。 默认情况下，这些方法中的每一个都会在内存中缓冲整个响应主体。 这很容易上手，并且对于较小的响应也相当有效。 在某些情况下，最好使用流传输方法，其中只需要在内存中保留一小块。 您可以使用此方法发送任意HTTP请求并接收流式响应。 它使用相同的HTTP消息API，但不将响应主体缓存在内存中。 它仅在接收到数据时以小块形式处理响应主体，并通过 ReactPHP的Stream API 转发此数据。这适用于（任意数量）任意大小的响应。 $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { $body = $response->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); $body->on('data', function ($chunk) { echo $chunk; }); $body->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage() . PHP_EOL; }); $body->on('close', function () { echo '[DONE]' . PHP_EOL; }); }); 另请参见ReactPHP's ReadableStreamInterface 和streaming response ，以获取更多详细信息，示例和可能的用例。 如果传出请求主体的大小已知且非空，则此方法将自动添加匹配的Content-Length请求标头。 对于空的请求主体，如果请求方法通常需要一个请求主体（仅适用于POST, PUT 和 PATCH）， 则仅包含Content-Length: 0请求标头。 如果您使用的是流式请求主体（ReadableStreamInterface）， 则默认使用Transfer-Encoding: chunked， 否则您必须显式地传递匹配的Content-Length请求标头，如下所示: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->requestStreaming('POST', $url, array('Content-Length' => '11'), $body); withTimeout() withTimeout(bool|number $timeout): Browser方法可用于更改等待挂起请求的最大超时。 您可以传入秒数作为新的超时值: $browser = $browser->withTimeout(10.0); 您可以传入布尔值false来禁用任何超时。 在这种情况下，请求可以永远保持待处理状态: $browser = $browser->withTimeout(false); 您可以传入布尔值true来重新启用默认超时处理。 这将遵守PHP的default_socket_timeout设置（默认为60s）: $browser = $browser->withTimeout(true); 另请参阅 timeouts 了解有关超时处理的更多详细信息。 请注意，Browser是一个不可变的对象， 即此方法实际上返回一个 新的 Browser 实例，并应用了给定的超时值。 withFollowRedirects() withFollowRedirects(bool|int $followRedirects): Browser 方法可用于更改遵循HTTP重定向。 您可以传入重定向的最大数量来追踪: $browser = $browser->withFollowRedirects(5); 当重定向次数超过时，请求将自动被拒绝。你可以传入一个0来拒绝任何遇到的重定向请求: $browser = $browser->withFollowRedirects(0); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // only non-redirected responses will now end up here var_dump($response->getHeaders()); }); 您可以传入布尔值false来禁用任何重定向。在这种情况下， 请求将使用重定向响应进行解析，而不是遵循Location响应头: $browser = $browser->withFollowRedirects(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any redirects will now end up here var_dump($response->getHeaderLine('Location')); }); 您可以传入布尔值true来重新启用默认重定向处理。 默认情况下，最多遵循10个重定向: $browser = $browser->withFollowRedirects(true); 另请参阅redirects ，以获取有关重定向处理的更多详细信息。 请注意，Browser是一个不可变的对象， 即该方法实际上返回一个新的 Browser实例，并应用了给定的重定向设置。 withRejectErrorResponse() withRejectErrorResponse(bool $obeySuccessCode): Browser方法可用于更改是否拒绝不成功的HTTP响应状态代码（4xx和5xx）。 您可以传入布尔值false以禁用拒绝使用4xx或5xx响应状态代码的传入响应。在这种情况下，请求将通过指示错误条件的响应消息进行解析: $browser = $browser->withRejectErrorResponse(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any HTTP response will now end up here var_dump($response->getStatusCode(), $response->getReasonPhrase()); }); 您可以传入布尔值true来重新启用默认状态代码处理。 默认情况下，使用ResponseException 拒绝4xx或5xx范围内的任何响应状态代码: $browser = $browser->withRejectErrorResponse(true); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any successful HTTP response will now end up here var_dump($response->getStatusCode(), $response->getReasonPhrase()); }, function (Exception $e) { if ($e instanceof React\\Http\\Message\\ResponseException) { // any HTTP response error message will now end up here $response = $e->getResponse(); var_dump($response->getStatusCode(), $response->getReasonPhrase()); } else { var_dump($e->getMessage()); } }); 请注意，Browser是一个不可变的对象， 即该方法实际上返回一个新的 Browser实例，并应用了给定的设置。 withBase() withBase(string|null $baseUrl): Browser 方法可用于更改解析相对URL的基本URL。 如果您配置了一个基本URL，那么对相对URL的任何请求都将首先通过相对于给定的绝对基本URL解析这个请求来处理。 这支持解析相对路径引用（如../等）。 这对于所有端点（URL）都位于公共基URL下的（RESTful）API调用特别有用。 $browser = $browser->withBase('http://api.example.com/v3/'); // will request http://api.example.com/v3/users $browser->get('users')->then(…); 您可以传入null基础URL以返回不使用基础URL的新实例: $browser = $browser->withBase(null); 因此，任何使用相对URL的请求都无法完成，并且在不发送请求的情况下将被拒绝。 如果给定的$baseUrl参数不是一个有效的URL，这个方法将抛出一个InvalidArgumentException。 注意，Browser是一个不可变对象，也就是说， withBase()方法实际上会返回一个新的 Browser实例，其中应用了给定的base URL。 withProtocolVersion() withProtocolVersion(string $protocolVersion): Browser 方法用来更改HTTP协议的版本，该版本将用于所有后续请求。 以上所有的 request methods 默认以HTTP/1.1的方式发送请求。 这是首选的HTTP协议版本，它还提供了与传统HTTP/1.0服务器的良好向后兼容性。 所以一般很少更改这个协议版本。 如果你想使用旧的HTTP/1.0协议版本，你可以使用这个方法: $browser = $browser->withProtocolVersion('1.0'); $browser->get($url)->then(…); 注意，Browser是一个不可变对象，也就是说， withBase()方法实际上会返回一个新的 Browser实例，其中应用了新协议版本。 withResponseBuffer() withResponseBuffer(int $maximumSize): Browser方法用来改变缓冲响应体的最大大小。 发送HTTP请求的首选方法是使用上述 request methods ， 例如 get() 方法发送HTTPGET请求。 默认情况下，这些方法中的每一个都会在内存中缓冲整个响应主体。 这很容易上手，并且对于较小的响应也相当有效。 默认情况下，响应主体缓冲区将限制为16 MiB。 如果响应正文超过此值，则该请求将被拒绝。 您可以传入最大字节数来缓冲: $browser = $browser->withResponseBuffer(1024 * 1024); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // response body will not exceed 1 MiB var_dump($response->getHeaders(), (string) $response->getBody()); }); 请注意，对于每个待处理的请求，响应主体缓冲区必须保留在内存中，直到其传输完成为止， 并且仅在满足待处理的请求之后才将其释放。 所以通常不建议增加此最大缓冲区大小以允许更大的响应主体。 相反，您可以使用requestStreaming() method 接收任意大小的响应而无需缓冲。 因此，此最大缓冲区大小设置对流响应没有影响。 注意，Browser是一个不可变对象，也就是说， withBase()方法实际上会返回一个新的 Browser实例，其中应用了给定的设置。 React\\Http\\Message Response React\\Http\\Message\\Response类可用于表示外发服务器响应消息。 $response = new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/html' ), \"Hello world!\\n\" ); 这个类实现了 PSR-7 ResponseInterface 这又扩展了 PSR-7 MessageInterface. 此实现构建在现有传入响应消息的基础上，并且只添加所需的流支持。这个基类被认为是将来可能改变的实现细节。 ServerRequest React\\Http\\Message\\ServerRequest类可以用来代表传入的服务器请求消息。 此类实现了 PSR-7 ServerRequestInterface 又扩展了 PSR-7 RequestInterface 继而扩展了 PSR-7 MessageInterface. 这主要用于内部表示每个传入的请求消息。 同样，您也可以在测试用例中使用这个类来测试您的web应用程序如何响应某些HTTP请求。 此实现建立在现有传出请求消息的顶部，并且仅添加必需的服务器方法。 该基类被认为是将来可能会更改的实现细节。 ResponseException React\\Http\\Message\\ResponseException是一个Exception子类， 如果远程服务器返回一个不成功的状态码(除了2xx或3xx)，它将被用来拒绝请求承诺。 你可以通过withRejectErrorResponse() method 来控制这个行为。 getCode(): int 方法可以用来返回HTTP响应状态码。 getResponse(): ResponseInterface方法可用于访问其底层的响应对象。 React\\Http\\Middleware StreamingRequestMiddleware React\\Http\\Middleware\\StreamingRequestMiddleware可以用来处理流请求体(没有缓冲)传入的请求。 这允许您处理任意大小的请求，而无需将请求体缓冲在内存中。 相反，它将把请求体表示为 ReadableStreamInterface ， 它会在接收到数据时发出数据块: $server = new React\\Http\\Server(array( new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = $request->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); return new React\\Promise\\Promise(function ($resolve) use ($body) { $bytes = 0; $body->on('data', function ($chunk) use (&$bytes) { $bytes += \\count($chunk); }); $body->on('close', function () use (&$bytes, $resolve) { $resolve(new React\\Http\\Message\\Response( 200, [], \"Received $bytes bytes\\n\" )); }); }); } )); 更多请参阅 streaming incoming request 另外，这个中间件可以结合使用LimitConcurrentRequestsMiddleware 和RequestBodyBufferMiddleware (见下文)来显式配置一次可以处理的请求总数: $server = new React\\Http\\Server(array( new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), //100个并发缓冲处理程序 new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 每请求 2 MiB new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler )); 这个类内部被用作标记，以不触发Server中的默认请求缓冲行为。它本身不实现任何逻辑。 LimitConcurrentRequestsMiddleware React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware可用于限制并发执行的处理程序的数量。 如果调用这个中间件，它将检查挂起处理程序的数量是否低于允许的限制，然后简单地调用下一个处理程序，它将返回下一个处理程序返回(或抛出)的任何内容。 如果挂起的处理程序的数量超过了允许的限制，请求将被排队（其流主体将被暂停），并且它将返回一个挂起的承诺。 一旦挂起的处理程序返回（或抛出），它将选择最早的请求并调用下一个处理程序（其流主体将被恢复）。 以下示例显示了如何使用此中间件来确保一次调用不超过10个处理程序: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(10), $handler ); 此中间件通常与RequestBodyBufferMiddleware （见下文）结合使用，限制一次可以缓冲的请求总数: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), //100个并发缓冲处理程序 new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 每请求 2 MiB new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); 更复杂的示例包括限制可以一次缓冲的请求总数，然后确保实际的请求处理程序仅处理一个请求，而没有任何并发处理: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), //100个并发缓冲处理程序 new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 每请求 2 MiB new React\\Http\\Middleware\\RequestBodyParserMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(1), // 仅执行1个处理程序（无并发） $handler ); RequestBodyBufferMiddleware React\\Http\\Middleware\\RequestBodyBufferMiddleware是一个内置的中间件，它可以用来在内存中缓冲整个传入的请求体。 如果请求处理程序需要完全的PSR-7兼容性，并且不需要默认的流请求体处理，则这很有用。 构造函数接受一个可选参数，即最大请求体大小。 如果未提供，它将使用PHP配置中的post_max_size(默认8 MiB)。 (注意，将使用匹配的SAPI的值，这在大多数情况下是CLI配置。) 任何请求主体超过此限制的传入请求都将被接受，但其请求主体将被丢弃(空请求主体)。 这样做是为了避免在内存中保留一个过大的传入请求(例如，考虑一个2GB的文件上传)。 这允许下一个中间件处理程序仍然处理这个请求，但它将看到一个空的请求体。 这类似于PHP的默认行为，即如果超过这个限制则不会解析正文。然而，与PHP的默认行为不同，原始请求体不能通过' PHP://input '获得。 RequestBodyBufferMiddleware将缓冲主体已知大小的请求(即指定了Content-Length头) 以及主体未知大小的请求(即Transfer-Encoding: chunked头)。 所有请求将被缓冲在内存中，直到到达请求主体末尾，然后使用完整的缓冲请求调用下一个中间件处理程序。 类似地，这将立即为具有空请求主体的请求（例如简单的GET请求）和已经缓冲的请求（例如由于其他中间件）调用下一个中间件处理程序。 请注意，给定的缓冲区大小限制将分别应用于每个请求。 这意味着，如果您允许2 MiB限制，然后接收1000个并发请求，则仅为这些缓冲区最多可以分配2000 MiB。 因此，强烈建议将其与LimitConcurrentRequestsMiddleware （请参阅上文）一起使用，以限制并发请求的总数。 Usage: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), //100个并发缓冲处理程序 new React\\Http\\Middleware\\RequestBodyBufferMiddleware(16 * 1024 * 1024), // 16 MiB function (Psr\\Http\\Message\\ServerRequestInterface $request) { // $request->getBody() 的请求体可用，无需流式传输 return new React\\Http\\Message\\Response(200); }, ); RequestBodyParserMiddleware React\\Http\\Middleware\\RequestBodyParserMiddleware 接受一个完全缓冲的请求体 (通常来自RequestBodyBufferMiddleware)， 并从传入的Http请求体解析表单值和上传文件。 这个中间件处理程序负责从使用Content-Type: application/x-www-form-urlencoded或 Content-Type: multipart/form-data的HTTP请求中应用值， 以类似PHP默认的超全局变量$_POST和$_FILES。 与其依赖这些超全局变量，你可以使用PSR-7定义的$request->getParsedBody()和$request->getUploadedFiles()方法。 相应地，每个文件上传将被表示为实现 PSR-7 UploadedFileInterface 的实例。 由于其阻塞性质，moveTo()方法不可用，而是抛出RuntimeException。 你可以使用$contents = (string)$file->getStream();来访问文件内容并将其持久化到您喜欢的数据存储中。 $handler = function (Psr\\Http\\Message\\ServerRequestInterface $request) { // 如果有的话，现在可以从 $request->getParsedBody() 中获得解析的表单字段 $body = $request->getParsedBody(); $name = isset($body['name']) ? $body['name'] : 'unnamed'; $files = $request->getUploadedFiles(); $avatar = isset($files['avatar']) ? $files['avatar'] : null; if ($avatar instanceof Psr\\Http\\Message\\UploadedFileInterface) { if ($avatar->getError() === UPLOAD_ERR_OK) { $uploaded = $avatar->getSize() . ' bytes'; } elseif ($avatar->getError() === UPLOAD_ERR_INI_SIZE) { $uploaded = 'file too large'; } else { $uploaded = 'with error'; } } else { $uploaded = 'nothing'; } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $name . ' uploaded ' . $uploaded ); }; $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), //100个并发缓冲处理程序 new React\\Http\\Middleware\\RequestBodyBufferMiddleware(16 * 1024 * 1024), // 16 MiB new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); 详情请参阅 form upload server示例 默认情况下，中间件遵循upload_max_filesize (默认2M) ini设置。 超过此限制的文件将被拒绝，错误为UPLOAD_ERR_INI_SIZE。 你可以通过显式地将最大文件大小(以字节为单位)作为第一个参数传递给构造函数来控制每个文件上传的最大文件大小，如下所示: new React\\Http\\Middleware\\RequestBodyParserMiddleware(8 * 1024 * 1024); // 每个请求文件8 MiB 默认情况下，这个中间件尊重file_uploads (默认的1)和 max_file_uploads (默认的20)ini设置。 这些设置可以控制是否有文件，以及在单个请求中可以上传多少文件。 如果在单个请求中上传更多文件，额外的文件将被忽略，getUploadedFiles()方法将返回一个截断的数组。 请注意，提交时保留为空的上载字段不计入此限制。 你可以通过像这样显式地将第二个参数传递给构造函数来控制每个请求上传文件的最大数量: new React\\Http\\Middleware\\RequestBodyParserMiddleware(10 * 1024, 100); //100个文件，每个10 KiB 请注意，此中间件处理程序仅解析请求主体中已缓冲的所有内容。 如上例所示，请求主体必须由先前的中间件处理程序缓冲。 该先前的中间件处理程序还负责拒绝超出允许的消息大小（例如大文件上传）的传入请求。 上面使用的RequestBodyBufferMiddleware 仅丢弃过多的请求主体，从而导致主体为空。 如果您使用此中间件而没有先进行缓冲，则它将尝试解析一个空的（流式）主体，因此可能会假定一个空的数据结构。 更多细节请参阅RequestBodyBufferMiddleware。 该中间件遵循PHP的MAX_FILE_SIZE隐藏字段。 超过此限制的文件将被拒绝，并显示UPLOAD_ERR_FORM_SIZE错误。 该中间件遵循max_input_vars （默认为1000）和 max_input_nesting_level （默认为64）ini设置。 请注意，此中间件会忽略enable_post_data_reading （默认为1）ini 设置， 因为在这里没有什么意义，只能由更高级别的实现来完成。 如果您想遵循这个设置，就必须检查它的值，并有效地避免完全使用这个中间件。 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/http:^1.2 有关版本升级的详细信息，请参见CHANGELOG 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈推荐在这个项目中使用PHP 7+。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit 该测试套件还包含许多依赖稳定internet连接的功能集成测试。 如果您不想运行这些，则可以像这样跳过它们: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"3.Protocol-Components/HttpClient.html":{"url":"3.Protocol-Components/HttpClient.html","title":"HttpClient","keywords":"","body":"弃用的通知 该软件包现已迁移到react/http ，并且仅出于BC原因而存在。 $ composer require react/http 如果您以前使用过此软件包，则升级可能需要一两分钟。 新的API已更新为使用Promises和PSR-7消息抽象。 这意味着它现在比以往更强大，更易于使用: // 旧版 $client = new React\\HttpClient\\Client($loop); $request = $client->request('GET', 'https://example.com/'); $request->on('response', function ($response) { $response->on('data', function ($chunk) { echo $chunk; }); }); $request->end(); // 新版 $browser = new React\\Http\\Browser($loop); $browser->get('https://example.com/')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { echo $response->getBody(); }); 参阅 react/http "},"4.Utility-Components/Cache.html":{"url":"4.Utility-Components/Cache.html","title":"Cache","keywords":"","body":"Cache ReactPHP 的基于Promise 的异步缓存接口。 缓存组件提供了一个基于Promise 的CacheInterface 和其在内存中的ArrayCache 实现。 这允许使用者在界面上键入提示，并允许第三方提供替代的实现。 该项目的主要灵感来自PSR-16:缓存库的通用接口 ， 但使用更适合异步、非阻塞应用程序的接口。 目录 用法 CacheInterface get() set() delete() getMultiple() setMultiple() deleteMultiple() clear() has() ArrayCache 常见用法 Fallback get Fallback-get-and-set 安装 测试 License 用法 CacheInterface CacheInterface描述此组件的主接口。 允许使用者针对接口键入提示，并允许第三方提供替代实现。 get() get(string $key, mixed $default = null): PromiseInterface方法可以用来从缓存中获取值。 成功时，该方法将使用缓存的值进行解析;当找不到任何项目或发生错误时，该方法将返回$default值进行解析。 同样，过期的缓存项(一旦生命周期过期)被认为是缓存事项。 $cache ->get('foo') ->then('var_dump'); 本例获取键foo的值并将其传递给var_dump函数。您可以使用 promises 提供的任何组合。 set() set(string $key, mixed $value, ?float $ttl = null): PromiseInterface方法可以用来在缓存中存储一个值。 此方法将在成功时使用true解决问题，发生错误时使用false解决问题。如果缓存实现必须通过网络来存储它，则可能需要一段时间。 $ttl参数(可选)设置该缓存项的最大生命周期(以秒为单位)。如果忽略此参数(或null)，只要底层实现支持，该项将一直留在缓存中。 尝试访问过期的缓存项会导致缓存丢失，参阅'get()'。 $cache->set('foo', 'bar', 60); 这个例子最终将键foo的值设置为bar。如果它已经存在，它将被覆盖。 此接口不强制任何特定的TTL分辨率，因此如果您依赖毫秒或以下的非常高精度，则可能需要特别小心。 已知许多现有的缓存实现提供微秒或毫秒的精度，但通常不建议依赖这种高精度。 这个接口建议缓存实现应该使用单调的时间源(如果可用的话)。默认情况下，单调时间源只有在PHP 7.3才可用，因此缓存实现可能会退回到使用时钟时间。 虽然这不会影响许多常见的用例，但对于依赖于高时间精度的程序和依赖于不连续时间调整(时间跳跃)的系统来说，这是一个重要的区别。 这意味着，如果您存储一个TTL为30秒的缓存项，然后将系统时间向前调整20秒，该缓存项仍将在30秒内过期。 delete() delete(string $key): PromiseInterface方法可以用来从缓存中删除值。 成功时此方法将解析为true，当发生错误时将使用false解析。 当在缓存中没有找到用于$key的项时，它也解析为true。 如果缓存实现必须通过网络删除它，则可能需要一段时间。 $cache->delete('foo'); 这个例子最终从缓存中删除了键foo。与set()一样，这可能不会立即发生，并且返回Promise来保证删除项是否已经从缓存中移除。 getMultiple() getMultiple(string[] $keys, mixed $default = null): PromiseInterface方法可以通过它们唯一的键来检索多个缓存项。 此方法将在成功时使用缓存值数组进行解析，或在找不到项或发生错误时使用给定的$default值进行解析。 同样，过期的缓存项（一旦过了有效期）被视为缓存未命中。 $cache->getMultiple(array('name', 'age'))->then(function (array $values) { $name = $values['name'] ?? 'User'; $age = $values['age'] ?? 'n/a'; echo $name . ' is ' . $age . PHP_EOL; }); 此示例获取name和age键的缓存项，并打印一些示例输出。 您可以使用 promises 提供的任何组合。 setMultiple() 可以使用setMultiple(array $values, ?float $ttl = null): PromiseInterface方法在缓存中持久化一组键值对，其中ttl是可选的。 此方法将在成功时使用true进行解析，或在发生错误时使用false进行解析。如果缓存实现必须通过网络来存储它，则可能需要一段时间。 $ttl参数(可选)设置这些缓存项的最大生命周期(以秒为单位)。如果省略这个参数(或null)，只要底层实现支持，这些项就会一直留在缓存中。 尝试访问过期的缓存项会导致缓存丢失，请参阅getMultiple() $cache->setMultiple(array('foo' => 1, 'bar' => 2), 60); 本例最终将值列表设置为foo键为1值，bar键为2。如果某些键已经存在，它们将被重写。 deleteMultiple() deleteMultiple(string[] $keys): PromiseInterface 方法可以用于在一次操作中删除多个缓存项。 此方法将在成功时使用true进行解析，或在发生错误时使用false进行解析。 当在缓存中找不到$keys的项时，它也会解析为true。如果缓存实现必须通过网络删除它，则可能需要一段时间。 $cache->deleteMultiple(array('foo', 'bar, 'baz')); 本例最终从缓存中删除键foo, bar和baz。 与setMultiple()一样，这可能不会立即发生，并且会返回一个承诺，以保证该项是否已从缓存中删除。 clear() clear(): PromiseInterface方法可用于清除整个缓存。 此方法将在成功时使用true进行解析，或在发生错误时使用false进行解析。如果缓存实现必须通过网络删除它，则可能需要一段时间。 $cache->clear(); 这个例子最终会从缓存中删除所有的键。与deleteMultiple()一样，这可能不会立即发生，并且会返回一个承诺，以保证是否已从缓存中删除所有项。 has() has(string $key): PromiseInterface方法可用于确定缓存中是否存在项。 此方法将在成功时使用true进行解析，在找不到项或出现错误时使用false进行解析。 同样，过期的缓存项（一旦生命周期过期）被视为缓存未命中。 $cache ->has('foo') ->then('var_dump'); 下面的例子检查键foo的值是否设置在缓存中，并将结果传递给var_dump函数。您可以使用 promises 提供的任何组合。 注意:建议has()仅用于缓存预热类型的目的，而不要在get/set的实时应用程序操作中使用， 因为此方法受竞态条件的限制，在竞态条件下，has()将立即返回true， 然后另一个脚本可以将其删除，从而使应用程序的状态过期。 ArrayCache ArrayCache提供了 CacheInterface 在内存中的实现。 $cache = new ArrayCache(); $cache->set('foo', 'bar'); 它的构造函数接受一个?int $limit参数(可选)来限制在LRU缓存中存储的最大量。 如果您向该实例添加更多项，它将自动删除最近使用最少使用的项(LRU)。 例如，该代码片段将覆盖第一个值，并只存储最后两项: $cache = new ArrayCache(2); $cache->set('foo', '1'); $cache->set('bar', '2'); $cache->set('baz', '3'); 已知在使用PHP 7.3之前的任何版本时，此缓存实现都依赖于时钟时间来计划将来的缓存过期时间， 因为单调时间源仅在PHP 7.3起可用(hrtime())。 尽管这并不影响许多常见用例，但这对于依赖于高时间精度的程序或受不连续时间调整（时间跳跃）影响的系统而言，是一个重要的区别。 这意味着，如果在PHPset() 常见用法 Fallback get 缓存的一个常见用例是尝试获取缓存的值，如果没有找到，作为后备从原始数据源检索它。下面是一个例子: $cache ->get('foo') ->then(function ($result) { if ($result === null) { return getFooFromDb(); } return $result; }) ->then('var_dump'); 首先尝试检索foo的值。注册一个回调函数，当结果值为null时，它将调用getFooFromDb。 getFooFromDb是一个函数(可以是任何PHP可调用的)，如果键在缓存中不存在，它将被调用。 getFooFromDb可以通过从数据库(或任何其他数据源)返回实际值的承诺来处理丢失的键。 因此，该链将在两种情况下正确地返回提供值。 Fallback get and set 为了扩展 fallback get 示例, 通常需要在从数据源获取值之后在缓存上设置该值。 $cache ->get('foo') ->then(function ($result) { if ($result === null) { return $this->getAndCacheFooFromDb(); } return $result; }) ->then('var_dump'); public function getAndCacheFooFromDb() { return $this->db ->get('foo') ->then(array($this, 'cacheFooFromDb')); } public function cacheFooFromDb($foo) { $this->cache->set('foo', $foo); return $foo; } 通过使用串联操作，您可以轻松地有条件地缓存从数据库中获取的值。 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/cache:^1.1 有关版本升级的详细信息，请参见CHANGELOG 。 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈推荐在这个项目中使用PHP 7+。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/ChildProcess.html":{"url":"4.Utility-Components/ChildProcess.html","title":"ChildProcess","keywords":"","body":"Child Process Event-driven library for executing child processes with ReactPHP. This library integrates Program Execution with the EventLoop. Child processes launched may be signaled and will emit an exit event upon termination. Additionally, process I/O streams (i.e. STDIN, STDOUT, STDERR) are exposed as Streams. Table of contents Quickstart example Process Stream Properties Command Termination Custom pipes Sigchild Compatibility Windows Compatibility Install Tests License Quickstart example $loop = React\\EventLoop\\Factory::create(); $process = new React\\ChildProcess\\Process('echo foo'); $process->start($loop); $process->stdout->on('data', function ($chunk) { echo $chunk; }); $process->on('exit', function($exitCode, $termSignal) { echo 'Process exited with code ' . $exitCode . PHP_EOL; }); $loop->run(); See also the examples. Process Stream Properties Once a process is started, its I/O streams will be constructed as instances of React\\Stream\\ReadableStreamInterface and React\\Stream\\WritableStreamInterface. Before start() is called, these properties are not set. Once a process terminates, the streams will become closed but not unset. Following common Unix conventions, this library will start each child process with the three pipes matching the standard I/O streams as given below by default. You can use the named references for common use cases or access these as an array with all three pipes. $stdin or $pipes[0] is a WritableStreamInterface $stdout or $pipes[1] is a ReadableStreamInterface $stderr or $pipes[2] is a ReadableStreamInterface Note that this default configuration may be overridden by explicitly passing custom pipes, in which case they may not be set or be assigned different values. In particular, note that Windows support is limited in that it doesn't support non-blocking STDIO pipes. The $pipes array will always contain references to all pipes as configured and the standard I/O references will always be set to reference the pipes matching the above conventions. See custom pipes for more details. Because each of these implement the underlying ReadableStreamInterface or WritableStreamInterface, you can use any of their events and methods as usual: $process = new Process($command); $process->start($loop); $process->stdout->on('data', function ($chunk) { echo $chunk; }); $process->stdout->on('end', function () { echo 'ended'; }); $process->stdout->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage(); }); $process->stdout->on('close', function () { echo 'closed'; }); $process->stdin->write($data); $process->stdin->end($data = null); // … For more details, see the ReadableStreamInterface and WritableStreamInterface. Command The Process class allows you to pass any kind of command line string: $process = new Process('echo test'); $process->start($loop); The command line string usually consists of a whitespace-separated list with your main executable bin and any number of arguments. Special care should be taken to escape or quote any arguments, escpecially if you pass any user input along. Likewise, keep in mind that especially on Windows, it is rather common to have path names containing spaces and other special characters. If you want to run a binary like this, you will have to ensure this is quoted as a single argument using escapeshellarg() like this: $bin = 'C:\\\\Program files (x86)\\\\PHP\\\\php.exe'; $file = 'C:\\\\Users\\\\me\\\\Desktop\\\\Application\\\\main.php'; $process = new Process(escapeshellarg($bin) . ' ' . escapeshellarg($file)); $process->start($loop); By default, PHP will launch processes by wrapping the given command line string in a sh command on Unix, so that the first example will actually execute sh -c echo test under the hood on Unix. On Windows, it will not launch processes by wrapping them in a shell. This is a very useful feature because it does not only allow you to pass single commands, but actually allows you to pass any kind of shell command line and launch multiple sub-commands using command chains (with &&, ||, ; and others) and allows you to redirect STDIO streams (with 2>&1 and family). This can be used to pass complete command lines and receive the resulting STDIO streams from the wrapping shell command like this: $process = new Process('echo run && demo || echo failed'); $process->start($loop); Note that Windows support is limited in that it doesn't support STDIO streams at all and also that processes will not be run in a wrapping shell by default. If you want to run a shell built-in function such as echo hello or sleep 10, you may have to prefix your command line with an explicit shell like cmd /c echo hello. In other words, the underlying shell is responsible for managing this command line and launching the individual sub-commands and connecting their STDIO streams as appropriate. This implies that the Process class will only receive the resulting STDIO streams from the wrapping shell, which will thus contain the complete input/output with no way to discern the input/output of single sub-commands. If you want to discern the output of single sub-commands, you may want to implement some higher-level protocol logic, such as printing an explicit boundary between each sub-command like this: $process = new Process('cat first && echo --- && cat second'); $process->start($loop); As an alternative, considering launching one process at a time and listening on its exit event to conditionally start the next process in the chain. This will give you an opportunity to configure the subsequent process I/O streams: $first = new Process('cat first'); $first->start($loop); $first->on('exit', function () use ($loop) { $second = new Process('cat second'); $second->start($loop); }); Keep in mind that PHP uses the shell wrapper for ALL command lines on Unix. While this may seem reasonable for more complex command lines, this actually also applies to running the most simple single command: $process = new Process('yes'); $process->start($loop); This will actually spawn a command hierarchy similar to this on Unix: 5480 … \\_ php example.php 5481 … \\_ sh -c yes 5482 … \\_ yes This means that trying to get the underlying process PID or sending signals will actually target the wrapping shell, which may not be the desired result in many cases. If you do not want this wrapping shell process to show up, you can simply prepend the command string with exec on Unix platforms, which will cause the wrapping shell process to be replaced by our process: $process = new Process('exec yes'); $process->start($loop); This will show a resulting command hierarchy similar to this: 5480 … \\_ php example.php 5481 … \\_ yes This means that trying to get the underlying process PID and sending signals will now target the actual command as expected. Note that in this case, the command line will not be run in a wrapping shell. This implies that when using exec, there's no way to pass command lines such as those containing command chains or redirected STDIO streams. As a rule of thumb, most commands will likely run just fine with the wrapping shell. If you pass a complete command line (or are unsure), you SHOULD most likely keep the wrapping shell. If you're running on Unix and you want to pass an invidual command only, you MAY want to consider prepending the command string with exec to avoid the wrapping shell. Termination The exit event will be emitted whenever the process is no longer running. Event listeners will receive the exit code and termination signal as two arguments: $process = new Process('sleep 10'); $process->start($loop); $process->on('exit', function ($code, $term) { if ($term === null) { echo 'exit with code ' . $code . PHP_EOL; } else { echo 'terminated with signal ' . $term . PHP_EOL; } }); Note that $code is null if the process has terminated, but the exit code could not be determined (for example sigchild compatibility was disabled). Similarly, $term is null unless the process has terminated in response to an uncaught signal sent to it. This is not a limitation of this project, but actual how exit codes and signals are exposed on POSIX systems, for more details see also here. It's also worth noting that process termination depends on all file descriptors being closed beforehand. This means that all process pipes will emit a close event before the exit event and that no more data events will arrive after the exit event. Accordingly, if either of these pipes is in a paused state (pause() method or internally due to a pipe() call), this detection may not trigger. The terminate(?int $signal = null): bool method can be used to send the process a signal (SIGTERM by default). Depending on which signal you send to the process and whether it has a signal handler registered, this can be used to either merely signal a process or even forcefully terminate it. $process->terminate(SIGUSR1); Keep the above section in mind if you want to forcefully terminate a process. If your process spawn sub-processes or implicitly uses the wrapping shell mentioned above, its file descriptors may be inherited to child processes and terminating the main process may not necessarily terminate the whole process tree. It is highly suggested that you explicitly close() all process pipes accordingly when terminating a process: $process = new Process('sleep 10'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { foreach ($process->pipes as $pipe) { $pipe->close(); } $process->terminate(); }); For many simple programs these seamingly complicated steps can also be avoided by prefixing the command line with exec to avoid the wrapping shell and its inherited process pipes as mentioned above. $process = new Process('exec sleep 10'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { $process->terminate(); }); Many command line programs also wait for data on STDIN and terminate cleanly when this pipe is closed. For example, the following can be used to \"soft-close\" a cat process: $process = new Process('cat'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { $process->stdin->end(); }); While process pipes and termination may seem confusing to newcomers, the above properties actually allow some fine grained control over process termination, such as first trying a soft-close and then applying a force-close after a timeout. Custom pipes Following common Unix conventions, this library will start each child process with the three pipes matching the standard I/O streams by default. For more advanced use cases it may be useful to pass in custom pipes, such as explicitly passing additional file descriptors (FDs) or overriding default process pipes. Note that passing custom pipes is considered advanced usage and requires a more in-depth understanding of Unix file descriptors and how they are inherited to child processes and shared in multi-processing applications. If you do not want to use the default standard I/O pipes, you can explicitly pass an array containing the file descriptor specification to the constructor like this: $fds = array( // standard I/O pipes for stdin/stdout/stderr 0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'w'), // example FDs for files or open resources 4 => array('file', '/dev/null', 'r'), 6 => fopen('log.txt','a'), 8 => STDERR, // example FDs for sockets 10 => fsockopen('localhost', 8080), 12 => stream_socket_server('tcp://0.0.0.0:4711') ); $process = new Process($cmd, null, null, $fds); $process->start($loop); Unless your use case has special requirements that demand otherwise, you're highly recommended to (at least) pass in the standard I/O pipes as given above. The file descriptor specification accepts arguments in the exact same format as the underlying proc_open() function. Once the process is started, the $pipes array will always contain references to all pipes as configured and the standard I/O references will always be set to reference the pipes matching common Unix conventions. This library supports any number of pipes and additional file descriptors, but many common applications being run as a child process will expect that the parent process properly assigns these file descriptors. Sigchild Compatibility Internally, this project uses a work-around to improve compatibility when PHP has been compiled with the --enable-sigchild option. This should not affect most installations as this configure option is not used by default and many distributions (such as Debian and Ubuntu) are known to not use this by default. Some installations that use Oracle OCI8 may use this configure option to circumvent defunct processes. When PHP has been compiled with the --enable-sigchild option, a child process' exit code cannot be reliably determined via proc_close() or proc_get_status(). To work around this, we execute the child process with an additional pipe and use that to retrieve its exit code. This work-around incurs some overhead, so we only trigger this when necessary and when we detect that PHP has been compiled with the --enable-sigchild option. Because PHP does not provide a way to reliably detect this option, we try to inspect output of PHP's configure options from the phpinfo() function. The static setSigchildEnabled(bool $sigchild): void method can be used to explicitly enable or disable this behavior like this: // advanced: not recommended by default Process::setSigchildEnabled(true); Note that all processes instantiated after this method call will be affected. If this work-around is disabled on an affected PHP installation, the exit event may receive null instead of the actual exit code as described above. Similarly, some distributions are known to omit the configure options from phpinfo(), so automatic detection may fail to enable this work-around in some cases. You may then enable this explicitly as given above. Note: The original functionality was taken from Symfony's Process compoment. Windows Compatibility Due to platform constraints, this library provides only limited support for spawning child processes on Windows. In particular, PHP does not allow accessing standard I/O pipes without blocking. As such, this project will not allow constructing a child process with the default process pipes and will instead throw a LogicException on Windows by default: // throws LogicException on Windows $process = new Process('ping example.com'); $process->start($loop); There are a number of alternatives and workarounds as detailed below if you want to run a child process on Windows, each with its own set of pros and cons: This package does work on Windows Subsystem for Linux (or WSL) without issues. When you are in control over how your application is deployed, we recommend installing WSL when you want to run this package on Windows. If you only care about the exit code of a child process to check if its execution was successful, you can use custom pipes to omit any standard I/O pipes like this: $process = new Process('ping example.com', null, null, array()); $process->start($loop); $process->on('exit', function ($exitcode) { echo 'exit with ' . $exitcode . PHP_EOL; }); Similarly, this is also useful if your child process communicates over sockets with remote servers or even your parent process using the Socket component. This is usually considered the best alternative if you have control over how your child process communicates with the parent process. If you only care about command output after the child process has been executed, you can use custom pipes to configure file handles to be passed to the child process instead of pipes like this: $process = new Process('ping example.com', null, null, array( array('file', 'nul', 'r'), $stdout = tmpfile(), array('file', 'nul', 'w') )); $process->start($loop); $process->on('exit', function ($exitcode) use ($stdout) { echo 'exit with ' . $exitcode . PHP_EOL; // rewind to start and then read full file (demo only, this is blocking). // reading from shared file is only safe if you have some synchronization in place // or after the child process has terminated. rewind($stdout); echo stream_get_contents($stdout); fclose($stdout); }); Note that this example uses tmpfile()/fopen() for illustration purposes only. This should not be used in a truly async program because the filesystem is inherently blocking and each call could potentially take several seconds. See also the Filesystem component as an alternative. If you want to access command output as it happens in a streaming fashion, you can use redirection to spawn an additional process to forward your standard I/O streams to a socket and use custom pipes to omit any actual standard I/O pipes like this: $server = new React\\Socket\\Server('127.0.0.1:0', $loop); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->on('data', function ($chunk) { echo $chunk; }); }); $command = 'ping example.com | foobar ' . escapeshellarg($server->getAddress()); $process = new Process($command, null, null, array()); $process->start($loop); $process->on('exit', function ($exitcode) use ($server) { $server->close(); echo 'exit with ' . $exitcode . PHP_EOL; }); Note how this will spawn another fictional foobar helper program to consume the standard output from the actual child process. This is in fact similar to the above recommendation of using socket connections in the child process, but in this case does not require modification of the actual child process. In this example, the fictional foobar helper program can be implemented by simply consuming all data from standard input and forwarding it to a socket connection like this: $socket = stream_socket_client($argv[1]); do { fwrite($socket, $data = fread(STDIN, 8192)); } while (isset($data[0])); Accordingly, this example can also be run with plain PHP without having to rely on any external helper program like this: $code = '$s=stream_socket_client($argv[1]);do{fwrite($s,$d=fread(STDIN, 8192));}while(isset($d[0]));'; $command = 'ping example.com | php -r ' . escapeshellarg($code) . ' ' . escapeshellarg($server->getAddress()); $process = new Process($command, null, null, array()); $process->start($loop); See also example #23. Note that this is for illustration purposes only and you may want to implement some proper error checks and/or socket verification in actual production use if you do not want to risk other processes connecting to the server socket. In this case, we suggest looking at the excellent createprocess-windows. Additionally, note that the command given to the Process will be passed to the underlying Windows-API (CreateProcess) as-is and the process will not be launched in a wrapping shell by default. In particular, this means that shell built-in functions such as echo hello or sleep 10 may have to be prefixed with an explicit shell command like this: $process = new Process('cmd /c echo hello', null, null, $pipes); $process->start($loop); Install The recommended way to install this library is through Composer. New to Composer? This will install the latest supported version: $ composer require react/child-process:^0.6.1 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. See above note for limited Windows Compatibility. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/PromiseStream.html":{"url":"4.Utility-Components/PromiseStream.html","title":"PromiseStream","keywords":"","body":"PromiseStream The missing link between Promise-land and Stream-land for ReactPHP. Table of Contents Usage buffer() first() all() unwrapReadable() unwrapWritable() Install Tests License Usage This lightweight library consists only of a few simple functions. All functions reside under the React\\Promise\\Stream namespace. The below examples assume you use an import statement similar to this: use React\\Promise\\Stream; Stream\\buffer(…); Alternatively, you can also refer to them with their fully-qualified name: \\React\\Promise\\Stream\\buffer(…); buffer() The buffer(ReadableStreamInterface $stream, ?int $maxLength = null): PromiseInterface function can be used to create a Promise which resolves with the stream data buffer. $stream = accessSomeJsonStream(); Stream\\buffer($stream)->then(function ($contents) { var_dump(json_decode($contents)); }); The promise will resolve with all data chunks concatenated once the stream closes. The promise will resolve with an empty string if the stream is already closed. The promise will reject if the stream emits an error. The promise will reject if it is cancelled. The optional $maxLength argument defaults to no limit. In case the maximum length is given and the stream emits more data before the end, the promise will be rejected with an \\OverflowException. $stream = accessSomeToLargeStream(); Stream\\buffer($stream, 1024)->then(function ($contents) { var_dump(json_decode($contents)); }, function ($error) { // Reaching here when the stream buffer goes above the max size, // in this example that is 1024 bytes, // or when the stream emits an error. }); first() The first(ReadableStreamInterface|WritableStreamInterface $stream, string $event = 'data'): PromiseInterface function can be used to create a Promise which resolves once the given event triggers for the first time. $stream = accessSomeJsonStream(); Stream\\first($stream)->then(function ($chunk) { echo 'The first chunk arrived: ' . $chunk; }); The promise will resolve with whatever the first event emitted or null if the event does not pass any data. If you do not pass a custom event name, then it will wait for the first \"data\" event and resolve with a string containing the first data chunk. The promise will reject if the stream emits an error – unless you're waiting for the \"error\" event, in which case it will resolve. The promise will reject once the stream closes – unless you're waiting for the \"close\" event, in which case it will resolve. The promise will reject if the stream is already closed. The promise will reject if it is cancelled. all() The all(ReadableStreamInterface|WritableStreamInterface $stream, string $event = 'data'): PromiseInterface function can be used to create a Promise which resolves with an array of all the event data. $stream = accessSomeJsonStream(); Stream\\all($stream)->then(function ($chunks) { echo 'The stream consists of ' . count($chunks) . ' chunk(s)'; }); The promise will resolve with an array of whatever all events emitted or null if the events do not pass any data. If you do not pass a custom event name, then it will wait for all the \"data\" events and resolve with an array containing all the data chunks. The promise will resolve with an array once the stream closes. The promise will resolve with an empty array if the stream is already closed. The promise will reject if the stream emits an error. The promise will reject if it is cancelled. unwrapReadable() The unwrapReadable(PromiseInterface $promise): ReadableStreamInterface function can be used to unwrap a Promise which resolves with a ReadableStreamInterface. This function returns a readable stream instance (implementing ReadableStreamInterface) right away which acts as a proxy for the future promise resolution. Once the given Promise resolves with a ReadableStreamInterface, its data will be piped to the output stream. //$promise = someFunctionWhichResolvesWithAStream(); $promise = startDownloadStream($uri); $stream = Stream\\unwrapReadable($promise); $stream->on('data', function ($data) { echo $data; }); $stream->on('end', function () { echo 'DONE'; }); If the given promise is either rejected or fulfilled with anything but an instance of ReadableStreamInterface, then the output stream will emit an error event and close: $promise = startDownloadStream($invalidUri); $stream = Stream\\unwrapReadable($promise); $stream->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage(); }); The given $promise SHOULD be pending, i.e. it SHOULD NOT be fulfilled or rejected at the time of invoking this function. If the given promise is already settled and does not resolve with an instance of ReadableStreamInterface, then you will not be able to receive the error event. You can close() the resulting stream at any time, which will either try to cancel() the pending promise or try to close() the underlying stream. $promise = startDownloadStream($uri); $stream = Stream\\unwrapReadable($promise); $loop->addTimer(2.0, function () use ($stream) { $stream->close(); }); unwrapWritable() The unwrapWritable(PromiseInterface $promise): WritableStreamInterface function can be used to unwrap a Promise which resolves with a WritableStreamInterface. This function returns a writable stream instance (implementing WritableStreamInterface) right away which acts as a proxy for the future promise resolution. Any writes to this instance will be buffered in memory for when the promise resolves. Once the given Promise resolves with a WritableStreamInterface, any data you have written to the proxy will be forwarded transparently to the inner stream. //$promise = someFunctionWhichResolvesWithAStream(); $promise = startUploadStream($uri); $stream = Stream\\unwrapWritable($promise); $stream->write('hello'); $stream->end('world'); $stream->on('close', function () { echo 'DONE'; }); If the given promise is either rejected or fulfilled with anything but an instance of WritableStreamInterface, then the output stream will emit an error event and close: $promise = startUploadStream($invalidUri); $stream = Stream\\unwrapWritable($promise); $stream->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage(); }); The given $promise SHOULD be pending, i.e. it SHOULD NOT be fulfilled or rejected at the time of invoking this function. If the given promise is already settled and does not resolve with an instance of WritableStreamInterface, then you will not be able to receive the error event. You can close() the resulting stream at any time, which will either try to cancel() the pending promise or try to close() the underlying stream. $promise = startUploadStream($uri); $stream = Stream\\unwrapWritable($promise); $loop->addTimer(2.0, function () use ($stream) { $stream->close(); }); Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/promise-stream:^1.2 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/PromiseTimer.html":{"url":"4.Utility-Components/PromiseTimer.html","title":"PromiseTimer","keywords":"","body":"PromiseTimer A trivial implementation of timeouts for Promises, built on top of ReactPHP. Table of contents Usage timeout() Timeout cancellation Cancellation handler Input cancellation Output cancellation Collections resolve() Resolve cancellation reject() Reject cancellation TimeoutException Install Tests License Usage This lightweight library consists only of a few simple functions. All functions reside under the React\\Promise\\Timer namespace. The below examples assume you use an import statement similar to this: use React\\Promise\\Timer; Timer\\timeout(…); Alternatively, you can also refer to them with their fully-qualified name: \\React\\Promise\\Timer\\timeout(…); timeout() The timeout(PromiseInterface $promise, $time, LoopInterface $loop) function can be used to cancel operations that take too long. You need to pass in an input $promise that represents a pending operation and timeout parameters. It returns a new Promise with the following resolution behavior: If the input $promise resolves before $time seconds, resolve the resulting promise with its fulfillment value. If the input $promise rejects before $time seconds, reject the resulting promise with its rejection value. If the input $promise does not settle before $time seconds, cancel the operation and reject the resulting promise with a TimeoutException. Internally, the given $time value will be used to start a timer that will cancel the pending operation once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. If the input $promise is already settled, then the resulting promise will resolve or reject immediately without starting a timer at all. A common use case for handling only resolved values looks like this: $promise = accessSomeRemoteResource(); Timer\\timeout($promise, 10.0, $loop)->then(function ($value) { // the operation finished within 10.0 seconds }); A more complete example could look like this: $promise = accessSomeRemoteResource(); Timer\\timeout($promise, 10.0, $loop)->then( function ($value) { // the operation finished within 10.0 seconds }, function ($error) { if ($error instanceof Timer\\TimeoutException) { // the operation has failed due to a timeout } else { // the input operation has failed due to some other error } } ); Or if you're using react/promise v2.2.0 or up: Timer\\timeout($promise, 10.0, $loop) ->then(function ($value) { // the operation finished within 10.0 seconds }) ->otherwise(function (Timer\\TimeoutException $error) { // the operation has failed due to a timeout }) ->otherwise(function ($error) { // the input operation has failed due to some other error }) ; Timeout cancellation As discussed above, the timeout() function will cancel the underlying operation if it takes too long. This means that you can be sure the resulting promise will then be rejected with a TimeoutException. However, what happens to the underlying input $promise is a bit more tricky: Once the timer fires, we will try to call $promise->cancel() on the input $promise which in turn invokes its cancellation handler. This means that it's actually up the input $promise to handle cancellation support. A common use case involves cleaning up any resources like open network sockets or file handles or terminating external processes or timers. If the given input $promise does not support cancellation, then this is a NO-OP. This means that while the resulting promise will still be rejected, the underlying input $promise may still be pending and can hence continue consuming resources. See the following chapter for more details on the cancellation handler. Cancellation handler For example, an implementation for the above operation could look like this: function accessSomeRemoteResource() { return new Promise( function ($resolve, $reject) use (&$socket) { // this will be called once the promise is created // a common use case involves opening any resources and eventually resolving $socket = createSocket(); $socket->on('data', function ($data) use ($resolve) { $resolve($data); }); }, function ($resolve, $reject) use (&$socket) { // this will be called once calling `cancel()` on this promise // a common use case involves cleaning any resources and then rejecting $socket->close(); $reject(new \\RuntimeException('Operation cancelled')); } ); } In this example, calling $promise->cancel() will invoke the registered cancellation handler which then closes the network socket and rejects the Promise instance. If no cancellation handler is passed to the Promise constructor, then invoking its cancel() method it is effectively a NO-OP. This means that it may still be pending and can hence continue consuming resources. For more details on the promise cancellation, please refer to the Promise documentation. Input cancellation Irrespective of the timeout handling, you can also explicitly cancel() the input $promise at any time. This means that the timeout() handling does not affect cancellation of the input $promise, as demonstrated in the following example: $promise = accessSomeRemoteResource(); $timeout = Timer\\timeout($promise, 10.0, $loop); $promise->cancel(); The registered cancellation handler is responsible for handling the cancel() call: A described above, a common use involves resource cleanup and will then reject the Promise. If the input $promise is being rejected, then the timeout will be aborted and the resulting promise will also be rejected. If the input $promise is still pending, then the timout will continue running until the timer expires. The same happens if the input $promise does not register a cancellation handler. Output cancellation Similarily, you can also explicitly cancel() the resulting promise like this: $promise = accessSomeRemoteResource(); $timeout = Timer\\timeout($promise, 10.0, $loop); $timeout->cancel(); Note how this looks very similar to the above input cancellation example. Accordingly, it also behaves very similar. Calling cancel() on the resulting promise will merely try to cancel() the input $promise. This means that we do not take over responsibility of the outcome and it's entirely up to the input $promise to handle cancellation support. The registered cancellation handler is responsible for handling the cancel() call: As described above, a common use involves resource cleanup and will then reject the Promise. If the input $promise is being rejected, then the timeout will be aborted and the resulting promise will also be rejected. If the input $promise is still pending, then the timout will continue running until the timer expires. The same happens if the input $promise does not register a cancellation handler. To re-iterate, note that calling cancel() on the resulting promise will merely try to cancel the input $promise only. It is then up to the cancellation handler of the input promise to settle the promise. If the input promise is still pending when the timeout occurs, then the normal timeout cancellation handling will trigger, effectively rejecting the output promise with a TimeoutException. This is done for consistency with the timeout cancellation handling and also because it is assumed this is often used like this: $timeout = Timer\\timeout(accessSomeRemoteResource(), 10.0, $loop); $timeout->cancel(); As described above, this example works as expected and cleans up any resources allocated for the input $promise. Note that if the given input $promise does not support cancellation, then this is a NO-OP. This means that while the resulting promise will still be rejected after the timeout, the underlying input $promise may still be pending and can hence continue consuming resources. Collections If you want to wait for multiple promises to resolve, you can use the normal promise primitives like this: $promises = array( accessSomeRemoteResource(), accessSomeRemoteResource(), accessSomeRemoteResource() ); $promise = \\React\\Promise\\all($promises); Timer\\timeout($promise, 10, $loop)->then(function ($values) { // *all* promises resolved }); The applies to all promise collection primitives alike, i.e. all(), race(), any(), some() etc. For more details on the promise primitives, please refer to the Promise documentation. resolve() The resolve($time, LoopInterface $loop) function can be used to create a new Promise that resolves in $time seconds with the $time as the fulfillment value. Timer\\resolve(1.5, $loop)->then(function ($time) { echo 'Thanks for waiting ' . $time . ' seconds' . PHP_EOL; }); Internally, the given $time value will be used to start a timer that will resolve the promise once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. Resolve cancellation You can explicitly cancel() the resulting timer promise at any time: $timer = Timer\\resolve(2.0, $loop); $timer->cancel(); This will abort the timer and reject with a RuntimeException. reject() The reject($time, LoopInterface $loop) function can be used to create a new Promise which rejects in $time seconds with a TimeoutException. Timer\\reject(2.0, $loop)->then(null, function (TimeoutException $e) { echo 'Rejected after ' . $e->getTimeout() . ' seconds ' . PHP_EOL; }); Internally, the given $time value will be used to start a timer that will reject the promise once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. This function complements the resolve() function and can be used as a basic building block for higher-level promise consumers. Reject cancellation You can explicitly cancel() the resulting timer promise at any time: $timer = Timer\\reject(2.0, $loop); $timer->cancel(); This will abort the timer and reject with a RuntimeException. TimeoutException The TimeoutException extends PHP's built-in RuntimeException. The getTimeout() method can be used to get the timeout value in seconds. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/promise-timer:^1.6 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "}}