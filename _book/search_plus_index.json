{"./":{"url":"./","title":"简介","keywords":"","body":" 事件驱动,非阻塞I/O的PHP $loop = React\\EventLoop\\Factory::create(); $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); $socket = new React\\Socket\\Server(8080, $loop); $server->listen($socket); echo \"Server running at http://127.0.0.1:8080\\n\"; $loop->run(); 这个用ReactPHP编写的简单的Web服务器对每个请求都响应 \"Hello World\" ReactPHP是PHP中用于事件驱动编程的底层库。 核心是一个事件循环，它在其上提供底层实用程序， 例如：流抽象，异步DNS解析器，网络客户端/服务器，HTTP客户机/服务器和与进程的交互。 第三方库可以使用这些用于创建异步网络客户端/服务器等的组件。 ReactPHP已经可用于生产环境，并且经过来自世界各地的各种项目数百万次的安装测试。 由于事件驱动架构，使它非常适合高效的网络服务器和处理数百或数千个并发连接，长期运行的应用程序和许多其他无阻塞I / O操作的协作多任务形式。 ReactPHP之所以与众不同，是因为其活跃的生态系统具有数百个第三方库，可让您与许多现有系统集成 ，例如公共网络服务、数据库系统和其他第三方API。 生产就绪，并经过了实战测试。 稳固的，具有稳定的长期支持（LTS）版本。 不需要扩展，并且可以在任何平台上运行-没有任何借口！ 利用可选扩展来获得更好的性能（如果可用）。 强烈建议使用最新版本的PHP 7 +，以获得最佳性能和支持。 支持旧版PHP 5.3+和HHVM，以实现最大兼容性。 精心设计的和可重复使用的组件。 分离的零件，因此可以用其他实现方式替换它们。 经过测试（单位和功能）。 尽可能采用标准PSR，以实现最大的互操作性。 旨在“技术中立”，因此您可以使用首选的应用程序堆栈。 小型核心专业团队由外部贡献者的大型网络支持。 默认情况下，ReactPHP是非阻塞的，workers阻止I / O。 事件循环基于反应堆模式（因此命名），并且强烈受诸如EventMachine（Ruby），Twisted（Python）和 Node.js（V8）。 核心组件 EventLoop ReactPHP的核心反应器event-loop 文档 Stream 事件驱动的可读写流，用于ReactPHP中的非阻塞I / O 文档 Promise Promises/A 的PHP实现 文档 网络组件 Socket 异步，流式传输纯文本TCP / IP以及安全TLS套接字服务器和客户端连接 文档 Datagram 事件驱动的UDP客户端和服务器套接字 文档 协议组件 HTTP 事件驱动的流式纯文本HTTP和安全HTTPS服务器 文档 HTTPClient 事件驱动的HTTP流客户端 文档 DNS 异步DNS解析器 文档 实用组件 Cache 异步缓存 文档 ChildProcess 执行子进程的库。 文档 PromiseTimer ReactPHP的Promise库的简单超时实现。 文档 PromiseStream 在ReactPHP之上构建的Promise和Stream之间的衔接环节。 文档 "},"1.Core-Components/EventLoop.html":{"url":"1.Core-Components/EventLoop.html","title":"EventLoop","keywords":"","body":"EventLoop组件 ReactPHP的核心事件循环，用于事件I/O 为了使基于异步的库可互操作，它们需要使用相同的事件循环。 该组件提供了一个任何库都可以定位的通用公共LoopInterface， 这使它们可以在同一循环中使用，并由用户控制一个 run()调用。 目录 快速开始 用法 Factory create() Loop implementations StreamSelectLoop ExtEventLoop ExtLibeventLoop ExtLibevLoop ExtEvLoop ExtUvLoop LoopInterface run() stop() addTimer() addPeriodicTimer() cancelTimer() futureTick() addSignal() removeSignal() addReadStream() addWriteStream() removeReadStream() removeWriteStream() 安装 测试 License 快速开始 这里是一个仅使用事件循环构建的异步HTTP服务器。 $loop = React\\EventLoop\\Factory::create(); $server = stream_socket_server('tcp://127.0.0.1:8080'); stream_set_blocking($server, false); $loop->addReadStream($server, function ($server) use ($loop) { $conn = stream_socket_accept($server); $data = \"HTTP/1.1 200 OK\\r\\nContent-Length: 3\\r\\n\\r\\nHi\\n\"; $loop->addWriteStream($conn, function ($conn) use (&$data, $loop) { $written = fwrite($conn, $data); if ($written === strlen($data)) { fclose($conn); $loop->removeWriteStream($conn); } else { $data = substr($data, $written); } }); }); $loop->addPeriodicTimer(5, function () { $memory = memory_get_usage() / 1024; $formatted = number_format($memory, 3).'K'; echo \"Current memory usage: {$formatted}\\n\"; }); $loop->run(); 查看示例. 用法 典型的应用程序：开始时创建的单个事件循环，程序结束时运行。 // [1] $loop = React\\EventLoop\\Factory::create(); // [2] $loop->addPeriodicTimer(1, function () { echo \"Tick\\n\"; }); $stream = new React\\Stream\\ReadableResourceStream( fopen('file.txt', 'r'), $loop ); // [3] $loop->run(); 在程序开始时创建循环实例React\\EventLoop\\Factory::create() 并选择最佳的可用循环实现. 2.循环实例可直接使用或传递给库和应用程序代码。 在此示例中，向事件循环注册了一个定期定时器，该循环每秒输出一次 Tick ， 并使用ReactPHPstream组件 创建可读流进行演示。 3.循环在程序最后通过单个$loop->run()运行。 Factory Factory 类是一个提供便捷创建循环实例的最佳类 事件循环实现. create() create()：LoopInterface 方法可用于创建新的事件循环 例子: $loop = React\\EventLoop\\Factory::create(); 该方法返回实现LoopInterface的实例，事件循环实现是一个具体实现。 该方法通常只能在程序开始时调用一次。 Loop implementations 除了LoopInterface之外，还有一些提供了事件循环实现。 所有事件循环都支持以下功能： 文件描述符轮询 一次性定时器 周期定时器 在未来循环中延迟执行 对于此软件包的大多数使用者而言，底层事件循环实现是具体实现。 您应该使用Factory自动创建一个新实例。 高级！ 如果您明确需要某个事件循环实现，则可以手动实例化以下类之一。 请注意，您可能必须为其安装相应的PHP扩展，否则它们将在创建时抛出 BadMethodCallException 异常。 StreamSelectLoop 基于stream_select()的事件循环。 使用stream_select() 函数，它是唯一一个使用PHP开箱即用的实现。 在php5.3到php7+和HHVM上，这个事件循环是开箱即用的。这意味着不需要额外安装其他扩展，而且这个库可以在所有支持的PHP的平台上工作。 因此，如果您没有安装下面列出的事件循环扩展， Factory将默认使用此事件循环。 在后台，它执行一个简单的 select 系统调用。 该系统调用限于 FD_SETSIZE 的最大文件描述符数量（取决于平台，通常为1024），并以 O(m) （ m 是传递的最大文件描述符数量）进行缩放。 这意味着在同时处理数千个流时，您可能会遇到问题，并且在这种情况下，您可能想研究使用下面列出的事件循环实现之一替代。 如果您的用例属于仅涉及一次处理数十个或几百个流，则此事件循环实现的执行效果非常好。 如果要使用信号处理（另请参见下面的addSignal() ），此事件循环实现需要安装ext-pcntl扩展。 此扩展仅适用于类Unix平台，不支持Windows, 该扩展通常作为许多PHP发行版的一部分安装。 如果缺少此扩展名（或您正在Windows上运行），则不支持信号处理，将抛出BadMethodCallException异常。 PHP 7.3之前的版本，该事件循环都依赖于时钟时间来安排将来的定时器，因为单调时间源仅从PHP 7.3+ 可用（hrtime()）。 尽管这并不影响大部分应用程序，但这对于依赖于高时间精度的程序或受不连续时间调整（时间跳跃）影响的系统而言，是一个重要的区别。 这意味着，如果您安排一个定时器在PHP addTimer()。 ExtEventLoop 基于ext-event的事件循环。 使用event PECL extension 扩展，与libevent相同。 此循环可用于PHP 5.4到PHP 7+。 ExtEvLoop 基于ext-ev的事件循环。 使用 ev PECL extension 扩展，提供 libev 库的接口。 此循环可用于PHP 5.4到PHP 7+。 ExtUvLoop 基于ext-uv的事件循环。 使用 uv PECL extension 扩展， 提供 libuv 库的接口。 此循环可用于PHP 7+。 ExtLibeventLoop 基于ext-libevent的事件循环。 使用 libevent PECL extension 扩展。 libevent 本身支持许多特定于系统的后端（epoll，kqueue）。 此事件循环仅适用于PHP 5。 存在用于PHP 7 的版本 非正式更新 ，但已知由于SEGFAULT导致定期崩溃。 重申一下：不建议在PHP 7上使用此事件循环。 因此Factory将不会尝试在PHP 7上使用此事件循环。 已知只有在流变得可读（边缘触发）时才触发事件侦听器，并且如果从一开始就已经可读该流，则可能不会触发。 这也意味着，当数据仍留在PHP的内部流缓冲区中时，该流可能不被视为可读。 因此，在这种情况下，建议使用stream_set_read_buffer($stream, 0);禁用PHP的内部读取缓冲区。 另请参见addReadStream()。 ExtLibevLoop 基于ext-libev的事件循环。 使用非正式的 libev 扩展名 扩展，与libevent相同。 此循环仅适用于PHP 5。 PHP 7的更新不太可能 LoopInterface run() 使用 run(): void 方法执行事件循环，直到没有任务执行为止。 对于大部分应用程序，该方法是事件循环上唯一直接可见的调用。 根据经验，通常建议将所有内容附加到同一循环实例，然后在应用程序的最底端运行一次循环。 $loop->run(); 此方法将使循环保持运行状态，直到没有其他任务可以执行为止。 换句话说：此方法将阻塞直到最后一个定时器，流 和/或 信号被删除为止。 同样，必须确保应用程序实际调用此方法一次。如果将侦听器添加到循环中而没有执行该方法，任何附加的监听器将不再等待，应用程序会直接退出。 循环已在运行时，不能调用此方法。此方法在显式调用stop()ped后或由于以前不再有任何操作而自动停止后，可能会被多次调用。 stop() 运行stop(): void方法将停止正在运行的事件循环。 此方法为高级用法，应小心使用。通常建议仅当循环不再有任何事情要做时才自动停止。 此方法用于显式指示事件循环停止： $loop->addTimer(3.0, function () use ($loop) { $loop->stop(); }); 对当前未运行的循环实例或已停止的循环实例调用此方法无效。 addTimer() addTimer(float $interval, callable $callback): TimerInterface 方法可用于将要在设定间隔（秒）后调用回调。 定时器回调函数必须能够接受单个参数，定时器实例也是由这个方法返回的，或者您可以使用一个完全没有参数的函数。 定时器回调函数不能抛出Exception。 定时器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 与addPeriodicTimer()不同，此方法将确保在设定间隔（秒）后只调用一次回调。 您可以调用cancelTimer来取消挂起的定时器。 $loop->addTimer(0.8, function () { echo 'world!' . PHP_EOL; }); $loop->addTimer(0.3, function () { echo 'hello '; }); 示例#1. 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： function hello($name, LoopInterface $loop) { $loop->addTimer(1.0, function () use ($name) { echo \"hello $name\\n\"; }); } hello('Tester', $loop); 此接口不强制任意间隔的定时器，因此如果您依赖毫秒或以下的非常高的精度，可能需要特别小心。除非另有说明，否则事件循环实现应尽力提供高精度间隔，并应至少提供毫秒精度。 已知许多现有的事件循环实现提供微秒精度，但通常不建议依赖这种高精度。 类似地，不能保证在同一时间（在其可能的精度范围内）被调度执行的定时器的执行顺序。 此接口建议事件循环实现应使用单调时间源（如果可用）。假设单调时间源在默认情况下仅在php7.3中可用，那么事件循环实现可能会退回到使用挂钟时间。 虽然这不会影响许多常见的用例，但对于依赖高时间精度或受不连续时间调整（时间跳跃）影响的系统的程序来说，这是很重要的一点。 这意味着如果你安排一个定时器在30秒后触发，然后调整你的系统时间向前20秒，定时器仍应在30秒后触发。 有关详细信息，请参见事件循环实现 addPeriodicTimer() addPeriodicTimer(float $interval, callable $callback): TimerInterface 方法可用于将要在设定间隔（秒）后重复调用的回调。 定时器回调函数必须能够接受单个参数，定时器实例也是由这个方法返回的，或者您可以使用一个完全没有参数的函数。 定时器回调函数不能抛出Exception。 定时器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 与addTimer()不同，此方法将确保在设定间隔（秒）后重复调用回调。 您可以调用cancelTimer来取消挂起的定时器。 $timer = $loop->addPeriodicTimer(0.1, function () { echo 'tick!' . PHP_EOL; }); $loop->addTimer(1.0, function () use ($loop, $timer) { $loop->cancelTimer($timer); echo 'Done' . PHP_EOL; }); 示例#2. 如果要限制执行次数，可以将控制变量通过use绑定的回调闭包中，如下所示： function hello($name, LoopInterface $loop) { $n = 3; $loop->addPeriodicTimer(1.0, function ($timer) use ($name, $loop, &$n) { if ($n > 0) { --$n; echo \"hello $name\\n\"; } else { $loop->cancelTimer($timer); } }); } hello('Tester', $loop); 此接口不强制任意间隔的定时器，因此如果您依赖毫秒或以下的非常高的精度，可能需要特别小心。除非另有说明，否则事件循环实现应尽力提供高精度间隔，并应至少提供毫秒精度。 已知许多现有的事件循环实现提供微秒精度，但通常不建议依赖这种高精度。 类似地，不能保证在同一时间（在其可能的精度范围内）被调度执行的定时器的执行顺序。 此接口建议事件循环实现应使用单调时间源（如果可用）。假设单调时间源在默认情况下仅在php7.3中可用，那么事件循环实现可能会退回到使用挂钟时间。 虽然这不会影响许多常见的用例，但对于依赖高时间精度或受不连续时间调整（时间跳跃）影响的系统的程序来说，这是很重要的一点。 这意味着如果你安排一个定时器在30秒后触发，然后调整你的系统时间向前20秒，定时器仍应在30秒后触发。 有关详细信息，请参见事件循环实现 此外，由于每次调用后都要进行重新调度，周期性定时器可能会发生定时器漂移。 因此，通常不建议在毫秒级或以下的高精度间隔中使用此方法。 cancelTimer() cancelTimer(TimerInterface $timer): void 方法可用于取消待处理的定时器。 addPeriodicTimer() 示例#2. 对没有添加到循环实例的定时器或已取消的定时器调用此方法无效。 futureTick() futureTick(callable $listener): void 方法可用于安排在事件循环的未来时刻调用的回调。 这与间隔为 0 秒的定时器非常相似，但是它不会被插入定时器队列中，进而减少队列开销。 tick回调函数必须能够接受零参数。tick回调函数不抛出Exception。 tick回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： function hello($name, LoopInterface $loop) { $loop->futureTick(function () use ($name) { echo \"hello $name\\n\"; }); } hello('Tester', $loop); 与定时器不同，tick回调保证按其入队的顺序执行。同样，一旦将回调放入队列，就无法取消此操作。 这通常用于将较大的任务分解为较小的步骤（一种协作式多任务处理形式）。 $loop->futureTick(function () { echo 'b'; }); $loop->futureTick(function () { echo 'c'; }); echo 'a'; 示例#3. addSignal() addSignal(int $signal, callable $listener): void 方法可用于注册一个侦听器，以便在此过程捕获到信号时得到通知。 这对于从supervisor 或 systemd之类的工具捕获用户中断信号或关闭信号很有用。 通过此方法添加的信号，侦听器回调函数必须能够接受单个参数或者您可以使用完全不带参数的函数。 侦听器回调函数不得抛出 Exception 监听器回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 $loop->addSignal(SIGINT, function (int $signal) { echo 'Caught user interrupt signal' . PHP_EOL; }); 示例#4. 信号仅在类似Unix的平台上可用，由于操作系统限制，不支持Windows。 如果此平台不支持信号，例如缺少所需的扩展名，则此方法可能抛出BadMethodCallException。 注意 ：一个监听器只能添加到同一信号一次，多次添加将被忽略。 removeSignal() removeSignal(int $signal, callable $listener): void 方法可用于删除先前添加的信号监听器。 $loop->removeSignal(SIGINT, $listener); 删除未注册的监听器将被忽略。 addReadStream() 高级！ 请注意，此底层API被视为高级用法。 大多数用例可能应该使用更高级别的API来替代 可读流API addReadStream(resource $stream, callable $callback): void 方法可用于注册侦听器，以便在流准备好读取时收到通知。 第一个参数必须是一个有效的流资源，它支持检查循环实现是否可以读取它。 单个流资源不能添加多次。 但可以先调用removeReadStream()，或者使用单个侦听器对此事件做出反应，然后从此侦听器中进行调度。如果循环实现不支持给定的资源类型，则此方法可能引发Exception 添加的流资源侦听器回调函数必须能够接受单个参数或者您可以使用完全没有参数的函数。 侦听器回调函数不能抛出Exception 侦听器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： $loop->addReadStream($stream, function ($stream) use ($name) { echo $name . ' said: ' . fread($stream); }); 示例#11. 您可以调用 removeReadStream() 删除此流的读取事件侦听器。 无法保证多个流同时准备就绪时侦听器的执行顺序。 某些事件循环实现仅在流变得可读（边缘触发）时才触发侦听器，并且如果从一开始就已经可读该流，则可能不会触发。 这也意味着，当数据仍留在PHP的内部流缓冲区中时，该流可能不被视为可读。 在这种情况下，建议使用stream_set_read_buffer($stream, 0);禁用PHP的内部读取缓冲区。 addWriteStream() 高级！ 请注意，此底层API被视为高级用法。大多数用例可能应该使用更高级别的API替代可写流API addWriteStream(resource $stream, callable $callback): void 方法可用于注册一个侦听器，以便在流准备好写入时得到通知。 第一个参数务必是有效的流资源，它支持检查是否已准备好通过此循环实现进行写入。 单个流资源不得多次添加。 相反，请先调用removeWriteStream()或使用单个侦听器对此事件做出反应，然后从该事件进行分派监听。 如果此循环实现不支持给定的资源类型，则此方法可以抛出 Exception 添加的流资源侦听器回调函数必须能够接受单个参数或者您可以使用完全没有参数的函数。 侦听器回调函数不得抛出Exception 监听器回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： $loop->addWriteStream($stream, function ($stream) use ($name) { fwrite($stream, 'Hello ' . $name); }); 示例#12. 您可以调用 removeWriteStream() 删除此流的写入事件侦听器。 无法保证多个流同时准备就绪时侦听器的执行顺序。 removeReadStream() removeReadStream(resource $stream): void 方法可用于删除给定流的可读事件监听器。 从循环中删除已删除的流，或尝试删除从未添加过或无效的流时此方法无效。 removeWriteStream() removeWriteStream(resource $stream): void 方法可用于删除给定流的可写事件监听器。 从循环中删除已删除的流，或尝试删除从未添加过或无效的流时此方法无效。 安装 推荐安装 通过Composer. Composer新手? 该项目遵循 SemVer. 这将安装最新的受支持版本： $ composer require react/event-loop:^1.1.1 另请参见 CHANGELOG ，以获取有关版本升级的详细信息。 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈建议在这个项目中使用PHP7+。 建议安装任何一个事件循环扩展，但完全是可选的。 有关详细信息，请参见事件循环实现 测试 要运行测试套件，首先需要克隆此存储库，然后安装所有依赖项 通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行： $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"1.Core-Components/Promise.html":{"url":"1.Core-Components/Promise.html","title":"Promise","keywords":"","body":"Promise PHP的 CommonJS Promises/A 的轻量级实现。 主分支包含即将发布的3.0版本的代码。 对于当前稳定的2.x版本的代码，请检查 2.x分支 即将发布的3.0版本将是此软件包的主发展方向。 但是，对于尚未安装PHP 7+的用户，我们仍将积极支持2.0和1.0。 目录 简介 概念 Deferred（延迟） Promise（承诺） API Deferred Deferred::promise() Deferred::resolve() Deferred::reject() PromiseInterface PromiseInterface::then() PromiseInterface::done() PromiseInterface::otherwise() PromiseInterface::always() PromiseInterface::cancel() Promise Functions resolve() reject() all() race() any() some() map() reduce() PromisorInterface 示例 如何使用Deferred 承诺转发的工作原理 转发履行 转发拒绝 转发履行和拒绝 done() vs. then() Credits License 简介 Promise是一个为PHP实现CommonJS Promises/A 的库。 它还提供了其他一些与承诺相关的有用概念，例如加入多个承诺以及映射和减少承诺集合。 如果您以前从未听说过诺言，请先阅读此内容 概念 Deferred（延迟） Deferred 表示可能尚未完成的计算或工作单元。 通常（但并非总是）该计算将异步执行并在将来的某个时刻完成。 Promise（承诺） Deferred 表示计算本身，而 Promise 表示该计算的结果。 因此，每个Deferred 者都有一个承诺，可以充当其实际结果的占位符。 API Deferred Deferred 表示其解析挂起的操作。它有单独的promise和resolver部分。 $deferred = new React\\Promise\\Deferred(); $promise = $deferred->promise(); $deferred->resolve(mixed $value = null); $deferred->reject(\\Throwable $reason); promise 方法返回延迟的承诺。 resolve和reject 方法控制延迟状态。 Deferred的构造函数接受一个可选的$canceller参数。有关更多信息，请参见Promise Deferred::promise() $promise = $deferred->promise(); 返回延期的承诺，您可以将其分发给其他人，同时保留自行修改其状态的权限。 Deferred::resolve() $deferred->resolve(mixed $value = null); 解决promise()返回的承诺。 $value调用 $onFulfilled来通知所有消费者（它们通过$promise->then() 注册）。 如果$value本身是一个承诺，那么一旦这个承诺被解决，它将转换到这个承诺的状态。 Deferred::reject() $deferred->reject(\\Throwable $reason); 拒绝promise()返回的承诺，表示延迟的计算失败。 所有消费者都会收到通知，方法是使用$reason调用$onRejected（它们通过$promise->then()注册）。 PromiseInterface PromiseInterface 为所有promise实现提供公共接口。 请参阅Promise以获取此包唯一公共实现。 一个承诺代表一个最终的结果，要么是实现（成功）和相关的结果，要么是拒绝（失败）和相关的原因。 一旦承诺处于履行或拒绝的状态，承诺就变得不可更改。 它的状态和结果（或错误）都不能修改。 PromiseInterface::then() $transformedPromise = $promise->then(callable $onFulfilled = null, callable $onRejected = null); 通过对承诺的履行或拒绝的结果，应用函数来转换承诺的状态值并返回转换结果的新承诺。 then() 方法用于一个promise注册新的已完成和拒绝处理程序（所有参数都是可选的）： 一旦承诺实现，其结果将作为第一个参数传递，就会调用$onFulfilled 一旦承诺被拒绝，其原因作为第一个参数传递，就会调用$onRejected $onFulfilled或$onRejected的返回一个新的promise，无论哪个被调用，或者其中一个抛出异常则抛出异常。 promise 对在then()的同一调用中注册的处理回调做出以下保证： 1.仅会调用$onFulfilled 或 $onRejected中的一个，两者不会都调用。 2.$onFulfilled 和 $onRejected 不会被调用一次以上。 另请参见 resolve() - 创造承诺 reject() - 创建拒绝的承诺 PromiseInterface::done() done() vs. then() PromiseInterface::done() $promise->done(callable $onFulfilled = null, callable $onRejected = null); 如果承诺履行或拒绝，则耗费承诺的最终结果。 如果 $onFulfilled 或 $onRejected抛出或返回被拒绝的诺言，将导致致命错误(E_USER_ERROR) 由于done()的目的是消费而不是转换，所以done()总是返回null。 另请参见 PromiseInterface::then() done() vs. then() PromiseInterface::otherwise() $promise->otherwise(callable $onRejected); 注册拒绝处理程序以进行承诺。 快捷操作方式如下： $promise->then(null, $onRejected); 另外，您可以传入提示$onRejected的$reason参数，仅捕获特定的错误。 $promise ->otherwise(function (\\RuntimeException $reason) { // Only catch \\RuntimeException instances // All other types of errors will propagate automatically }) ->otherwise(function (\\Throwable $reason) { // Catch other errors )}; PromiseInterface::always() $newPromise = $promise->always(callable $onFulfilledOrRejected); 允许您在承诺链中执行“清理”类型的任务。 当promise被履行或被拒绝时调用$onFulfilledOrRejected(不带任何参数)回调 如果$promise履行，并且$onFulfilledOrRejected成功返回，则$newPromise履行与$promise相同的值。 如果$promise履行，并且$onFulfilledOrRejected抛出或返回被拒绝的承诺，$newPromise将抛出的异常或拒绝的承诺的原因。 如果$promise拒绝，并且$onFulfilledOrRejected成功返回，则$newPromise与$promise以相同的原因拒绝。 如果$promise拒绝，并且$onFulfilledOrRejected抛出或返回被拒绝的承诺，$newPromise将抛出的异常或拒绝的承诺的原因。 always()的行为于synchronous finally语句类似。当与otherwise()结合使用时，always()允许您编写于熟悉的同步catch/finally类似的代码。 考虑以下同步代码： try { return doSomething(); } catch (\\Throwable $e) { return handleError($e); } finally { cleanup(); } 可以编写类似的异步代码（doSomething()返回承诺）： return doSomething() ->otherwise('handleError') ->always('cleanup'); PromiseInterface::cancel() $promise->cancel(); cancel() 方法通知承诺创建者对操作的结果不再感兴趣。 一旦兑现了承诺（无论是履行还是拒绝），对承诺调用cancel()无效。 Promise 创建一个promise，其状态由传$resolver函数控制。 $resolver = function (callable $resolve, callable $reject) { // Do some work, possibly asynchronously, and then // resolve or reject. $resolve($awesomeResult); // or throw new Exception('Promise rejected'); // or $resolve($anotherPromise); // or $reject($nastyError); }; $canceller = function () { // Cancel/abort any running operations like network connections, streams etc. // Reject promise by throwing an exception throw new Exception('Promise cancelled'); }; $promise = new React\\Promise\\Promise($resolver, $canceller); promise构造函数将接收一个resolver函数和一个可选的canceller函数，这两个函数都将使用3个参数进行调用： $resolve($value) - 包装返回的promise的主要函数。 接受非承诺值或其他承诺。 当用非承诺值调用时，用该值实现承诺。当以另一个承诺被调用时， 例如 $resolve($otherPromise)，包装返回的promise等同于$otherPromise。 $rejec($reason) - 拒绝承诺的函数。建议只抛出异常，而不要使用$reject()。 如果resolver或canceller抛出异常，则将以该抛出的异常作为拒绝原因来拒绝承诺。 resolver函数将立即被调用，只有当所有使用者调用promise的cancel()方法时，canceller函数才会被调用。 Functions 用于创建、连接、映射和减少承诺集合的有用函数。 所有处理承诺集合的功能（例如all()，race()，some()等）都支持取消。 这意味着，如果您对返回的诺言调用cancel()，则集合中的所有诺言都会被取消。 resolve() $promise = React\\Promise\\resolve(mixed $promiseOrValue); 为$promiseOrValue创建一个承诺。 如果$promiseOrValue是一个值，它将是返回承诺 如果$promiseOrValue拥有thenable能力（提供then()方法的对象），则返回跟随thenable状态的可信承诺。 如果$promiseOrValue是一个承诺，它将按原样返回。 reject() $promise = React\\Promise\\reject(\\Throwable $reason); 为$reason创建一个拒绝的promise。 注意\\Throwable PHP7中引入的接口包括两个用户区域 \\Exception 和 \\Error 内部PHP错误。 通过强制使用\\Throwable作为拒绝承诺的理由，任何语言错误或用户地异常都可以用来拒绝承诺。 all() $promise = React\\Promise\\all(array $promisesOrValues); 返回一个承诺，该承诺仅在$promisesOrValues中的所有项都已解析时才会解析。 返回的承诺的解析值将是一个数组，其中包含$promisesOrValues中每个项的解析值。 race() $promise = React\\Promise\\race(array $promisesOrValues); 发起一场允许一名获胜者参加的竞赛。返回一个承诺，该承诺的解决方式与第一个履行的承诺解决方式相同。 如果$promisesOrValues包含0项，则返回的承诺将无限挂起。 any() $promise = React\\Promise\\any(array $promisesOrValues); 返回将在$promisesOrValues中的任何一项兑现的承诺。返回的承诺的值将是触发项的值。 只有在$promisesOrValues中的 所有 项被拒绝时，返回的承诺才会被拒绝。 拒绝值将是React\\Promise\\Exception\\CompositeException，其中包含所有拒绝原因。 拒绝原因可以通过CompositeException::getThrowables()获得。 如果$promisesOrValues包含0项，则返回的承诺也将拒绝， 并带有React\\Promise\\Exception\\LengthException some() $promise = React\\Promise\\some(array $promisesOrValues, integer $howMany); 返回一个承诺，当$promisesOrValues中至少有$howMany个提供的项兑现时，该承诺将被兑现。 返回的承诺的值将是一个长度为$howMany的数组，该数组包含首先解析的$howMany已兑现承诺的值。 如果$howMany项无法兑现（即(count($promisesOrValues)-$howMany)+1项拒绝）， 则返回的承诺将拒绝。拒绝值将是一个React\\Promise\\Exception\\CompositeException, 其中包含(count($promisesOrValues)-$howMany)+1拒绝原因。 拒绝原因可以通过CompositeException::getExceptions()获得。 如果$promisesOrValues包含的项目少于$howMany，则返回的承诺也将被拒绝， 并带有React\\Promise\\Exception\\LengthException。 map() $promise = React\\Promise\\map(array $promisesOrValues, callable $mapFunc); 传统的map函数，类似于array_map()，但允许输入包含承诺 和/或 值，$mapFunc可以返回值或承诺。 map函数接收每个项作为参数，其中item是$promisesOrValues中的promise或value的完全解析值。 reduce() $promise = React\\Promise\\reduce(array $promisesOrValues, callable $reduceFunc, $initialValue = null); 传统的reduce函数，类似于array_reduce()，但输入可以包含承诺 和/或 值， $reduceFunc可以返回值或承诺 和 $initialValue可以是承诺或起始值。 PromisorInterface React\\Promise\\PromisorInterface提供实现承诺的公共接口。 React\\Promise\\Deferred实现了它，但是由于它是公共API的一部分，任何人都可以实现它。 示例 如何使用Deferred function getAwesomeResultPromise() { $deferred = new React\\Promise\\Deferred(); // Execute a Node.js-style function using the callback pattern computeAwesomeResultAsynchronously(function (\\Throwable $error, $result) use ($deferred) { if ($error) { $deferred->reject($error); } else { $deferred->resolve($result); } }); // Return the promise return $deferred->promise(); } getAwesomeResultPromise() ->then( function ($value) { // Deferred resolved, do something with $value }, function (\\Throwable $reason) { // Deferred rejected, do something with $reason } ); 承诺转发的工作原理 几个简单的例子来展示promise/A转发机制是如何工作的。 当然，这些示例是精心设计的，在实际使用中，承诺链通常会分布在几个函数调用中，甚至是应用程序架构的几个级别。 转发履行 已履行承诺将值转发给下一个承诺。 第一个承诺$deferred->promise()将用下面传递给$deferred->resolve()的值来进行解析。 每次调用then()都会返回一个新的承诺，该承诺将使用前一个处理程序的返回值进行解析。这里创建了一个承诺“管道”。 $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { // $x will be the value passed to $deferred->resolve() below // and returns a *new promise* for $x + 1 return $x + 1; }) ->then(function ($x) { // $x === 2 // This handler receives the return value of the // previous handler. return $x + 1; }) ->then(function ($x) { // $x === 3 // This handler receives the return value of the // previous handler. return $x + 1; }) ->then(function ($x) { // $x === 4 // This handler receives the return value of the // previous handler. echo 'Resolve ' . $x; }); $deferred->resolve(1); // Prints \"Resolve 4\" 转发拒绝 被拒绝的承诺的行为与try/catch类似，工作方式也与此类似:当你捕获一个异常时，你必须重新抛出进而继续向下传播。 同样，当您处理被拒绝的承诺时且传播拒绝，需通过返回被拒绝的承诺或实际抛出“重新抛出”它（因为promise将抛出的异常转换为拒绝） $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { throw new \\Exception($x + 1); }) ->otherwise(function (\\Exception $x) { // Propagate the rejection throw $x; }) ->otherwise(function (\\Exception $x) { // Can also propagate by returning another rejection return React\\Promise\\reject( new \\Exception($x->getMessage() + 1) ); }) ->otherwise(function ($x) { echo 'Reject ' . $x->getMessage(); // 3 }); $deferred->resolve(1); // Prints \"Reject 3\" 转发履行和拒绝 就像try/catch一样，您可以选择是否传播。转发履行和拒绝仍将以可预测的方式转发回调结果。 $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { return $x + 1; }) ->then(function ($x) { throw new \\Exception($x + 1); }) ->otherwise(function (\\Exception $x) { // Handle the rejection, and don't propagate. // This is like catch without a rethrow return $x->getMessage() + 1; }) ->then(function ($x) { echo 'Mixed ' . $x; // 4 }); $deferred->resolve(1); // Prints \"Mixed 4\" done() vs. then() 黄金法则是： 返回您的诺言，或调用done()方法. 乍一看，then() 和 done()看起来非常相似。 但是，有重要的区别。 then()的目的是转换promise的值，并将转换后的值传递或返回一个新的promise到代码的其他部分。 done()的目的是消费promise的值，并将转换后的值转移到代码中。 除了转换值之外，then()还允许您从中间错误中恢复或传播。 未处理的任何错误都将由Promise机制捕获，并用于拒绝then()返回的承诺。 调用done()将错误的所有责任转移到代码中。 如果错误（抛出的异常或返回的拒绝）未能在您提供done()的$onFulfilled 或 $onRejected回调中捕获，它将导致致命错误。 function getJsonResult() { return queryApi() ->then( // Transform API results to an object function ($jsonResultString) { return json_decode($jsonResultString); }, // Transform API errors to an exception function ($jsonErrorString) { $object = json_decode($jsonErrorString); throw new ApiErrorException($object->errorMessage); } ); } // Here we provide no rejection handler. If the promise returned has been // rejected, the ApiErrorException will be thrown getJsonResult() ->done( // Consume transformed object function ($jsonResultObject) { // Do something with $jsonResultObject } ); // Here we provide a rejection handler which will either throw while debugging // or log the exception getJsonResult() ->done( function ($jsonResultObject) { // Do something with $jsonResultObject }, function (ApiErrorException $exception) { if (isDebug()) { throw $exception; } else { logException($exception); } } ); Credits 承诺是 when.js 的一部分，作者Brian Cavalier. 而且，大部分文档都是来源于when.js Wiki 和 API docs. License Released under the MIT license. "},"1.Core-Components/Stream.html":{"url":"1.Core-Components/Stream.html","title":"Stream","keywords":"","body":"Stream Event-driven readable and writable streams for non-blocking I/O in ReactPHP. In order to make the EventLoop easier to use, this component introduces the powerful concept of \"streams\". Streams allow you to efficiently process huge amounts of data (such as a multi Gigabyte file download) in small chunks without having to store everything in memory at once. They are very similar to the streams found in PHP itself, but have an interface more suited for async, non-blocking I/O. Table of contents Stream usage ReadableStreamInterface data event end event error event close event isReadable() pause() resume() pipe() close() WritableStreamInterface drain event pipe event error event close event isWritable() write() end() close() DuplexStreamInterface Creating streams ReadableResourceStream WritableResourceStream DuplexResourceStream ThroughStream CompositeStream Usage Install Tests License More Stream usage ReactPHP uses the concept of \"streams\" throughout its ecosystem to provide a consistent higher-level abstraction for processing streams of arbitrary data contents and size. While a stream itself is a quite low-level concept, it can be used as a powerful abstraction to build higher-level components and protocols on top. If you're new to this concept, it helps to think of them as a water pipe: You can consume water from a source or you can produce water and forward (pipe) it to any destination (sink). Similarly, streams can either be readable (such as STDIN terminal input) or writable (such as STDOUT terminal output) or duplex (both readable and writable, such as a TCP/IP connection) Accordingly, this package defines the following three interfaces ReadableStreamInterface WritableStreamInterface DuplexStreamInterface ReadableStreamInterface The ReadableStreamInterface is responsible for providing an interface for read-only streams and the readable side of duplex streams. Besides defining a few methods, this interface also implements the EventEmitterInterface which allows you to react to certain events. The event callback functions MUST be a valid callable that obeys strict parameter definitions and MUST accept event parameters exactly as documented. The event callback functions MUST NOT throw an Exception. The return value of the event callback functions will be ignored and has no effect, so for performance reasons you're recommended to not return any excessive data structures. Every implementation of this interface MUST follow these event semantics in order to be considered a well-behaving stream. Note that higher-level implementations of this interface may choose to define additional events with dedicated semantics not defined as part of this low-level stream specification. Conformance with these event semantics is out of scope for this interface, so you may also have to refer to the documentation of such a higher-level implementation. data event The data event will be emitted whenever some data was read/received from this source stream. The event receives a single mixed argument for incoming data. $stream->on('data', function ($data) { echo $data; }); This event MAY be emitted any number of times, which may be zero times if this stream does not send any data at all. It SHOULD not be emitted after an end or close event. The given $data argument may be of mixed type, but it's usually recommended it SHOULD be a string value or MAY use a type that allows representation as a string for maximum compatibility. Many common streams (such as a TCP/IP connection or a file-based stream) will emit the raw (binary) payload data that is received over the wire as chunks of string values. Due to the stream-based nature of this, the sender may send any number of chunks with varying sizes. There are no guarantees that these chunks will be received with the exact same framing the sender intended to send. In other words, many lower-level protocols (such as TCP/IP) transfer the data in chunks that may be anywhere between single-byte values to several dozens of kilobytes. You may want to apply a higher-level protocol to these low-level data chunks in order to achieve proper message framing. end event The end event will be emitted once the source stream has successfully reached the end of the stream (EOF). $stream->on('end', function () { echo 'END'; }); This event SHOULD be emitted once or never at all, depending on whether a successful end was detected. It SHOULD NOT be emitted after a previous end or close event. It MUST NOT be emitted if the stream closes due to a non-successful end, such as after a previous error event. After the stream is ended, it MUST switch to non-readable mode, see also isReadable(). This event will only be emitted if the end was reached successfully, not if the stream was interrupted by an unrecoverable error or explicitly closed. Not all streams know this concept of a \"successful end\". Many use-cases involve detecting when the stream closes (terminates) instead, in this case you should use the close event. After the stream emits an end event, it SHOULD usually be followed by a close event. Many common streams (such as a TCP/IP connection or a file-based stream) will emit this event if either the remote side closes the connection or a file handle was successfully read until reaching its end (EOF). Note that this event should not be confused with the end() method. This event defines a successful end reading from a source stream, while the end() method defines writing a successful end to a destination stream. error event The error event will be emitted once a fatal error occurs, usually while trying to read from this stream. The event receives a single Exception argument for the error instance. $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); This event SHOULD be emitted once the stream detects a fatal error, such as a fatal transmission error or after an unexpected data or premature end event. It SHOULD NOT be emitted after a previous error, end or close event. It MUST NOT be emitted if this is not a fatal error condition, such as a temporary network issue that did not cause any data to be lost. After the stream errors, it MUST close the stream and SHOULD thus be followed by a close event and then switch to non-readable mode, see also close() and isReadable(). Many common streams (such as a TCP/IP connection or a file-based stream) only deal with data transmission and do not make assumption about data boundaries (such as unexpected data or premature end events). In other words, many lower-level protocols (such as TCP/IP) may choose to only emit this for a fatal transmission error once and will then close (terminate) the stream in response. If this stream is a DuplexStreamInterface, you should also notice how the writable side of the stream also implements an error event. In other words, an error may occur while either reading or writing the stream which should result in the same error processing. close event The close event will be emitted once the stream closes (terminates). $stream->on('close', function () { echo 'CLOSED'; }); This event SHOULD be emitted once or never at all, depending on whether the stream ever terminates. It SHOULD NOT be emitted after a previous close event. After the stream is closed, it MUST switch to non-readable mode, see also isReadable(). Unlike the end event, this event SHOULD be emitted whenever the stream closes, irrespective of whether this happens implicitly due to an unrecoverable error or explicitly when either side closes the stream. If you only want to detect a successful end, you should use the end event instead. Many common streams (such as a TCP/IP connection or a file-based stream) will likely choose to emit this event after reading a successful end event or after a fatal transmission error event. If this stream is a DuplexStreamInterface, you should also notice how the writable side of the stream also implements a close event. In other words, after receiving this event, the stream MUST switch into non-writable AND non-readable mode, see also isWritable(). Note that this event should not be confused with the end event. isReadable() The isReadable(): bool method can be used to check whether this stream is in a readable state (not closed already). This method can be used to check if the stream still accepts incoming data events or if it is ended or closed already. Once the stream is non-readable, no further data or end events SHOULD be emitted. assert($stream->isReadable() === false); $stream->on('data', assertNeverCalled()); $stream->on('end', assertNeverCalled()); A successfully opened stream always MUST start in readable mode. Once the stream ends or closes, it MUST switch to non-readable mode. This can happen any time, explicitly through close() or implicitly due to a remote close or an unrecoverable transmission error. Once a stream has switched to non-readable mode, it MUST NOT transition back to readable mode. If this stream is a DuplexStreamInterface, you should also notice how the writable side of the stream also implements an isWritable() method. Unless this is a half-open duplex stream, they SHOULD usually have the same return value. pause() The pause(): void method can be used to pause reading incoming data events. Removes the data source file descriptor from the event loop. This allows you to throttle incoming data. Unless otherwise noted, a successfully opened stream SHOULD NOT start in paused state. Once the stream is paused, no futher data or end events SHOULD be emitted. $stream->pause(); $stream->on('data', assertShouldNeverCalled()); $stream->on('end', assertShouldNeverCalled()); This method is advisory-only, though generally not recommended, the stream MAY continue emitting data events. You can continue processing events by calling resume() again. Note that both methods can be called any number of times, in particular calling pause() more than once SHOULD NOT have any effect. See also resume(). resume() The resume(): void method can be used to resume reading incoming data events. Re-attach the data source after a previous pause(). $stream->pause(); $loop->addTimer(1.0, function () use ($stream) { $stream->resume(); }); Note that both methods can be called any number of times, in particular calling resume() without a prior pause() SHOULD NOT have any effect. See also pause(). pipe() The pipe(WritableStreamInterface $dest, array $options = []) method can be used to pipe all the data from this readable source into the given writable destination. Automatically sends all incoming data to the destination. Automatically throttles the source based on what the destination can handle. $source->pipe($dest); Similarly, you can also pipe an instance implementing DuplexStreamInterface into itself in order to write back all the data that is received. This may be a useful feature for a TCP/IP echo service: $connection->pipe($connection); This method returns the destination stream as-is, which can be used to set up chains of piped streams: $source->pipe($decodeGzip)->pipe($filterBadWords)->pipe($dest); By default, this will call end() on the destination stream once the source stream emits an end event. This can be disabled like this: $source->pipe($dest, array('end' => false)); Note that this only applies to the end event. If an error or explicit close event happens on the source stream, you'll have to manually close the destination stream: $source->pipe($dest); $source->on('close', function () use ($dest) { $dest->end('BYE!'); }); If the source stream is not readable (closed state), then this is a NO-OP. $source->close(); $source->pipe($dest); // NO-OP If the destinantion stream is not writable (closed state), then this will simply throttle (pause) the source stream: $dest->close(); $source->pipe($dest); // calls $source->pause() Similarly, if the destination stream is closed while the pipe is still active, it will also throttle (pause) the source stream: $source->pipe($dest); $dest->close(); // calls $source->pause() Once the pipe is set up successfully, the destination stream MUST emit a pipe event with this source stream an event argument. close() The close(): void method can be used to close the stream (forcefully). This method can be used to (forcefully) close the stream. $stream->close(); Once the stream is closed, it SHOULD emit a close event. Note that this event SHOULD NOT be emitted more than once, in particular if this method is called multiple times. After calling this method, the stream MUST switch into a non-readable mode, see also isReadable(). This means that no further data or end events SHOULD be emitted. $stream->close(); assert($stream->isReadable() === false); $stream->on('data', assertNeverCalled()); $stream->on('end', assertNeverCalled()); If this stream is a DuplexStreamInterface, you should also notice how the writable side of the stream also implements a close() method. In other words, after calling this method, the stream MUST switch into non-writable AND non-readable mode, see also isWritable(). Note that this method should not be confused with the end() method. WritableStreamInterface The WritableStreamInterface is responsible for providing an interface for write-only streams and the writable side of duplex streams. Besides defining a few methods, this interface also implements the EventEmitterInterface which allows you to react to certain events. The event callback functions MUST be a valid callable that obeys strict parameter definitions and MUST accept event parameters exactly as documented. The event callback functions MUST NOT throw an Exception. The return value of the event callback functions will be ignored and has no effect, so for performance reasons you're recommended to not return any excessive data structures. Every implementation of this interface MUST follow these event semantics in order to be considered a well-behaving stream. Note that higher-level implementations of this interface may choose to define additional events with dedicated semantics not defined as part of this low-level stream specification. Conformance with these event semantics is out of scope for this interface, so you may also have to refer to the documentation of such a higher-level implementation. drain event The drain event will be emitted whenever the write buffer became full previously and is now ready to accept more data. $stream->on('drain', function () use ($stream) { echo 'Stream is now ready to accept more data'; }); This event SHOULD be emitted once every time the buffer became full previously and is now ready to accept more data. In other words, this event MAY be emitted any number of times, which may be zero times if the buffer never became full in the first place. This event SHOULD NOT be emitted if the buffer has not become full previously. This event is mostly used internally, see also write() for more details. pipe event The pipe event will be emitted whenever a readable stream is pipe()d into this stream. The event receives a single ReadableStreamInterface argument for the source stream. $stream->on('pipe', function (ReadableStreamInterface $source) use ($stream) { echo 'Now receiving piped data'; // explicitly close target if source emits an error $source->on('error', function () use ($stream) { $stream->close(); }); }); $source->pipe($stream); This event MUST be emitted once for each readable stream that is successfully piped into this destination stream. In other words, this event MAY be emitted any number of times, which may be zero times if no stream is ever piped into this stream. This event MUST NOT be emitted if either the source is not readable (closed already) or this destination is not writable (closed already). This event is mostly used internally, see also pipe() for more details. error event The error event will be emitted once a fatal error occurs, usually while trying to write to this stream. The event receives a single Exception argument for the error instance. $stream->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); This event SHOULD be emitted once the stream detects a fatal error, such as a fatal transmission error. It SHOULD NOT be emitted after a previous error or close event. It MUST NOT be emitted if this is not a fatal error condition, such as a temporary network issue that did not cause any data to be lost. After the stream errors, it MUST close the stream and SHOULD thus be followed by a close event and then switch to non-writable mode, see also close() and isWritable(). Many common streams (such as a TCP/IP connection or a file-based stream) only deal with data transmission and may choose to only emit this for a fatal transmission error once and will then close (terminate) the stream in response. If this stream is a DuplexStreamInterface, you should also notice how the readable side of the stream also implements an error event. In other words, an error may occur while either reading or writing the stream which should result in the same error processing. close event The close event will be emitted once the stream closes (terminates). $stream->on('close', function () { echo 'CLOSED'; }); This event SHOULD be emitted once or never at all, depending on whether the stream ever terminates. It SHOULD NOT be emitted after a previous close event. After the stream is closed, it MUST switch to non-writable mode, see also isWritable(). This event SHOULD be emitted whenever the stream closes, irrespective of whether this happens implicitly due to an unrecoverable error or explicitly when either side closes the stream. Many common streams (such as a TCP/IP connection or a file-based stream) will likely choose to emit this event after flushing the buffer from the end() method, after receiving a successful end event or after a fatal transmission error event. If this stream is a DuplexStreamInterface, you should also notice how the readable side of the stream also implements a close event. In other words, after receiving this event, the stream MUST switch into non-writable AND non-readable mode, see also isReadable(). Note that this event should not be confused with the end event. isWritable() The isWritable(): bool method can be used to check whether this stream is in a writable state (not closed already). This method can be used to check if the stream still accepts writing any data or if it is ended or closed already. Writing any data to a non-writable stream is a NO-OP: assert($stream->isWritable() === false); $stream->write('end'); // NO-OP $stream->end('end'); // NO-OP A successfully opened stream always MUST start in writable mode. Once the stream ends or closes, it MUST switch to non-writable mode. This can happen any time, explicitly through end() or close() or implicitly due to a remote close or an unrecoverable transmission error. Once a stream has switched to non-writable mode, it MUST NOT transition back to writable mode. If this stream is a DuplexStreamInterface, you should also notice how the readable side of the stream also implements an isReadable() method. Unless this is a half-open duplex stream, they SHOULD usually have the same return value. write() The write(mixed $data): bool method can be used to write some data into the stream. A successful write MUST be confirmed with a boolean true, which means that either the data was written (flushed) immediately or is buffered and scheduled for a future write. Note that this interface gives you no control over explicitly flushing the buffered data, as finding the appropriate time for this is beyond the scope of this interface and left up to the implementation of this interface. Many common streams (such as a TCP/IP connection or file-based stream) may choose to buffer all given data and schedule a future flush by using an underlying EventLoop to check when the resource is actually writable. If a stream cannot handle writing (or flushing) the data, it SHOULD emit an error event and MAY close() the stream if it can not recover from this error. If the internal buffer is full after adding $data, then write() SHOULD return false, indicating that the caller should stop sending data until the buffer drains. The stream SHOULD send a drain event once the buffer is ready to accept more data. Similarly, if the the stream is not writable (already in a closed state) it MUST NOT process the given $data and SHOULD return false, indicating that the caller should stop sending data. The given $data argument MAY be of mixed type, but it's usually recommended it SHOULD be a string value or MAY use a type that allows representation as a string for maximum compatibility. Many common streams (such as a TCP/IP connection or a file-based stream) will only accept the raw (binary) payload data that is transferred over the wire as chunks of string values. Due to the stream-based nature of this, the sender may send any number of chunks with varying sizes. There are no guarantees that these chunks will be received with the exact same framing the sender intended to send. In other words, many lower-level protocols (such as TCP/IP) transfer the data in chunks that may be anywhere between single-byte values to several dozens of kilobytes. You may want to apply a higher-level protocol to these low-level data chunks in order to achieve proper message framing. end() The end(mixed $data = null): void method can be used to successfully end the stream (after optionally sending some final data). This method can be used to successfully end the stream, i.e. close the stream after sending out all data that is currently buffered. $stream->write('hello'); $stream->write('world'); $stream->end(); If there's no data currently buffered and nothing to be flushed, then this method MAY close() the stream immediately. If there's still data in the buffer that needs to be flushed first, then this method SHOULD try to write out this data and only then close() the stream. Once the stream is closed, it SHOULD emit a close event. Note that this interface gives you no control over explicitly flushing the buffered data, as finding the appropriate time for this is beyond the scope of this interface and left up to the implementation of this interface. Many common streams (such as a TCP/IP connection or file-based stream) may choose to buffer all given data and schedule a future flush by using an underlying EventLoop to check when the resource is actually writable. You can optionally pass some final data that is written to the stream before ending the stream. If a non-null value is given as $data, then this method will behave just like calling write($data) before ending with no data. // shorter version $stream->end('bye'); // same as longer version $stream->write('bye'); $stream->end(); After calling this method, the stream MUST switch into a non-writable mode, see also isWritable(). This means that no further writes are possible, so any additional write() or end() calls have no effect. $stream->end(); assert($stream->isWritable() === false); $stream->write('nope'); // NO-OP $stream->end(); // NO-OP If this stream is a DuplexStreamInterface, calling this method SHOULD also end its readable side, unless the stream supports half-open mode. In other words, after calling this method, these streams SHOULD switch into non-writable AND non-readable mode, see also isReadable(). This implies that in this case, the stream SHOULD NOT emit any data or end events anymore. Streams MAY choose to use the pause() method logic for this, but special care may have to be taken to ensure a following call to the resume() method SHOULD NOT continue emitting readable events. Note that this method should not be confused with the close() method. close() The close(): void method can be used to close the stream (forcefully). This method can be used to forcefully close the stream, i.e. close the stream without waiting for any buffered data to be flushed. If there's still data in the buffer, this data SHOULD be discarded. $stream->close(); Once the stream is closed, it SHOULD emit a close event. Note that this event SHOULD NOT be emitted more than once, in particular if this method is called multiple times. After calling this method, the stream MUST switch into a non-writable mode, see also isWritable(). This means that no further writes are possible, so any additional write() or end() calls have no effect. $stream->close(); assert($stream->isWritable() === false); $stream->write('nope'); // NO-OP $stream->end(); // NO-OP Note that this method should not be confused with the end() method. Unlike the end() method, this method does not take care of any existing buffers and simply discards any buffer contents. Likewise, this method may also be called after calling end() on a stream in order to stop waiting for the stream to flush its final data. $stream->end(); $loop->addTimer(1.0, function () use ($stream) { $stream->close(); }); If this stream is a DuplexStreamInterface, you should also notice how the readable side of the stream also implements a close() method. In other words, after calling this method, the stream MUST switch into non-writable AND non-readable mode, see also isReadable(). DuplexStreamInterface The DuplexStreamInterface is responsible for providing an interface for duplex streams (both readable and writable). It builds on top of the existing interfaces for readable and writable streams and follows the exact same method and event semantics. If you're new to this concept, you should look into the ReadableStreamInterface and WritableStreamInterface first. Besides defining a few methods, this interface also implements the EventEmitterInterface which allows you to react to the same events defined on the ReadbleStreamInterface and WritableStreamInterface. The event callback functions MUST be a valid callable that obeys strict parameter definitions and MUST accept event parameters exactly as documented. The event callback functions MUST NOT throw an Exception. The return value of the event callback functions will be ignored and has no effect, so for performance reasons you're recommended to not return any excessive data structures. Every implementation of this interface MUST follow these event semantics in order to be considered a well-behaving stream. Note that higher-level implementations of this interface may choose to define additional events with dedicated semantics not defined as part of this low-level stream specification. Conformance with these event semantics is out of scope for this interface, so you may also have to refer to the documentation of such a higher-level implementation. See also ReadableStreamInterface and WritableStreamInterface for more details. Creating streams ReactPHP uses the concept of \"streams\" throughout its ecosystem, so that many higher-level consumers of this package only deal with stream usage. This implies that stream instances are most often created within some higher-level components and many consumers never actually have to deal with creating a stream instance. Use react/socket if you want to accept incoming or establish outgoing plaintext TCP/IP or secure TLS socket connection streams. Use react/http if you want to receive an incoming HTTP request body streams. Use react/child-process if you want to communicate with child processes via process pipes such as STDIN, STDOUT, STDERR etc. Use experimental react/filesystem if you want to read from / write to the filesystem. See also the last chapter for more real-world applications. However, if you are writing a lower-level component or want to create a stream instance from a stream resource, then the following chapter is for you. Note that the following examples use fopen() and stream_socket_client() for illustration purposes only. These functions SHOULD NOT be used in a truly async program because each call may take several seconds to complete and would block the EventLoop otherwise. Additionally, the fopen() call will return a file handle on some platforms which may or may not be supported by all EventLoop implementations. As an alternative, you may want to use higher-level libraries listed above. ReadableResourceStream The ReadableResourceStream is a concrete implementation of the ReadableStreamInterface for PHP's stream resources. This can be used to represent a read-only resource like a file stream opened in readable mode or a stream such as STDIN: $stream = new ReadableResourceStream(STDIN, $loop); $stream->on('data', function ($chunk) { echo $chunk; }); $stream->on('end', function () { echo 'END'; }); See also ReadableStreamInterface for more details. The first parameter given to the constructor MUST be a valid stream resource that is opened in reading mode (e.g. fopen() mode r). Otherwise, it will throw an InvalidArgumentException: // throws InvalidArgumentException $stream = new ReadableResourceStream(false, $loop); See also the DuplexResourceStream for read-and-write stream resources otherwise. Internally, this class tries to enable non-blocking mode on the stream resource which may not be supported for all stream resources. Most notably, this is not supported by pipes on Windows (STDIN etc.). If this fails, it will throw a RuntimeException: // throws RuntimeException on Windows $stream = new ReadableResourceStream(STDIN, $loop); Once the constructor is called with a valid stream resource, this class will take care of the underlying stream resource. You SHOULD only use its public API and SHOULD NOT interfere with the underlying stream resource manually. This class takes an optional int|null $readChunkSize parameter that controls the maximum buffer size in bytes to read at once from the stream. You can use a null value here in order to apply its default value. This value SHOULD NOT be changed unless you know what you're doing. This can be a positive number which means that up to X bytes will be read at once from the underlying stream resource. Note that the actual number of bytes read may be lower if the stream resource has less than X bytes currently available. This can be -1 which means \"read everything available\" from the underlying stream resource. This should read until the stream resource is not readable anymore (i.e. underlying buffer drained), note that this does not neccessarily mean it reached EOF. $stream = new ReadableResourceStream(STDIN, $loop, 8192); PHP bug warning: If the PHP process has explicitly been started without a STDIN stream, then trying to read from STDIN may return data from another stream resource. This does not happen if you start this with an empty stream like php test.php instead of php test.php . See #81 for more details. WritableResourceStream The WritableResourceStream is a concrete implementation of the WritableStreamInterface for PHP's stream resources. This can be used to represent a write-only resource like a file stream opened in writable mode or a stream such as STDOUT or STDERR: $stream = new WritableResourceStream(STDOUT, $loop); $stream->write('hello!'); $stream->end(); See also WritableStreamInterface for more details. The first parameter given to the constructor MUST be a valid stream resource that is opened for writing. Otherwise, it will throw an InvalidArgumentException: // throws InvalidArgumentException $stream = new WritableResourceStream(false, $loop); See also the DuplexResourceStream for read-and-write stream resources otherwise. Internally, this class tries to enable non-blocking mode on the stream resource which may not be supported for all stream resources. Most notably, this is not supported by pipes on Windows (STDOUT, STDERR etc.). If this fails, it will throw a RuntimeException: // throws RuntimeException on Windows $stream = new WritableResourceStream(STDOUT, $loop); Once the constructor is called with a valid stream resource, this class will take care of the underlying stream resource. You SHOULD only use its public API and SHOULD NOT interfere with the underlying stream resource manually. Any write() calls to this class will not be performed instantly, but will be performed asynchronously, once the EventLoop reports the stream resource is ready to accept data. For this, it uses an in-memory buffer string to collect all outstanding writes. This buffer has a soft-limit applied which defines how much data it is willing to accept before the caller SHOULD stop sending further data. This class takes an optional int|null $writeBufferSoftLimit parameter that controls this maximum buffer size in bytes. You can use a null value here in order to apply its default value. This value SHOULD NOT be changed unless you know what you're doing. $stream = new WritableResourceStream(STDOUT, $loop, 8192); This class takes an optional int|null $writeChunkSize parameter that controls this maximum buffer size in bytes to write at once to the stream. You can use a null value here in order to apply its default value. This value SHOULD NOT be changed unless you know what you're doing. This can be a positive number which means that up to X bytes will be written at once to the underlying stream resource. Note that the actual number of bytes written may be lower if the stream resource has less than X bytes currently available. This can be -1 which means \"write everything available\" to the underlying stream resource. $stream = new WritableResourceStream(STDOUT, $loop, null, 8192); See also write() for more details. DuplexResourceStream The DuplexResourceStream is a concrete implementation of the DuplexStreamInterface for PHP's stream resources. This can be used to represent a read-and-write resource like a file stream opened in read and write mode mode or a stream such as a TCP/IP connection: $conn = stream_socket_client('tcp://google.com:80'); $stream = new DuplexResourceStream($conn, $loop); $stream->write('hello!'); $stream->end(); See also DuplexStreamInterface for more details. The first parameter given to the constructor MUST be a valid stream resource that is opened for reading and writing. Otherwise, it will throw an InvalidArgumentException: // throws InvalidArgumentException $stream = new DuplexResourceStream(false, $loop); See also the ReadableResourceStream for read-only and the WritableResourceStream for write-only stream resources otherwise. Internally, this class tries to enable non-blocking mode on the stream resource which may not be supported for all stream resources. Most notably, this is not supported by pipes on Windows (STDOUT, STDERR etc.). If this fails, it will throw a RuntimeException: // throws RuntimeException on Windows $stream = new DuplexResourceStream(STDOUT, $loop); Once the constructor is called with a valid stream resource, this class will take care of the underlying stream resource. You SHOULD only use its public API and SHOULD NOT interfere with the underlying stream resource manually. This class takes an optional int|null $readChunkSize parameter that controls the maximum buffer size in bytes to read at once from the stream. You can use a null value here in order to apply its default value. This value SHOULD NOT be changed unless you know what you're doing. This can be a positive number which means that up to X bytes will be read at once from the underlying stream resource. Note that the actual number of bytes read may be lower if the stream resource has less than X bytes currently available. This can be -1 which means \"read everything available\" from the underlying stream resource. This should read until the stream resource is not readable anymore (i.e. underlying buffer drained), note that this does not neccessarily mean it reached EOF. $conn = stream_socket_client('tcp://google.com:80'); $stream = new DuplexResourceStream($conn, $loop, 8192); Any write() calls to this class will not be performed instantly, but will be performed asynchronously, once the EventLoop reports the stream resource is ready to accept data. For this, it uses an in-memory buffer string to collect all outstanding writes. This buffer has a soft-limit applied which defines how much data it is willing to accept before the caller SHOULD stop sending further data. This class takes another optional WritableStreamInterface|null $buffer parameter that controls this write behavior of this stream. You can use a null value here in order to apply its default value. This value SHOULD NOT be changed unless you know what you're doing. If you want to change the write buffer soft limit, you can pass an instance of WritableResourceStream like this: $conn = stream_socket_client('tcp://google.com:80'); $buffer = new WritableResourceStream($conn, $loop, 8192); $stream = new DuplexResourceStream($conn, $loop, null, $buffer); See also WritableResourceStream for more details. ThroughStream The ThroughStream implements the DuplexStreamInterface and will simply pass any data you write to it through to its readable end. $through = new ThroughStream(); $through->on('data', $this->expectCallableOnceWith('hello')); $through->write('hello'); Similarly, the end() method will end the stream and emit an end event and then close() the stream. The close() method will close the stream and emit a close event. Accordingly, this is can also be used in a pipe() context like this: $through = new ThroughStream(); $source->pipe($through)->pipe($dest); Optionally, its constructor accepts any callable function which will then be used to filter any data written to it. This function receives a single data argument as passed to the writable side and must return the data as it will be passed to its readable end: $through = new ThroughStream('strtoupper'); $source->pipe($through)->pipe($dest); Note that this class makes no assumptions about any data types. This can be used to convert data, for example for transforming any structured data into a newline-delimited JSON (NDJSON) stream like this: $through = new ThroughStream(function ($data) { return json_encode($data) . PHP_EOL; }); $through->on('data', $this->expectCallableOnceWith(\"[2, true]\\n\")); $through->write(array(2, true)); The callback function is allowed to throw an Exception. In this case, the stream will emit an error event and then close() the stream. $through = new ThroughStream(function ($data) { if (!is_string($data)) { throw new \\UnexpectedValueException('Only strings allowed'); } return $data; }); $through->on('error', $this->expectCallableOnce())); $through->on('close', $this->expectCallableOnce())); $through->on('data', $this->expectCallableNever())); $through->write(2); CompositeStream The CompositeStream implements the DuplexStreamInterface and can be used to create a single duplex stream from two individual streams implementing ReadableStreamInterface and WritableStreamInterface respectively. This is useful for some APIs which may require a single DuplexStreamInterface or simply because it's often more convenient to work with a single stream instance like this: $stdin = new ReadableResourceStream(STDIN, $loop); $stdout = new WritableResourceStream(STDOUT, $loop); $stdio = new CompositeStream($stdin, $stdout); $stdio->on('data', function ($chunk) use ($stdio) { $stdio->write('You said: ' . $chunk); }); This is a well-behaving stream which forwards all stream events from the underlying streams and forwards all streams calls to the underlying streams. If you write() to the duplex stream, it will simply write() to the writable side and return its status. If you end() the duplex stream, it will end() the writable side and will pause() the readable side. If you close() the duplex stream, both input streams will be closed. If either of the two input streams emits a close event, the duplex stream will also close. If either of the two input streams is already closed while constructing the duplex stream, it will close() the other side and return a closed stream. Usage The following example can be used to pipe the contents of a source file into a destination file without having to ever read the whole file into memory: $loop = new React\\EventLoop\\StreamSelectLoop; $source = new React\\Stream\\ReadableResourceStream(fopen('source.txt', 'r'), $loop); $dest = new React\\Stream\\WritableResourceStream(fopen('destination.txt', 'w'), $loop); $source->pipe($dest); $loop->run(); Note that this example uses fopen() for illustration purposes only. This should not be used in a truly async program because the filesystem is inherently blocking and each call could potentially take several seconds. See also creating streams for more sophisticated examples. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/stream:^1.1.1 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project due to its vast performance improvements. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. More See creating streams for more information on how streams are created in real-world applications. See our users wiki and the dependents on Packagist for a list of packages that use streams in real-world applications. "},"2.Network-Components/Datagram.html":{"url":"2.Network-Components/Datagram.html","title":"Datagram","keywords":"","body":"Datagram Event-driven UDP datagram socket client and server for ReactPHP. Quickstart example Once installed, you can use the following code to connect to an UDP server listening on localhost:1234 and send and receive UDP datagrams: $loop = React\\EventLoop\\Factory::create(); $factory = new React\\Datagram\\Factory($loop); $factory->createClient('localhost:1234')->then(function (React\\Datagram\\Socket $client) { $client->send('first'); $client->on('message', function($message, $serverAddress, $client) { echo 'received \"' . $message . '\" from ' . $serverAddress. PHP_EOL; }); }); $loop->run(); See also the examples. Usage This library's API is modelled after node.js's API for UDP / Datagram Sockets (dgram.Socket). Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/datagram:^1.5 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"2.Network-Components/Socket.html":{"url":"2.Network-Components/Socket.html","title":"Socket","keywords":"","body":"Socket Async, streaming plaintext TCP/IP and secure TLS socket server and client connections for ReactPHP. The socket library provides re-usable interfaces for a socket-layer server and client based on the EventLoop and Stream components. Its server component allows you to build networking servers that accept incoming connections from networking clients (such as an HTTP server). Its client component allows you to build networking clients that establish outgoing connections to networking servers (such as an HTTP or database client). This library provides async, streaming means for all of this, so you can handle multiple concurrent connections without blocking. Table of Contents Quickstart example Connection usage ConnectionInterface getRemoteAddress() getLocalAddress() Server usage ServerInterface connection event error event getAddress() pause() resume() close() Server Advanced server usage TcpServer SecureServer UnixServer LimitingServer getConnections() Client usage ConnectorInterface connect() Connector Advanced client usage TcpConnector HappyEyeBallsConnector DnsConnector SecureConnector TimeoutConnector UnixConnector FixUriConnector Install Tests License Quickstart example Here is a server that closes the connection if you send it anything: $loop = React\\EventLoop\\Factory::create(); $socket = new React\\Socket\\Server('127.0.0.1:8080', $loop); $socket->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"Hello \" . $connection->getRemoteAddress() . \"!\\n\"); $connection->write(\"Welcome to this amazing server!\\n\"); $connection->write(\"Here's a tip: don't say anything.\\n\"); $connection->on('data', function ($data) use ($connection) { $connection->close(); }); }); $loop->run(); See also the examples. Here's a client that outputs the output of said server and then attempts to send it a string: $loop = React\\EventLoop\\Factory::create(); $connector = new React\\Socket\\Connector($loop); $connector->connect('127.0.0.1:8080')->then(function (React\\Socket\\ConnectionInterface $connection) use ($loop) { $connection->pipe(new React\\Stream\\WritableResourceStream(STDOUT, $loop)); $connection->write(\"Hello World!\\n\"); }); $loop->run(); Connection usage ConnectionInterface The ConnectionInterface is used to represent any incoming and outgoing connection, such as a normal TCP/IP connection. An incoming or outgoing connection is a duplex stream (both readable and writable) that implements React's DuplexStreamInterface. It contains additional properties for the local and remote address (client IP) where this connection has been established to/from. Most commonly, instances implementing this ConnectionInterface are emitted by all classes implementing the ServerInterface and used by all classes implementing the ConnectorInterface. Because the ConnectionInterface implements the underlying DuplexStreamInterface you can use any of its events and methods as usual: $connection->on('data', function ($chunk) { echo $chunk; }); $connection->on('end', function () { echo 'ended'; }); $connection->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage(); }); $connection->on('close', function () { echo 'closed'; }); $connection->write($data); $connection->end($data = null); $connection->close(); // … For more details, see the DuplexStreamInterface. getRemoteAddress() The getRemoteAddress(): ?string method returns the full remote address (URI) where this connection has been established with. $address = $connection->getRemoteAddress(); echo 'Connection with ' . $address . PHP_EOL; If the remote address can not be determined or is unknown at this time (such as after the connection has been closed), it MAY return a NULL value instead. Otherwise, it will return the full address (URI) as a string value, such as tcp://127.0.0.1:8080, tcp://[::1]:80, tls://127.0.0.1:443, unix://example.sock or unix:///path/to/example.sock. Note that individual URI components are application specific and depend on the underlying transport protocol. If this is a TCP/IP based connection and you only want the remote IP, you may use something like this: $address = $connection->getRemoteAddress(); $ip = trim(parse_url($address, PHP_URL_HOST), '[]'); echo 'Connection with ' . $ip . PHP_EOL; getLocalAddress() The getLocalAddress(): ?string method returns the full local address (URI) where this connection has been established with. $address = $connection->getLocalAddress(); echo 'Connection with ' . $address . PHP_EOL; If the local address can not be determined or is unknown at this time (such as after the connection has been closed), it MAY return a NULL value instead. Otherwise, it will return the full address (URI) as a string value, such as tcp://127.0.0.1:8080, tcp://[::1]:80, tls://127.0.0.1:443, unix://example.sock or unix:///path/to/example.sock. Note that individual URI components are application specific and depend on the underlying transport protocol. This method complements the getRemoteAddress() method, so they should not be confused. If your TcpServer instance is listening on multiple interfaces (e.g. using the address 0.0.0.0), you can use this method to find out which interface actually accepted this connection (such as a public or local interface). If your system has multiple interfaces (e.g. a WAN and a LAN interface), you can use this method to find out which interface was actually used for this connection. Server usage ServerInterface The ServerInterface is responsible for providing an interface for accepting incoming streaming connections, such as a normal TCP/IP connection. Most higher-level components (such as a HTTP server) accept an instance implementing this interface to accept incoming streaming connections. This is usually done via dependency injection, so it's fairly simple to actually swap this implementation against any other implementation of this interface. This means that you SHOULD typehint against this interface instead of a concrete implementation of this interface. Besides defining a few methods, this interface also implements the EventEmitterInterface which allows you to react to certain events. connection event The connection event will be emitted whenever a new connection has been established, i.e. a new client connects to this server socket: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'new connection' . PHP_EOL; }); See also the ConnectionInterface for more details about handling the incoming connection. error event The error event will be emitted whenever there's an error accepting a new connection from a client. $server->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage() . PHP_EOL; }); Note that this is not a fatal error event, i.e. the server keeps listening for new connections even after this event. getAddress() The getAddress(): ?string method can be used to return the full address (URI) this server is currently listening on. $address = $server->getAddress(); echo 'Server listening on ' . $address . PHP_EOL; If the address can not be determined or is unknown at this time (such as after the socket has been closed), it MAY return a NULL value instead. Otherwise, it will return the full address (URI) as a string value, such as tcp://127.0.0.1:8080, tcp://[::1]:80, tls://127.0.0.1:443 unix://example.sock or unix:///path/to/example.sock. Note that individual URI components are application specific and depend on the underlying transport protocol. If this is a TCP/IP based server and you only want the local port, you may use something like this: $address = $server->getAddress(); $port = parse_url($address, PHP_URL_PORT); echo 'Server listening on port ' . $port . PHP_EOL; pause() The pause(): void method can be used to pause accepting new incoming connections. Removes the socket resource from the EventLoop and thus stop accepting new connections. Note that the listening socket stays active and is not closed. This means that new incoming connections will stay pending in the operating system backlog until its configurable backlog is filled. Once the backlog is filled, the operating system may reject further incoming connections until the backlog is drained again by resuming to accept new connections. Once the server is paused, no futher connection events SHOULD be emitted. $server->pause(); $server->on('connection', assertShouldNeverCalled()); This method is advisory-only, though generally not recommended, the server MAY continue emitting connection events. Unless otherwise noted, a successfully opened server SHOULD NOT start in paused state. You can continue processing events by calling resume() again. Note that both methods can be called any number of times, in particular calling pause() more than once SHOULD NOT have any effect. Similarly, calling this after close() is a NO-OP. resume() The resume(): void method can be used to resume accepting new incoming connections. Re-attach the socket resource to the EventLoop after a previous pause(). $server->pause(); $loop->addTimer(1.0, function () use ($server) { $server->resume(); }); Note that both methods can be called any number of times, in particular calling resume() without a prior pause() SHOULD NOT have any effect. Similarly, calling this after close() is a NO-OP. close() The close(): void method can be used to shut down this listening socket. This will stop listening for new incoming connections on this socket. echo 'Shutting down server socket' . PHP_EOL; $server->close(); Calling this method more than once on the same instance is a NO-OP. Server The Server class is the main class in this package that implements the ServerInterface and allows you to accept incoming streaming connections, such as plaintext TCP/IP or secure TLS connection streams. Connections can also be accepted on Unix domain sockets. $server = new React\\Socket\\Server(8080, $loop); As above, the $uri parameter can consist of only a port, in which case the server will default to listening on the localhost address 127.0.0.1, which means it will not be reachable from outside of this system. In order to use a random port assignment, you can use the port 0: $server = new React\\Socket\\Server(0, $loop); $address = $server->getAddress(); In order to change the host the socket is listening on, you can provide an IP address through the first parameter provided to the constructor, optionally preceded by the tcp:// scheme: $server = new React\\Socket\\Server('192.168.0.1:8080', $loop); If you want to listen on an IPv6 address, you MUST enclose the host in square brackets: $server = new React\\Socket\\Server('[::1]:8080', $loop); To listen on a Unix domain socket (UDS) path, you MUST prefix the URI with the unix:// scheme: $server = new React\\Socket\\Server('unix:///tmp/server.sock', $loop); If the given URI is invalid, does not contain a port, any other scheme or if it contains a hostname, it will throw an InvalidArgumentException: // throws InvalidArgumentException due to missing port $server = new React\\Socket\\Server('127.0.0.1', $loop); If the given URI appears to be valid, but listening on it fails (such as if port is already in use or port below 1024 may require root access etc.), it will throw a RuntimeException: $first = new React\\Socket\\Server(8080, $loop); // throws RuntimeException because port is already in use $second = new React\\Socket\\Server(8080, $loop); Note that these error conditions may vary depending on your system and/or configuration. See the exception message and code for more details about the actual error condition. Optionally, you can specify TCP socket context options for the underlying stream socket resource like this: $server = new React\\Socket\\Server('[::1]:8080', $loop, array( 'tcp' => array( 'backlog' => 200, 'so_reuseport' => true, 'ipv6_v6only' => true ) )); Note that available socket context options, their defaults and effects of changing these may vary depending on your system and/or PHP version. Passing unknown context options has no effect. The backlog context option defaults to 511 unless given explicitly. For BC reasons, you can also pass the TCP socket context options as a simple array without wrapping this in another array under the tcp key. You can start a secure TLS (formerly known as SSL) server by simply prepending the tls:// URI scheme. Internally, it will wait for plaintext TCP/IP connections and then performs a TLS handshake for each connection. It thus requires valid TLS context options, which in its most basic form may look something like this if you're using a PEM encoded certificate file: $server = new React\\Socket\\Server('tls://127.0.0.1:8080', $loop, array( 'tls' => array( 'local_cert' => 'server.pem' ) )); Note that the certificate file will not be loaded on instantiation but when an incoming connection initializes its TLS context. This implies that any invalid certificate file paths or contents will only cause an error event at a later time. If your private key is encrypted with a passphrase, you have to specify it like this: $server = new React\\Socket\\Server('tls://127.0.0.1:8000', $loop, array( 'tls' => array( 'local_cert' => 'server.pem', 'passphrase' => 'secret' ) )); By default, this server supports TLSv1.0+ and excludes support for legacy SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you want to negotiate with the remote side: $server = new React\\Socket\\Server('tls://127.0.0.1:8000', $loop, array( 'tls' => array( 'local_cert' => 'server.pem', 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_SERVER ) )); Note that available TLS context options, their defaults and effects of changing these may vary depending on your system and/or PHP version. The outer context array allows you to also use tcp (and possibly more) context options at the same time. Passing unknown context options has no effect. If you do not use the tls:// scheme, then passing tls context options has no effect. Whenever a client connects, it will emit a connection event with a connection instance implementing ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Plaintext connection from ' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); See also the ServerInterface for more details. Note that the Server class is a concrete implementation for TCP/IP sockets. If you want to typehint in your higher-level protocol implementation, you SHOULD use the generic ServerInterface instead. Advanced server usage TcpServer The TcpServer class implements the ServerInterface and is responsible for accepting plaintext TCP/IP connections. $server = new React\\Socket\\TcpServer(8080, $loop); As above, the $uri parameter can consist of only a port, in which case the server will default to listening on the localhost address 127.0.0.1, which means it will not be reachable from outside of this system. In order to use a random port assignment, you can use the port 0: $server = new React\\Socket\\TcpServer(0, $loop); $address = $server->getAddress(); In order to change the host the socket is listening on, you can provide an IP address through the first parameter provided to the constructor, optionally preceded by the tcp:// scheme: $server = new React\\Socket\\TcpServer('192.168.0.1:8080', $loop); If you want to listen on an IPv6 address, you MUST enclose the host in square brackets: $server = new React\\Socket\\TcpServer('[::1]:8080', $loop); If the given URI is invalid, does not contain a port, any other scheme or if it contains a hostname, it will throw an InvalidArgumentException: // throws InvalidArgumentException due to missing port $server = new React\\Socket\\TcpServer('127.0.0.1', $loop); If the given URI appears to be valid, but listening on it fails (such as if port is already in use or port below 1024 may require root access etc.), it will throw a RuntimeException: $first = new React\\Socket\\TcpServer(8080, $loop); // throws RuntimeException because port is already in use $second = new React\\Socket\\TcpServer(8080, $loop); Note that these error conditions may vary depending on your system and/or configuration. See the exception message and code for more details about the actual error condition. Optionally, you can specify socket context options for the underlying stream socket resource like this: $server = new React\\Socket\\TcpServer('[::1]:8080', $loop, array( 'backlog' => 200, 'so_reuseport' => true, 'ipv6_v6only' => true )); Note that available socket context options, their defaults and effects of changing these may vary depending on your system and/or PHP version. Passing unknown context options has no effect. The backlog context option defaults to 511 unless given explicitly. Whenever a client connects, it will emit a connection event with a connection instance implementing ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Plaintext connection from ' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); See also the ServerInterface for more details. SecureServer The SecureServer class implements the ServerInterface and is responsible for providing a secure TLS (formerly known as SSL) server. It does so by wrapping a TcpServer instance which waits for plaintext TCP/IP connections and then performs a TLS handshake for each connection. It thus requires valid TLS context options, which in its most basic form may look something like this if you're using a PEM encoded certificate file: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem' )); Note that the certificate file will not be loaded on instantiation but when an incoming connection initializes its TLS context. This implies that any invalid certificate file paths or contents will only cause an error event at a later time. If your private key is encrypted with a passphrase, you have to specify it like this: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem', 'passphrase' => 'secret' )); By default, this server supports TLSv1.0+ and excludes support for legacy SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you want to negotiate with the remote side: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem', 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_SERVER )); Note that available TLS context options, their defaults and effects of changing these may vary depending on your system and/or PHP version. Passing unknown context options has no effect. Whenever a client completes the TLS handshake, it will emit a connection event with a connection instance implementing ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Secure connection from' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); Whenever a client fails to perform a successful TLS handshake, it will emit an error event and then close the underlying TCP/IP connection: $server->on('error', function (Exception $e) { echo 'Error' . $e->getMessage() . PHP_EOL; }); See also the ServerInterface for more details. Note that the SecureServer class is a concrete implementation for TLS sockets. If you want to typehint in your higher-level protocol implementation, you SHOULD use the generic ServerInterface instead. Advanced usage: Despite allowing any ServerInterface as first parameter, you SHOULD pass a TcpServer instance as first parameter, unless you know what you're doing. Internally, the SecureServer has to set the required TLS context options on the underlying stream resources. These resources are not exposed through any of the interfaces defined in this package, but only through the internal Connection class. The TcpServer class is guaranteed to emit connections that implement the ConnectionInterface and uses the internal Connection class in order to expose these underlying resources. If you use a custom ServerInterface and its connection event does not meet this requirement, the SecureServer will emit an error event and then close the underlying connection. UnixServer The UnixServer class implements the ServerInterface and is responsible for accepting connections on Unix domain sockets (UDS). $server = new React\\Socket\\UnixServer('/tmp/server.sock', $loop); As above, the $uri parameter can consist of only a socket path or socket path prefixed by the unix:// scheme. If the given URI appears to be valid, but listening on it fails (such as if the socket is already in use or the file not accessible etc.), it will throw a RuntimeException: $first = new React\\Socket\\UnixServer('/tmp/same.sock', $loop); // throws RuntimeException because socket is already in use $second = new React\\Socket\\UnixServer('/tmp/same.sock', $loop); Note that these error conditions may vary depending on your system and/or configuration. In particular, Zend PHP does only report \"Unknown error\" when the UDS path already exists and can not be bound. You may want to check is_file() on the given UDS path to report a more user-friendly error message in this case. See the exception message and code for more details about the actual error condition. Whenever a client connects, it will emit a connection event with a connection instance implementing ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'New connection' . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); See also the ServerInterface for more details. LimitingServer The LimitingServer decorator wraps a given ServerInterface and is responsible for limiting and keeping track of open connections to this server instance. Whenever the underlying server emits a connection event, it will check its limits and then either keep track of this connection by adding it to the list of open connections and then forward the connection event or reject (close) the connection when its limits are exceeded and will forward an error event instead. Whenever a connection closes, it will remove this connection from the list of open connections. $server = new React\\Socket\\LimitingServer($server, 100); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); See also the second example for more details. You have to pass a maximum number of open connections to ensure the server will automatically reject (close) connections once this limit is exceeded. In this case, it will emit an error event to inform about this and no connection event will be emitted. $server = new React\\Socket\\LimitingServer($server, 100); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); You MAY pass a null limit in order to put no limit on the number of open connections and keep accepting new connection until you run out of operating system resources (such as open file handles). This may be useful if you do not want to take care of applying a limit but still want to use the getConnections() method. You can optionally configure the server to pause accepting new connections once the connection limit is reached. In this case, it will pause the underlying server and no longer process any new connections at all, thus also no longer closing any excessive connections. The underlying operating system is responsible for keeping a backlog of pending connections until its limit is reached, at which point it will start rejecting further connections. Once the server is below the connection limit, it will continue consuming connections from the backlog and will process any outstanding data on each connection. This mode may be useful for some protocols that are designed to wait for a response message (such as HTTP), but may be less useful for other protocols that demand immediate responses (such as a \"welcome\" message in an interactive chat). $server = new React\\Socket\\LimitingServer($server, 100, true); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); getConnections() The getConnections(): ConnectionInterface[] method can be used to return an array with all currently active connections. foreach ($server->getConnection() as $connection) { $connection->write('Hi!'); } Client usage ConnectorInterface The ConnectorInterface is responsible for providing an interface for establishing streaming connections, such as a normal TCP/IP connection. This is the main interface defined in this package and it is used throughout React's vast ecosystem. Most higher-level components (such as HTTP, database or other networking service clients) accept an instance implementing this interface to create their TCP/IP connection to the underlying networking service. This is usually done via dependency injection, so it's fairly simple to actually swap this implementation against any other implementation of this interface. The interface only offers a single method: connect() The connect(string $uri): PromiseInterface method can be used to create a streaming connection to the given remote address. It returns a Promise which either fulfills with a stream implementing ConnectionInterface on success or rejects with an Exception if the connection is not successful: $connector->connect('google.com:443')->then( function (React\\Socket\\ConnectionInterface $connection) { // connection successfully established }, function (Exception $error) { // failed to connect due to $error } ); See also ConnectionInterface for more details. The returned Promise MUST be implemented in such a way that it can be cancelled when it is still pending. Cancelling a pending promise MUST reject its value with an Exception. It SHOULD clean up any underlying resources and references as applicable: $promise = $connector->connect($uri); $promise->cancel(); Connector The Connector class is the main class in this package that implements the ConnectorInterface and allows you to create streaming connections. You can use this connector to create any kind of streaming connections, such as plaintext TCP/IP, secure TLS or local Unix connection streams. It binds to the main event loop and can be used like this: $loop = React\\EventLoop\\Factory::create(); $connector = new React\\Socket\\Connector($loop); $connector->connect($uri)->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); In order to create a plaintext TCP/IP connection, you can simply pass a host and port combination like this: $connector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); If you do no specify a URI scheme in the destination URI, it will assume tcp:// as a default and establish a plaintext TCP/IP connection. Note that TCP/IP connections require a host and port part in the destination URI like above, all other URI components are optional. In order to create a secure TLS connection, you can use the tls:// URI scheme like this: $connector->connect('tls://www.google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); In order to create a local Unix domain socket connection, you can use the unix:// URI scheme like this: $connector->connect('unix:///tmp/demo.sock')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); The getRemoteAddress() method will return the target Unix domain socket (UDS) path as given to the connect() method, including the unix:// scheme, for example unix:///tmp/demo.sock. The getLocalAddress() method will most likely return a null value as this value is not applicable to UDS connections here. Under the hood, the Connector is implemented as a higher-level facade for the lower-level connectors implemented in this package. This means it also shares all of their features and implementation details. If you want to typehint in your higher-level protocol implementation, you SHOULD use the generic ConnectorInterface instead. As of v1.4.0, the Connector class defaults to using the happy eyeballs algorithm to automatically connect over IPv4 or IPv6 when a hostname is given. This automatically attempts to connect using both IPv4 and IPv6 at the same time (preferring IPv6), thus avoiding the usual problems faced by users with imperfect IPv6 connections or setups. If you want to revert to the old behavior of only doing an IPv4 lookup and only attempt a single IPv4 connection, you can set up the Connector like this: $connector = new React\\Socket\\Connector($loop, array( 'happy_eyeballs' => false )); Similarly, you can also affect the default DNS behavior as follows. The Connector class will try to detect your system DNS settings (and uses Google's public DNS server 8.8.8.8 as a fallback if unable to determine your system settings) to resolve all public hostnames into underlying IP addresses by default. If you explicitly want to use a custom DNS server (such as a local DNS relay or a company wide DNS server), you can set up the Connector like this: $connector = new React\\Socket\\Connector($loop, array( 'dns' => '127.0.1.1' )); $connector->connect('localhost:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); If you do not want to use a DNS resolver at all and want to connect to IP addresses only, you can also set up your Connector like this: $connector = new React\\Socket\\Connector($loop, array( 'dns' => false )); $connector->connect('127.0.0.1:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); Advanced: If you need a custom DNS React\\Dns\\Resolver\\ResolverInterface instance, you can also set up your Connector like this: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $resolver = $dnsResolverFactory->createCached('127.0.1.1', $loop); $connector = new React\\Socket\\Connector($loop, array( 'dns' => $resolver )); $connector->connect('localhost:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); By default, the tcp:// and tls:// URI schemes will use timeout value that respects your default_socket_timeout ini setting (which defaults to 60s). If you want a custom timeout value, you can simply pass this like this: $connector = new React\\Socket\\Connector($loop, array( 'timeout' => 10.0 )); Similarly, if you do not want to apply a timeout at all and let the operating system handle this, you can pass a boolean flag like this: $connector = new React\\Socket\\Connector($loop, array( 'timeout' => false )); By default, the Connector supports the tcp://, tls:// and unix:// URI schemes. If you want to explicitly prohibit any of these, you can simply pass boolean flags like this: // only allow secure TLS connections $connector = new React\\Socket\\Connector($loop, array( 'tcp' => false, 'tls' => true, 'unix' => false, )); $connector->connect('tls://google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); The tcp:// and tls:// also accept additional context options passed to the underlying connectors. If you want to explicitly pass additional context options, you can simply pass arrays of context options like this: // allow insecure TLS connections $connector = new React\\Socket\\Connector($loop, array( 'tcp' => array( 'bindto' => '192.168.0.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ), )); $connector->connect('tls://localhost:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); By default, this connector supports TLSv1.0+ and excludes support for legacy SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you want to negotiate with the remote side: $connector = new React\\Socket\\Connector($loop, array( 'tls' => array( 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT ) )); For more details about context options, please refer to the PHP documentation about socket context options and SSL context options. Advanced: By default, the Connector supports the tcp://, tls:// and unix:// URI schemes. For this, it sets up the required connector classes automatically. If you want to explicitly pass custom connectors for any of these, you can simply pass an instance implementing the ConnectorInterface like this: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $resolver = $dnsResolverFactory->createCached('127.0.1.1', $loop); $tcp = new React\\Socket\\HappyEyeBallsConnector($loop, new React\\Socket\\TcpConnector($loop), $resolver); $tls = new React\\Socket\\SecureConnector($tcp, $loop); $unix = new React\\Socket\\UnixConnector($loop); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $tcp, 'tls' => $tls, 'unix' => $unix, 'dns' => false, 'timeout' => false, )); $connector->connect('google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); Internally, the tcp:// connector will always be wrapped by the DNS resolver, unless you disable DNS like in the above example. In this case, the tcp:// connector receives the actual hostname instead of only the resolved IP address and is thus responsible for performing the lookup. Internally, the automatically created tls:// connector will always wrap the underlying tcp:// connector for establishing the underlying plaintext TCP/IP connection before enabling secure TLS mode. If you want to use a custom underlying tcp:// connector for secure TLS connections only, you may explicitly pass a tls:// connector like above instead. Internally, the tcp:// and tls:// connectors will always be wrapped by TimeoutConnector, unless you disable timeouts like in the above example. Advanced client usage TcpConnector The TcpConnector class implements the ConnectorInterface and allows you to create plaintext TCP/IP connections to any IP-port-combination: $tcpConnector = new React\\Socket\\TcpConnector($loop); $tcpConnector->connect('127.0.0.1:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); See also the examples. Pending connection attempts can be cancelled by cancelling its pending promise like so: $promise = $tcpConnector->connect('127.0.0.1:80'); $promise->cancel(); Calling cancel() on a pending promise will close the underlying socket resource, thus cancelling the pending TCP/IP connection, and reject the resulting promise. You can optionally pass additional socket context options to the constructor like this: $tcpConnector = new React\\Socket\\TcpConnector($loop, array( 'bindto' => '192.168.0.1:0' )); Note that this class only allows you to connect to IP-port-combinations. If the given URI is invalid, does not contain a valid IP address and port or contains any other scheme, it will reject with an InvalidArgumentException: If the given URI appears to be valid, but connecting to it fails (such as if the remote host rejects the connection etc.), it will reject with a RuntimeException. If you want to connect to hostname-port-combinations, see also the following chapter. Advanced usage: Internally, the TcpConnector allocates an empty context resource for each stream resource. If the destination URI contains a hostname query parameter, its value will be used to set up the TLS peer name. This is used by the SecureConnector and DnsConnector to verify the peer name and can also be used if you want a custom TLS peer name. HappyEyeBallsConnector The HappyEyeBallsConnector class implements the ConnectorInterface and allows you to create plaintext TCP/IP connections to any hostname-port-combination. Internally it implements the happy eyeballs algorithm from RFC6555 and RFC8305 to support IPv6 and IPv4 hostnames. It does so by decorating a given TcpConnector instance so that it first looks up the given domain name via DNS (if applicable) and then establishes the underlying TCP/IP connection to the resolved target IP address. Make sure to set up your DNS resolver and underlying TCP connector like this: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $dns = $dnsResolverFactory->createCached('8.8.8.8', $loop); $dnsConnector = new React\\Socket\\HappyEyeBallsConnector($loop, $tcpConnector, $dns); $dnsConnector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); See also the examples. Pending connection attempts can be cancelled by cancelling its pending promise like so: $promise = $dnsConnector->connect('www.google.com:80'); $promise->cancel(); Calling cancel() on a pending promise will cancel the underlying DNS lookups and/or the underlying TCP/IP connection(s) and reject the resulting promise. Advanced usage: Internally, the HappyEyeBallsConnector relies on a Resolver to look up the IP addresses for the given hostname. It will then replace the hostname in the destination URI with this IP's and append a hostname query parameter and pass this updated URI to the underlying connector. The Happy Eye Balls algorithm describes looking the IPv6 and IPv4 address for the given hostname so this connector sends out two DNS lookups for the A and AAAA records. It then uses all IP addresses (both v6 and v4) and tries to connect to all of them with a 50ms interval in between. Alterating between IPv6 and IPv4 addresses. When a connection is established all the other DNS lookups and connection attempts are cancelled. DnsConnector The DnsConnector class implements the ConnectorInterface and allows you to create plaintext TCP/IP connections to any hostname-port-combination. It does so by decorating a given TcpConnector instance so that it first looks up the given domain name via DNS (if applicable) and then establishes the underlying TCP/IP connection to the resolved target IP address. Make sure to set up your DNS resolver and underlying TCP connector like this: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $dns = $dnsResolverFactory->createCached('8.8.8.8', $loop); $dnsConnector = new React\\Socket\\DnsConnector($tcpConnector, $dns); $dnsConnector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); See also the examples. Pending connection attempts can be cancelled by cancelling its pending promise like so: $promise = $dnsConnector->connect('www.google.com:80'); $promise->cancel(); Calling cancel() on a pending promise will cancel the underlying DNS lookup and/or the underlying TCP/IP connection and reject the resulting promise. Advanced usage: Internally, the DnsConnector relies on a React\\Dns\\Resolver\\ResolverInterface to look up the IP address for the given hostname. It will then replace the hostname in the destination URI with this IP and append a hostname query parameter and pass this updated URI to the underlying connector. The underlying connector is thus responsible for creating a connection to the target IP address, while this query parameter can be used to check the original hostname and is used by the TcpConnector to set up the TLS peer name. If a hostname is given explicitly, this query parameter will not be modified, which can be useful if you want a custom TLS peer name. SecureConnector The SecureConnector class implements the ConnectorInterface and allows you to create secure TLS (formerly known as SSL) connections to any hostname-port-combination. It does so by decorating a given DnsConnector instance so that it first creates a plaintext TCP/IP connection and then enables TLS encryption on this stream. $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop); $secureConnector->connect('www.google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"GET / HTTP/1.0\\r\\nHost: www.google.com\\r\\n\\r\\n\"); ... }); $loop->run(); See also the examples. Pending connection attempts can be cancelled by cancelling its pending promise like so: $promise = $secureConnector->connect('www.google.com:443'); $promise->cancel(); Calling cancel() on a pending promise will cancel the underlying TCP/IP connection and/or the SSL/TLS negotiation and reject the resulting promise. You can optionally pass additional SSL context options to the constructor like this: $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop, array( 'verify_peer' => false, 'verify_peer_name' => false )); By default, this connector supports TLSv1.0+ and excludes support for legacy SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you want to negotiate with the remote side: $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop, array( 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT )); Advanced usage: Internally, the SecureConnector relies on setting up the required context options on the underlying stream resource. It should therefor be used with a TcpConnector somewhere in the connector stack so that it can allocate an empty context resource for each stream resource and verify the peer name. Failing to do so may result in a TLS peer name mismatch error or some hard to trace race conditions, because all stream resources will use a single, shared default context resource otherwise. TimeoutConnector The TimeoutConnector class implements the ConnectorInterface and allows you to add timeout handling to any existing connector instance. It does so by decorating any given ConnectorInterface instance and starting a timer that will automatically reject and abort any underlying connection attempt if it takes too long. $timeoutConnector = new React\\Socket\\TimeoutConnector($connector, 3.0, $loop); $timeoutConnector->connect('google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { // connection succeeded within 3.0 seconds }); See also any of the examples. Pending connection attempts can be cancelled by cancelling its pending promise like so: $promise = $timeoutConnector->connect('google.com:80'); $promise->cancel(); Calling cancel() on a pending promise will cancel the underlying connection attempt, abort the timer and reject the resulting promise. UnixConnector The UnixConnector class implements the ConnectorInterface and allows you to connect to Unix domain socket (UDS) paths like this: $connector = new React\\Socket\\UnixConnector($loop); $connector->connect('/tmp/demo.sock')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"HELLO\\n\"); }); $loop->run(); Connecting to Unix domain sockets is an atomic operation, i.e. its promise will settle (either resolve or reject) immediately. As such, calling cancel() on the resulting promise has no effect. The getRemoteAddress() method will return the target Unix domain socket (UDS) path as given to the connect() method, prepended with the unix:// scheme, for example unix:///tmp/demo.sock. The getLocalAddress() method will most likely return a null value as this value is not applicable to UDS connections here. FixedUriConnector The FixedUriConnector class implements the ConnectorInterface and decorates an existing Connector to always use a fixed, preconfigured URI. This can be useful for consumers that do not support certain URIs, such as when you want to explicitly connect to a Unix domain socket (UDS) path instead of connecting to a default address assumed by an higher-level API: $connector = new React\\Socket\\FixedUriConnector( 'unix:///var/run/docker.sock', new React\\Socket\\UnixConnector($loop) ); // destination will be ignored, actually connects to Unix domain socket $promise = $connector->connect('localhost:80'); Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/socket:^1.6 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project, partly due to its vast performance improvements and partly because legacy PHP versions require several workarounds as described below. Secure TLS connections received some major upgrades starting with PHP 5.6, with the defaults now being more secure, while older versions required explicit context options. This library does not take responsibility over these context options, so it's up to consumers of this library to take care of setting appropriate context options as described above. PHP PHP This project also supports running on HHVM. Note that really old HHVM stream_socket_enable_crypto() function. As such, trying to create a secure TLS connections on affected versions will return a rejected promise instead. This issue is also covered by our test suite, which will skip related tests on affected versions. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"3.Protocol-Components/Dns.html":{"url":"3.Protocol-Components/Dns.html","title":"Dns","keywords":"","body":"Dns Async DNS resolver for ReactPHP. The main point of the DNS component is to provide async DNS resolution. However, it is really a toolkit for working with DNS messages, and could easily be used to create a DNS server. Table of contents Basic usage Caching Custom cache adapter ResolverInterface resolve() resolveAll() Advanced usage UdpTransportExecutor TcpTransportExecutor SelectiveTransportExecutor HostsFileExecutor Install Tests License References Basic usage The most basic usage is to just create a resolver through the resolver factory. All you need to give it is a nameserver, then you can start resolving names, baby! $loop = React\\EventLoop\\Factory::create(); $config = React\\Dns\\Config\\Config::loadSystemConfigBlocking(); $server = $config->nameservers ? reset($config->nameservers) : '8.8.8.8'; $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->create($server, $loop); $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); $loop->run(); See also the first example. The Config class can be used to load the system default config. This is an operation that may access the filesystem and block. Ideally, this method should thus be executed only once before the loop starts and not repeatedly while it is running. Note that this class may return an empty configuration if the system config can not be loaded. As such, you'll likely want to apply a default nameserver as above if none can be found. Note that the factory loads the hosts file from the filesystem once when creating the resolver instance. Ideally, this method should thus be executed only once before the loop starts and not repeatedly while it is running. But there's more. Caching You can cache results by configuring the resolver to use a CachedExecutor: $loop = React\\EventLoop\\Factory::create(); $config = React\\Dns\\Config\\Config::loadSystemConfigBlocking(); $server = $config->nameservers ? reset($config->nameservers) : '8.8.8.8'; $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->createCached($server, $loop); $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); ... $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); $loop->run(); If the first call returns before the second, only one query will be executed. The second result will be served from an in memory cache. This is particularly useful for long running scripts where the same hostnames have to be looked up multiple times. See also the third example. Custom cache adapter By default, the above will use an in memory cache. You can also specify a custom cache implementing CacheInterface to handle the record cache instead: $cache = new React\\Cache\\ArrayCache(); $loop = React\\EventLoop\\Factory::create(); $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->createCached('8.8.8.8', $loop, $cache); See also the wiki for possible cache implementations. ResolverInterface resolve() The resolve(string $domain): PromiseInterface method can be used to resolve the given $domain name to a single IPv4 address (type A query). $resolver->resolve('reactphp.org')->then(function ($ip) { echo 'IP for reactphp.org is ' . $ip . PHP_EOL; }); This is one of the main methods in this package. It sends a DNS query for the given $domain name to your DNS server and returns a single IP address on success. If the DNS server sends a DNS response message that contains more than one IP address for this query, it will randomly pick one of the IP addresses from the response. If you want the full list of IP addresses or want to send a different type of query, you should use the resolveAll() method instead. If the DNS server sends a DNS response message that indicates an error code, this method will reject with a RecordNotFoundException. Its message and code can be used to check for the response code. If the DNS communication fails and the server does not respond with a valid response message, this message will reject with an Exception. Pending DNS queries can be cancelled by cancelling its pending promise like so: $promise = $resolver->resolve('reactphp.org'); $promise->cancel(); resolveAll() The resolveAll(string $host, int $type): PromiseInterface method can be used to resolve all record values for the given $domain name and query $type. $resolver->resolveAll('reactphp.org', Message::TYPE_A)->then(function ($ips) { echo 'IPv4 addresses for reactphp.org ' . implode(', ', $ips) . PHP_EOL; }); $resolver->resolveAll('reactphp.org', Message::TYPE_AAAA)->then(function ($ips) { echo 'IPv6 addresses for reactphp.org ' . implode(', ', $ips) . PHP_EOL; }); This is one of the main methods in this package. It sends a DNS query for the given $domain name to your DNS server and returns a list with all record values on success. If the DNS server sends a DNS response message that contains one or more records for this query, it will return a list with all record values from the response. You can use the Message::TYPE_* constants to control which type of query will be sent. Note that this method always returns a list of record values, but each record value type depends on the query type. For example, it returns the IPv4 addresses for type A queries, the IPv6 addresses for type AAAA queries, the hostname for type NS, CNAME and PTR queries and structured data for other queries. See also the Record documentation for more details. If the DNS server sends a DNS response message that indicates an error code, this method will reject with a RecordNotFoundException. Its message and code can be used to check for the response code. If the DNS communication fails and the server does not respond with a valid response message, this message will reject with an Exception. Pending DNS queries can be cancelled by cancelling its pending promise like so: $promise = $resolver->resolveAll('reactphp.org', Message::TYPE_AAAA); $promise->cancel(); Advanced Usage UdpTransportExecutor The UdpTransportExecutor can be used to send DNS queries over a UDP transport. This is the main class that sends a DNS query to your DNS server and is used internally by the Resolver for the actual message transport. For more advanced usages one can utilize this class directly. The following example looks up the IPv6 address for igor.io. $loop = Factory::create(); $executor = new UdpTransportExecutor('8.8.8.8:53', $loop); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); $loop->run(); See also the fourth example. Note that this executor does not implement a timeout, so you will very likely want to use this in combination with a TimeoutExecutor like this: $executor = new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ); Also note that this executor uses an unreliable UDP transport and that it does not implement any retry logic, so you will likely want to use this in combination with a RetryExecutor like this: $executor = new RetryExecutor( new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ) ); Note that this executor is entirely async and as such allows you to execute any number of queries concurrently. You should probably limit the number of concurrent queries in your application or you're very likely going to face rate limitations and bans on the resolver end. For many common applications, you may want to avoid sending the same query multiple times when the first one is still pending, so you will likely want to use this in combination with a CoopExecutor like this: $executor = new CoopExecutor( new RetryExecutor( new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ) ) ); Internally, this class uses PHP's UDP sockets and does not take advantage of react/datagram purely for organizational reasons to avoid a cyclic dependency between the two packages. Higher-level components should take advantage of the Datagram component instead of reimplementing this socket logic from scratch. TcpTransportExecutor The TcpTransportExecutor class can be used to send DNS queries over a TCP/IP stream transport. This is one of the main classes that send a DNS query to your DNS server. For more advanced usages one can utilize this class directly. The following example looks up the IPv6 address for reactphp.org. $loop = Factory::create(); $executor = new TcpTransportExecutor('8.8.8.8:53', $loop); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); $loop->run(); See also example #92. Note that this executor does not implement a timeout, so you will very likely want to use this in combination with a TimeoutExecutor like this: $executor = new TimeoutExecutor( new TcpTransportExecutor($nameserver, $loop), 3.0, $loop ); Unlike the UdpTransportExecutor, this class uses a reliable TCP/IP transport, so you do not necessarily have to implement any retry logic. Note that this executor is entirely async and as such allows you to execute queries concurrently. The first query will establish a TCP/IP socket connection to the DNS server which will be kept open for a short period. Additional queries will automatically reuse this existing socket connection to the DNS server, will pipeline multiple requests over this single connection and will keep an idle connection open for a short period. The initial TCP/IP connection overhead may incur a slight delay if you only send occasional queries – when sending a larger number of concurrent queries over an existing connection, it becomes increasingly more efficient and avoids creating many concurrent sockets like the UDP-based executor. You may still want to limit the number of (concurrent) queries in your application or you may be facing rate limitations and bans on the resolver end. For many common applications, you may want to avoid sending the same query multiple times when the first one is still pending, so you will likely want to use this in combination with a CoopExecutor like this: $executor = new CoopExecutor( new TimeoutExecutor( new TcpTransportExecutor($nameserver, $loop), 3.0, $loop ) ); Internally, this class uses PHP's TCP/IP sockets and does not take advantage of react/socket purely for organizational reasons to avoid a cyclic dependency between the two packages. Higher-level components should take advantage of the Socket component instead of reimplementing this socket logic from scratch. SelectiveTransportExecutor The SelectiveTransportExecutor class can be used to Send DNS queries over a UDP or TCP/IP stream transport. This class will automatically choose the correct transport protocol to send a DNS query to your DNS server. It will always try to send it over the more efficient UDP transport first. If this query yields a size related issue (truncated messages), it will retry over a streaming TCP/IP transport. For more advanced usages one can utilize this class directly. The following example looks up the IPv6 address for reactphp.org. $executor = new SelectiveTransportExecutor($udpExecutor, $tcpExecutor); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); Note that this executor only implements the logic to select the correct transport for the given DNS query. Implementing the correct transport logic, implementing timeouts and any retry logic is left up to the given executors, see also UdpTransportExecutor and TcpTransportExecutor for more details. Note that this executor is entirely async and as such allows you to execute any number of queries concurrently. You should probably limit the number of concurrent queries in your application or you're very likely going to face rate limitations and bans on the resolver end. For many common applications, you may want to avoid sending the same query multiple times when the first one is still pending, so you will likely want to use this in combination with a CoopExecutor like this: $executor = new CoopExecutor( new SelectiveTransportExecutor( $datagramExecutor, $streamExecutor ) ); HostsFileExecutor Note that the above UdpTransportExecutor class always performs an actual DNS query. If you also want to take entries from your hosts file into account, you may use this code: $hosts = \\React\\Dns\\Config\\HostsFile::loadFromPathBlocking(); $executor = new UdpTransportExecutor('8.8.8.8:53', $loop); $executor = new HostsFileExecutor($hosts, $executor); $executor->query( new Query('localhost', Message::TYPE_A, Message::CLASS_IN) ); Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/dns:^1.4 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. References RFC 1034 Domain Names - Concepts and Facilities RFC 1035 Domain Names - Implementation and Specification "},"3.Protocol-Components/Http.html":{"url":"3.Protocol-Components/Http.html","title":"Http","keywords":"","body":"HTTP Event-driven, streaming HTTP client and server implementation for ReactPHP. This HTTP library provides re-usable implementations for an HTTP client and server based on ReactPHP's Socket and EventLoop components. Its client component allows you to send any number of async HTTP/HTTPS requests concurrently. Its server component allows you to build plaintext HTTP and secure HTTPS servers that accept incoming HTTP requests from HTTP clients (such as web browsers). This library provides async, streaming means for all of this, so you can handle multiple concurrent HTTP requests without blocking. Table of contents Quickstart example Client Usage Request methods Promises Cancellation Timeouts Authentication Redirects Blocking Concurrency Streaming response Streaming request HTTP proxy SOCKS proxy SSH proxy Unix domain sockets Server Usage Server listen() Server Request Request parameters Query parameters Request body Streaming incoming request Request method Cookie parameters Invalid request Server Response Deferred response Streaming outgoing response Response length Invalid response Default response headers Middleware Custom middleware Third-Party Middleware API Browser get() post() head() patch() put() delete() request() requestStreaming() withTimeout() withFollowRedirects() withRejectErrorResponse() withBase() withProtocolVersion() withResponseBuffer() React\\Http\\Message Response ServerRequest ResponseException React\\Http\\Middleware StreamingRequestMiddleware LimitConcurrentRequestsMiddleware RequestBodyBufferMiddleware RequestBodyParserMiddleware Install Tests License Quickstart example Once installed, you can use the following code to access a HTTP webserver and send some simple HTTP GET requests: $loop = React\\EventLoop\\Factory::create(); $client = new React\\Http\\Browser($loop); $client->get('http://www.google.com/')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders(), (string)$response->getBody()); }); $loop->run(); This is an HTTP server which responds with Hello World! to every request. $loop = React\\EventLoop\\Factory::create(); $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); $socket = new React\\Socket\\Server(8080, $loop); $server->listen($socket); $loop->run(); See also the examples. Client Usage Request methods Most importantly, this project provides a Browser object that offers several methods that resemble the HTTP protocol methods: $browser->get($url, array $headers = array()); $browser->head($url, array $headers = array()); $browser->post($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->delete($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->put($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->patch($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); Each of these methods requires a $url and some optional parameters to send an HTTP request. Each of these method names matches the respective HTTP request method, for example the get() method sends an HTTP GET request. You can optionally pass an associative array of additional $headers that will be sent with this HTTP request. Additionally, each method will automatically add a matching Content-Length request header if an outgoing request body is given and its size is known and non-empty. For an empty request body, if will only include a Content-Length: 0 request header if the request method usually expects a request body (only applies to POST, PUT and PATCH HTTP request methods). If you're using a streaming request body, it will default to using Transfer-Encoding: chunked unless you explicitly pass in a matching Content-Length request header. See also streaming request for more details. By default, all of the above methods default to sending requests using the HTTP/1.1 protocol version. If you want to explicitly use the legacy HTTP/1.0 protocol version, you can use the withProtocolVersion() method. If you want to use any other or even custom HTTP request method, you can use the request() method. Each of the above methods supports async operation and either fulfills with a PSR-7 ResponseInterface or rejects with an Exception. Please see the following chapter about promises for more details. Promises Sending requests is async (non-blocking), so you can actually send multiple requests in parallel. The Browser will respond to each request with a PSR-7 ResponseInterface message, the order is not guaranteed. Sending requests uses a Promise-based interface that makes it easy to react to when an HTTP request is completed (i.e. either successfully fulfilled or rejected with an error): $browser->get($url)->then( function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump('Response received', $response); }, function (Exception $error) { var_dump('There was an error', $error->getMessage()); } ); If this looks strange to you, you can also use the more traditional blocking API. Keep in mind that resolving the Promise with the full response message means the whole response body has to be kept in memory. This is easy to get started and works reasonably well for smaller responses (such as common HTML pages or RESTful or JSON API requests). You may also want to look into the streaming API: If you're dealing with lots of concurrent requests (100+) or If you want to process individual data chunks as they happen (without having to wait for the full response body) or If you're expecting a big response body size (1 MiB or more, for example when downloading binary files) or If you're unsure about the response body size (better be safe than sorry when accessing arbitrary remote HTTP endpoints and the response body size is unknown in advance). Cancellation The returned Promise is implemented in such a way that it can be cancelled when it is still pending. Cancelling a pending promise will reject its value with an Exception and clean up any underlying resources. $promise = $browser->get($url); $loop->addTimer(2.0, function () use ($promise) { $promise->cancel(); }); Timeouts This library uses a very efficient HTTP implementation, so most HTTP requests should usually be completed in mere milliseconds. However, when sending HTTP requests over an unreliable network (the internet), there are a number of things that can go wrong and may cause the request to fail after a time. As such, this library respects PHP's default_socket_timeout setting (default 60s) as a timeout for sending the outgoing HTTP request and waiting for a successful response and will otherwise cancel the pending request and reject its value with an Exception. Note that this timeout value covers creating the underlying transport connection, sending the HTTP request, receiving the HTTP response headers and its full response body and following any eventual redirects. See also redirects below to configure the number of redirects to follow (or disable following redirects altogether) and also streaming below to not take receiving large response bodies into account for this timeout. You can use the withTimeout() method to pass a custom timeout value in seconds like this: $browser = $browser->withTimeout(10.0); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // response received within 10 seconds maximum var_dump($response->getHeaders()); }); Similarly, you can use a bool false to not apply a timeout at all or use a bool true value to restore the default handling. See withTimeout() for more details. If you're using a streaming response body, the time it takes to receive the response body stream will not be included in the timeout. This allows you to keep this incoming stream open for a longer time, such as when downloading a very large stream or when streaming data over a long-lived connection. If you're using a streaming request body, the time it takes to send the request body stream will not be included in the timeout. This allows you to keep this outgoing stream open for a longer time, such as when uploading a very large stream. Note that this timeout handling applies to the higher-level HTTP layer. Lower layers such as socket and DNS may also apply (different) timeout values. In particular, the underlying socket connection uses the same default_socket_timeout setting to establish the underlying transport connection. To control this connection timeout behavior, you can inject a custom Connector like this: $browser = new React\\Http\\Browser( $loop, new React\\Socket\\Connector( $loop, array( 'timeout' => 5 ) ) ); Authentication This library supports HTTP Basic Authentication using the Authorization: Basic … request header or allows you to set an explicit Authorization request header. By default, this library does not include an outgoing Authorization request header. If the server requires authentication, if may return a 401 (Unauthorized) status code which will reject the request by default (see also the withRejectErrorResponse() method below). In order to pass authentication details, you can simply pass the username and password as part of the request URL like this: $promise = $browser->get('https://user:pass@example.com/api'); Note that special characters in the authentication details have to be percent-encoded, see also rawurlencode(). This example will automatically pass the base64-encoded authentication details using the outgoing Authorization: Basic … request header. If the HTTP endpoint you're talking to requires any other authentication scheme, you can also pass this header explicitly. This is common when using (RESTful) HTTP APIs that use OAuth access tokens or JSON Web Tokens (JWT): $token = 'abc123'; $promise = $browser->get( 'https://example.com/api', array( 'Authorization' => 'Bearer ' . $token ) ); When following redirects, the Authorization request header will never be sent to any remote hosts by default. When following a redirect where the Location response header contains authentication details, these details will be sent for following requests. See also redirects below. Redirects By default, this library follows any redirects and obeys 3xx (Redirection) status codes using the Location response header from the remote server. The promise will be fulfilled with the last response from the chain of redirects. $browser->get($url, $headers)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // the final response will end up here var_dump($response->getHeaders()); }); Any redirected requests will follow the semantics of the original request and will include the same request headers as the original request except for those listed below. If the original request contained a request body, this request body will never be passed to the redirected request. Accordingly, each redirected request will remove any Content-Length and Content-Type request headers. If the original request used HTTP authentication with an Authorization request header, this request header will only be passed as part of the redirected request if the redirected URL is using the same host. In other words, the Authorizaton request header will not be forwarded to other foreign hosts due to possible privacy/security concerns. When following a redirect where the Location response header contains authentication details, these details will be sent for following requests. You can use the withFollowRedirects() method to control the maximum number of redirects to follow or to return any redirect responses as-is and apply custom redirection logic like this: $browser = $browser->withFollowRedirects(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any redirects will now end up here var_dump($response->getHeaders()); }); See also withFollowRedirects() for more details. Blocking As stated above, this library provides you a powerful, async API by default. If, however, you want to integrate this into your traditional, blocking environment, you should look into also using clue/reactphp-block. The resulting blocking code could look something like this: use Clue\\React\\Block; $loop = React\\EventLoop\\Factory::create(); $browser = new React\\Http\\Browser($loop); $promise = $browser->get('http://example.com/'); try { $response = Block\\await($promise, $loop); // response successfully received } catch (Exception $e) { // an error occured while performing the request } Similarly, you can also process multiple requests concurrently and await an array of Response objects: $promises = array( $browser->get('http://example.com/'), $browser->get('http://www.example.org/'), ); $responses = Block\\awaitAll($promises, $loop); Please refer to clue/reactphp-block for more details. Keep in mind the above remark about buffering the whole response message in memory. As an alternative, you may also see one of the following chapters for the streaming API. Concurrency As stated above, this library provides you a powerful, async API. Being able to send a large number of requests at once is one of the core features of this project. For instance, you can easily send 100 requests concurrently while processing SQL queries at the same time. Remember, with great power comes great responsibility. Sending an excessive number of requests may either take up all resources on your side or it may even get you banned by the remote side if it sees an unreasonable number of requests from your side. // watch out if array contains many elements foreach ($urls as $url) { $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); } As a consequence, it's usually recommended to limit concurrency on the sending side to a reasonable value. It's common to use a rather small limit, as doing more than a dozen of things at once may easily overwhelm the receiving side. You can use clue/reactphp-mq as a lightweight in-memory queue to concurrently do many (but not too many) things at once: // wraps Browser in a Queue object that executes no more than 10 operations at once $q = new Clue\\React\\Mq\\Queue(10, null, function ($url) use ($browser) { return $browser->get($url); }); foreach ($urls as $url) { $q($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); } Additional requests that exceed the concurrency limit will automatically be enqueued until one of the pending requests completes. This integrates nicely with the existing Promise-based API. Please refer to clue/reactphp-mq for more details. This in-memory approach works reasonably well for some thousand outstanding requests. If you're processing a very large input list (think millions of rows in a CSV or NDJSON file), you may want to look into using a streaming approach instead. See clue/reactphp-flux for more details. Streaming response All of the above examples assume you want to store the whole response body in memory. This is easy to get started and works reasonably well for smaller responses. However, there are several situations where it's usually a better idea to use a streaming approach, where only small chunks have to be kept in memory: If you're dealing with lots of concurrent requests (100+) or If you want to process individual data chunks as they happen (without having to wait for the full response body) or If you're expecting a big response body size (1 MiB or more, for example when downloading binary files) or If you're unsure about the response body size (better be safe than sorry when accessing arbitrary remote HTTP endpoints and the response body size is unknown in advance). You can use the requestStreaming() method to send an arbitrary HTTP request and receive a streaming response. It uses the same HTTP message API, but does not buffer the response body in memory. It only processes the response body in small chunks as data is received and forwards this data through ReactPHP's Stream API. This works for (any number of) responses of arbitrary sizes. This means it resolves with a normal PSR-7 ResponseInterface, which can be used to access the response message parameters as usual. You can access the message body as usual, however it now also implements ReactPHP's ReadableStreamInterface as well as parts of the PSR-7 StreamInterface. $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { $body = $response->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); $body->on('data', function ($chunk) { echo $chunk; }); $body->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage() . PHP_EOL; }); $body->on('close', function () { echo '[DONE]' . PHP_EOL; }); }); See also the stream download benchmark example and the stream forwarding example. You can invoke the following methods on the message body: $body->on($event, $callback); $body->eof(); $body->isReadable(); $body->pipe(React\\Stream\\WritableStreamInterface $dest, array $options = array()); $body->close(); $body->pause(); $body->resume(); Because the message body is in a streaming state, invoking the following methods doesn't make much sense: $body->__toString(); // '' $body->detach(); // throws BadMethodCallException $body->getSize(); // null $body->tell(); // throws BadMethodCallException $body->isSeekable(); // false $body->seek(); // throws BadMethodCallException $body->rewind(); // throws BadMethodCallException $body->isWritable(); // false $body->write(); // throws BadMethodCallException $body->read(); // throws BadMethodCallException $body->getContents(); // throws BadMethodCallException Note how timeouts apply slightly differently when using streaming. In streaming mode, the timeout value covers creating the underlying transport connection, sending the HTTP request, receiving the HTTP response headers and following any eventual redirects. In particular, the timeout value does not take receiving (possibly large) response bodies into account. If you want to integrate the streaming response into a higher level API, then working with Promise objects that resolve with Stream objects is often inconvenient. Consider looking into also using react/promise-stream. The resulting streaming code could look something like this: use React\\Promise\\Stream; function download(Browser $browser, string $url): React\\Stream\\ReadableStreamInterface { return Stream\\unwrapReadable( $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { return $response->getBody(); }) ); } $stream = download($browser, $url); $stream->on('data', function ($data) { echo $data; }); See also the requestStreaming() method for more details. Streaming request Besides streaming the response body, you can also stream the request body. This can be useful if you want to send big POST requests (uploading files etc.) or process many outgoing streams at once. Instead of passing the body as a string, you can simply pass an instance implementing ReactPHP's ReadableStreamInterface to the request methods like this: $browser->post($url, array(), $stream)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { echo 'Successfully sent.'; }); If you're using a streaming request body (React\\Stream\\ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->post($url, array('Content-Length' => '11'), $body); If the streaming request body emits an error event or is explicitly closed without emitting a successful end event first, the request will automatically be closed and rejected. HTTP proxy You can also establish your outgoing connections through an HTTP CONNECT proxy server by adding a dependency to clue/reactphp-http-proxy. HTTP CONNECT proxy servers (also commonly known as \"HTTPS proxy\" or \"SSL proxy\") are commonly used to tunnel HTTPS traffic through an intermediary (\"proxy\"), to conceal the origin address (anonymity) or to circumvent address blocking (geoblocking). While many (public) HTTP CONNECT proxy servers often limit this to HTTPS port443 only, this can technically be used to tunnel any TCP/IP-based protocol, such as plain HTTP and TLS-encrypted HTTPS. $proxy = new Clue\\React\\HttpProxy\\ProxyConnector( 'http://127.0.0.1:8080', new React\\Socket\\Connector($loop) ); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); See also the HTTP CONNECT proxy example. SOCKS proxy You can also establish your outgoing connections through a SOCKS proxy server by adding a dependency to clue/reactphp-socks. The SOCKS proxy protocol family (SOCKS5, SOCKS4 and SOCKS4a) is commonly used to tunnel HTTP(S) traffic through an intermediary (\"proxy\"), to conceal the origin address (anonymity) or to circumvent address blocking (geoblocking). While many (public) SOCKS proxy servers often limit this to HTTP(S) port 80 and 443 only, this can technically be used to tunnel any TCP/IP-based protocol. $proxy = new Clue\\React\\Socks\\Client( 'socks://127.0.0.1:1080', new React\\Socket\\Connector($loop) ); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); See also the SOCKS proxy example. SSH proxy You can also establish your outgoing connections through an SSH server by adding a dependency to clue/reactphp-ssh-proxy. Secure Shell (SSH) is a secure network protocol that is most commonly used to access a login shell on a remote server. Its architecture allows it to use multiple secure channels over a single connection. Among others, this can also be used to create an \"SSH tunnel\", which is commonly used to tunnel HTTP(S) traffic through an intermediary (\"proxy\"), to conceal the origin address (anonymity) or to circumvent address blocking (geoblocking). This can be used to tunnel any TCP/IP-based protocol (HTTP, SMTP, IMAP etc.), allows you to access local services that are otherwise not accessible from the outside (database behind firewall) and as such can also be used for plain HTTP and TLS-encrypted HTTPS. $proxy = new Clue\\React\\SshProxy\\SshSocksConnector('me@localhost:22', $loop); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); See also the SSH proxy example. Unix domain sockets By default, this library supports transport over plaintext TCP/IP and secure TLS connections for the http:// and https:// URL schemes respectively. This library also supports Unix domain sockets (UDS) when explicitly configured. In order to use a UDS path, you have to explicitly configure the connector to override the destination URL so that the hostname given in the request URL will no longer be used to establish the connection: $connector = new React\\Socket\\FixedUriConnector( 'unix:///var/run/docker.sock', new React\\Socket\\UnixConnector($loop) ); $browser = new Browser($loop, $connector); $client->get('http://localhost/info')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders(), (string)$response->getBody()); }); See also the Unix Domain Sockets (UDS) example. Server Usage Server The React\\Http\\Server class is responsible for handling incoming connections and then processing each incoming HTTP request. When a complete HTTP request has been received, it will invoke the given request handler function. This request handler function needs to be passed to the constructor and will be invoked with the respective request object and expects a response object in return: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); Each incoming HTTP request message is always represented by the PSR-7 ServerRequestInterface, see also following request chapter for more details. Each outgoing HTTP response message is always represented by the PSR-7 ResponseInterface, see also following response chapter for more details. In order to start listening for any incoming connections, the Server needs to be attached to an instance of React\\Socket\\ServerInterface through the listen() method as described in the following chapter. In its most simple form, you can attach this to a React\\Socket\\Server in order to start a plaintext HTTP server like this: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('0.0.0.0:8080', $loop); $server->listen($socket); See also the listen() method and the hello world server example for more details. By default, the Server buffers and parses the complete incoming HTTP request in memory. It will invoke the given request handler function when the complete request headers and request body has been received. This means the request object passed to your request handler function will be fully compatible with PSR-7 (http-message). This provides sane defaults for 80% of the use cases and is the recommended way to use this library unless you're sure you know what you're doing. On the other hand, buffering complete HTTP requests in memory until they can be processed by your request handler function means that this class has to employ a number of limits to avoid consuming too much memory. In order to take the more advanced configuration out your hand, it respects setting from your php.ini to apply its default settings. This is a list of PHP settings this class respects with their respective default values: memory_limit 128M post_max_size 8M // capped at 64K enable_post_data_reading 1 max_input_nesting_level 64 max_input_vars 1000 file_uploads 1 upload_max_filesize 2M max_file_uploads 20 In particular, the post_max_size setting limits how much memory a single HTTP request is allowed to consume while buffering its request body. This needs to be limited because the server can process a large number of requests concurrently, so the server may potentially consume a large amount of memory otherwise. To support higher concurrency by default, this value is capped at 64K. If you assign a higher value, it will only allow 64K by default. If a request exceeds this limit, its request body will be ignored and it will be processed like a request with no request body at all. See below for explicit configuration to override this setting. By default, this class will try to avoid consuming more than half of your memory_limit for buffering multiple concurrent HTTP requests. As such, with the above default settings of 128M max, it will try to consume no more than 64M for buffering multiple concurrent HTTP requests. As a consequence, it will limit the concurrency to 1024 HTTP requests with the above defaults. It is imperative that you assign reasonable values to your PHP ini settings. It is usually recommended to not support buffering incoming HTTP requests with a large HTTP request body (e.g. large file uploads). If you want to increase this buffer size, you will have to also increase the total memory limit to allow for more concurrent requests (set memory_limit 512M or more) or explicitly limit concurrency. In order to override the above buffering defaults, you can configure the Server explicitly. You can use the LimitConcurrentRequestsMiddleware and RequestBodyBufferMiddleware (see below) to explicitly configure the total number of requests that can be handled at once like this: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); In this example, we allow processing up to 100 concurrent requests at once and each request can buffer up to 2M. This means you may have to keep a maximum of 200M of memory for incoming request body buffers. Accordingly, you need to adjust the memory_limit ini setting to allow for these buffers plus your actual application logic memory requirements (think 512M or more). Internally, this class automatically assigns these middleware handlers automatically when no StreamingRequestMiddleware is given. Accordingly, you can use this example to override all default settings to implement custom limits. As an alternative to buffering the complete request body in memory, you can also use a streaming approach where only small chunks of data have to be kept in memory: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), $handler ); In this case, it will invoke the request handler function once the HTTP request headers have been received, i.e. before receiving the potentially much larger HTTP request body. This means the request passed to your request handler function may not be fully compatible with PSR-7. This is specifically designed to help with more advanced use cases where you want to have full control over consuming the incoming HTTP request body and concurrency settings. See also streaming incoming request below for more details. listen() The listen(React\\Socket\\ServerInterface $socket): void method can be used to start listening for HTTP requests on the given socket server instance. The given React\\Socket\\ServerInterface is responsible for emitting the underlying streaming connections. This HTTP server needs to be attached to it in order to process any connections and pase incoming streaming data as incoming HTTP request messages. In its most common form, you can attach this to a React\\Socket\\Server in order to start a plaintext HTTP server like this: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('0.0.0.0:8080', $loop); $server->listen($socket); See also hello world server example for more details. This example will start listening for HTTP requests on the alternative HTTP port 8080 on all interfaces (publicly). As an alternative, it is very common to use a reverse proxy and let this HTTP server listen on the localhost (loopback) interface only by using the listen address 127.0.0.1:8080 instead. This way, you host your application(s) on the default HTTP port 80 and only route specific requests to this HTTP server. Likewise, it's usually recommended to use a reverse proxy setup to accept secure HTTPS requests on default HTTPS port 443 (TLS termination) and only route plaintext requests to this HTTP server. As an alternative, you can also accept secure HTTPS requests with this HTTP server by attaching this to a React\\Socket\\Server using a secure TLS listen address, a certificate file and optional passphrase like this: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('tls://0.0.0.0:8443', $loop, array( 'local_cert' => __DIR__ . '/localhost.pem' )); $server->listen($socket); See also hello world HTTPS example for more details. Server Request As seen above, the Server class is responsible for handling incoming connections and then processing each incoming HTTP request. The request object will be processed once the request has been received by the client. This request object implements the PSR-7 ServerRequestInterface which in turn extends the PSR-7 RequestInterface and will be passed to the callback function like this. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = \"The method of the request is: \" . $request->getMethod(); $body .= \"The requested path is: \" . $request->getUri()->getPath(); return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); }); For more details about the request object, also check out the documentation of PSR-7 ServerRequestInterface and PSR-7 RequestInterface. Request parameters The getServerParams(): mixed[] method can be used to get server-side parameters similar to the $_SERVER variable. The following parameters are currently available: REMOTE_ADDR The IP address of the request sender REMOTE_PORT Port of the request sender SERVER_ADDR The IP address of the server SERVER_PORT The port of the server REQUEST_TIME Unix timestamp when the complete request header has been received, as integer similar to time() REQUEST_TIME_FLOAT Unix timestamp when the complete request header has been received, as float similar to microtime(true) HTTPS Set to 'on' if the request used HTTPS, otherwise it won't be set $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = \"Your IP is: \" . $request->getServerParams()['REMOTE_ADDR']; return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); }); See also whatsmyip server example. Advanced: Note that address parameters will not be set if you're listening on a Unix domain socket (UDS) path as this protocol lacks the concept of host/port. Query parameters The getQueryParams(): array method can be used to get the query parameters similiar to the $_GET variable. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $queryParams = $request->getQueryParams(); $body = 'The query parameter \"foo\" is not set. Click the following link '; $body .= 'to use query parameter in your request'; if (isset($queryParams['foo'])) { $body = 'The value of \"foo\" is: ' . htmlspecialchars($queryParams['foo']); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/html' ), $body ); }); The response in the above example will return a response body with a link. The URL contains the query parameter foo with the value bar. Use htmlentities like in this example to prevent Cross-Site Scripting (abbreviated as XSS). See also server query parameters example. Request body By default, the Server will buffer and parse the full request body in memory. This means the given request object includes the parsed request body and any file uploads. As an alternative to the default buffering logic, you can also use the StreamingRequestMiddleware. Jump to the next chapter to learn more about how to process a streaming incoming request. As stated above, each incoming HTTP request is always represented by the PSR-7 ServerRequestInterface. This interface provides several methods that are useful when working with the incoming request body as described below. The getParsedBody(): null|array|object method can be used to get the parsed request body, similar to PHP's $_POST variable. This method may return a (possibly nested) array structure with all body parameters or a null value if the request body could not be parsed. By default, this method will only return parsed data for requests using Content-Type: application/x-www-form-urlencoded or Content-Type: multipart/form-data request headers (commonly used for POST requests for HTML form submission data). $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $name = $request->getParsedBody()['name'] ?? 'anonymous'; return new React\\Http\\Message\\Response( 200, array(), \"Hello $name!\\n\" ); }); See also form upload example for more details. The getBody(): StreamInterface method can be used to get the raw data from this request body, similar to PHP's php://input stream. This method returns an instance of the request body represented by the PSR-7 StreamInterface. This is particularly useful when using a custom request body that will not otherwise be parsed by default, such as a JSON (Content-Type: application/json) or an XML (Content-Type: application/xml) request body (which is commonly used for POST, PUT or PATCH requests in JSON-based or RESTful/RESTish APIs). $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $data = json_decode((string)$request->getBody()); $name = $data->name ?? 'anonymous'; return new React\\Http\\Message\\Response( 200, array('Content-Type' => 'application/json'), json_encode(['message' => \"Hello $name!\"]) ); }); See also JSON API server example for more details. The getUploadedFiles(): array method can be used to get the uploaded files in this request, similar to PHP's $_FILES variable. This method returns a (possibly nested) array structure with all file uploads, each represented by the PSR-7 UploadedFileInterface. This array will only be filled when using the Content-Type: multipart/form-data request header (commonly used for POST requests for HTML file uploads). $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $files = $request->getUploadedFiles(); $name = isset($files['avatar']) ? $files['avatar']->getClientFilename() : 'nothing'; return new React\\Http\\Message\\Response( 200, array(), \"Uploaded $name\\n\" ); }); See also form upload server example for more details. The getSize(): ?int method can be used to get the size of the request body, similar to PHP's $_SERVER['CONTENT_LENGTH'] variable. This method returns the complete size of the request body measured in number of bytes as defined by the message boundaries. This value may be 0 if the request message does not contain a request body (such as a simple GET request). This method operates on the buffered request body, i.e. the request body size is always known, even when the request does not specify a Content-Length request header or when using Transfer-Encoding: chunked for HTTP/1.1 requests. Note: The Server automatically takes care of handling requests with the additional Expect: 100-continue request header. When HTTP/1.1 clients want to send a bigger request body, they MAY send only the request headers with an additional Expect: 100-continue request header and wait before sending the actual (large) message body. In this case the server will automatically send an intermediary HTTP/1.1 100 Continue response to the client. This ensures you will receive the request body without a delay as expected. Streaming incoming request If you're using the advanced StreamingRequestMiddleware, the request object will be processed once the request headers have been received. This means that this happens irrespective of (i.e. before) receiving the (potentially much larger) request body. Note that this is non-standard behavior considered advanced usage. Jump to the previous chapter to learn more about how to process a buffered request body. While this may be uncommon in the PHP ecosystem, this is actually a very powerful approach that gives you several advantages not otherwise possible: React to requests before receiving a large request body, such as rejecting an unauthenticated request or one that exceeds allowed message lengths (file uploads). Start processing parts of the request body before the remainder of the request body arrives or if the sender is slowly streaming data. Process a large request body without having to buffer anything in memory, such as accepting a huge file upload or possibly unlimited request body stream. The getBody(): StreamInterface method can be used to access the request body stream. In the streaming mode, this method returns a stream instance that implements both the PSR-7 StreamInterface and the ReactPHP ReadableStreamInterface. However, most of the PSR-7 StreamInterface methods have been designed under the assumption of being in control of a synchronous request body. Given that this does not apply to this server, the following PSR-7 StreamInterface methods are not used and SHOULD NOT be called: tell(), eof(), seek(), rewind(), write() and read(). If this is an issue for your use case and/or you want to access uploaded files, it's highly recommended to use a buffered request body or use the RequestBodyBufferMiddleware instead. The ReactPHP ReadableStreamInterface gives you access to the incoming request body as the individual chunks arrive: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = $request->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); return new React\\Promise\\Promise(function ($resolve, $reject) use ($body) { $bytes = 0; $body->on('data', function ($data) use (&$bytes) { $bytes += strlen($data); }); $body->on('end', function () use ($resolve, &$bytes){ $resolve(new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Received $bytes bytes\\n\" )); }); // an error occures e.g. on invalid chunked encoded data or an unexpected 'end' event $body->on('error', function (\\Exception $exception) use ($resolve, &$bytes) { $resolve(new React\\Http\\Message\\Response( 400, array( 'Content-Type' => 'text/plain' ), \"Encountered error after $bytes bytes: {$exception->getMessage()}\\n\" )); }); }); } ); The above example simply counts the number of bytes received in the request body. This can be used as a skeleton for buffering or processing the request body. See also streaming request server example for more details. The data event will be emitted whenever new data is available on the request body stream. The server also automatically takes care of decoding any incoming requests using Transfer-Encoding: chunked and will only emit the actual payload as data. The end event will be emitted when the request body stream terminates successfully, i.e. it was read until its expected end. The error event will be emitted in case the request stream contains invalid data for Transfer-Encoding: chunked or when the connection closes before the complete request stream has been received. The server will automatically stop reading from the connection and discard all incoming data instead of closing it. A response message can still be sent (unless the connection is already closed). A close event will be emitted after an error or end event. For more details about the request body stream, check out the documentation of ReactPHP ReadableStreamInterface. The getSize(): ?int method can be used to get the size of the request body, similar to PHP's $_SERVER['CONTENT_LENGTH'] variable. This method returns the complete size of the request body measured in number of bytes as defined by the message boundaries. This value may be 0 if the request message does not contain a request body (such as a simple GET request). This method operates on the streaming request body, i.e. the request body size may be unknown (null) when using Transfer-Encoding: chunked for HTTP/1.1 requests. $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $size = $request->getBody()->getSize(); if ($size === null) { $body = 'The request does not contain an explicit length.'; $body .= 'This example does not accept chunked transfer encoding.'; return new React\\Http\\Message\\Response( 411, array( 'Content-Type' => 'text/plain' ), $body ); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Request body size: \" . $size . \" bytes\\n\" ); } ); Note: The Server automatically takes care of handling requests with the additional Expect: 100-continue request header. When HTTP/1.1 clients want to send a bigger request body, they MAY send only the request headers with an additional Expect: 100-continue request header and wait before sending the actual (large) message body. In this case the server will automatically send an intermediary HTTP/1.1 100 Continue response to the client. This ensures you will receive the streaming request body without a delay as expected. Request method Note that the server supports any request method (including custom and non- standard ones) and all request-target formats defined in the HTTP specs for each respective method, including normal origin-form requests as well as proxy requests in absolute-form and authority-form. The getUri(): UriInterface method can be used to get the effective request URI which provides you access to individiual URI components. Note that (depending on the given request-target) certain URI components may or may not be present, for example the getPath(): string method will return an empty string for requests in asterisk-form or authority-form. Its getHost(): string method will return the host as determined by the effective request URI, which defaults to the local socket address if a HTTP/1.0 client did not specify one (i.e. no Host header). Its getScheme(): string method will return http or https depending on whether the request was made over a secure TLS connection to the target host. The Host header value will be sanitized to match this host component plus the port component only if it is non-standard for this URI scheme. You can use getMethod(): string and getRequestTarget(): string to check this is an accepted request and may want to reject other requests with an appropriate error code, such as 400 (Bad Request) or 405 (Method Not Allowed). The CONNECT method is useful in a tunneling setup (HTTPS proxy) and not something most HTTP servers would want to care about. Note that if you want to handle this method, the client MAY send a different request-target than the Host header value (such as removing default ports) and the request-target MUST take precendence when forwarding. Cookie parameters The getCookieParams(): string[] method can be used to get all cookies sent with the current request. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $key = 'react\\php'; if (isset($request->getCookieParams()[$key])) { $body = \"Your cookie value is: \" . $request->getCookieParams()[$key]; return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain', 'Set-Cookie' => urlencode($key) . '=' . urlencode('test;more') ), \"Your cookie has been set.\" ); }); The above example will try to set a cookie on first access and will try to print the cookie value on all subsequent tries. Note how the example uses the urlencode() function to encode non-alphanumeric characters. This encoding is also used internally when decoding the name and value of cookies (which is in line with other implementations, such as PHP's cookie functions). See also cookie server example for more details. Invalid request The Server class supports both HTTP/1.1 and HTTP/1.0 request messages. If a client sends an invalid request message, uses an invalid HTTP protocol version or sends an invalid Transfer-Encoding request header value, the server will automatically send a 400 (Bad Request) HTTP error response to the client and close the connection. On top of this, it will emit an error event that can be used for logging purposes like this: $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); Note that the server will also emit an error event if you do not return a valid response object from your request handler function. See also invalid response for more details. Server Response The callback function passed to the constructor of the Server is responsible for processing the request and returning a response, which will be delivered to the client. This function MUST return an instance implementing PSR-7 ResponseInterface object or a ReactPHP Promise which resolves with a PSR-7 ResponseInterface object. This projects ships a Response class which implements the PSR-7 ResponseInterface. In its most simple form, you can use it like this: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); We use this Response class throughout our project examples, but feel free to use any other implementation of the PSR-7 ResponseInterface. See also the Response class for more details. Deferred response The example above returns the response directly, because it needs no time to be processed. Using a database, the file system or long calculations (in fact every action that will take >=1ms) to create your response, will slow down the server. To prevent this you SHOULD use a ReactPHP Promise. This example shows how such a long-term action could look like: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { return new Promise(function ($resolve, $reject) use ($loop) { $loop->addTimer(1.5, function() use ($resolve) { $response = new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello world\" ); $resolve($response); }); }); }); The above example will create a response after 1.5 second. This example shows that you need a promise, if your response needs time to created. The ReactPHP Promise will resolve in a Response object when the request body ends. If the client closes the connection while the promise is still pending, the promise will automatically be cancelled. The promise cancellation handler can be used to clean up any pending resources allocated in this case (if applicable). If a promise is resolved after the client closes, it will simply be ignored. Streaming outgoing response The Response class in this project supports to add an instance which implements the ReactPHP ReadableStreamInterface for the response body. So you are able stream data directly into the response body. Note that other implementations of the PSR-7 ResponseInterface may only support strings. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { $stream = new ThroughStream(); $timer = $loop->addPeriodicTimer(0.5, function () use ($stream) { $stream->write(microtime(true) . PHP_EOL); }); $loop->addTimer(5, function() use ($loop, $timer, $stream) { $loop->cancelTimer($timer); $stream->end(); }); return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $stream ); }); The above example will emit every 0.5 seconds the current Unix timestamp with microseconds as float to the client and will end after 5 seconds. This is just a example you could use of the streaming, you could also send a big amount of data via little chunks or use it for body data that needs to calculated. If the request handler resolves with a response stream that is already closed, it will simply send an empty response body. If the client closes the connection while the stream is still open, the response stream will automatically be closed. If a promise is resolved with a streaming body after the client closes, the response stream will automatically be closed. The close event can be used to clean up any pending resources allocated in this case (if applicable). Note that special care has to be taken if you use a body stream instance that implements ReactPHP's DuplexStreamInterface (such as the ThroughStream in the above example). For most cases, this will simply only consume its readable side and forward (send) any data that is emitted by the stream, thus entirely ignoring the writable side of the stream. If however this is either a 101 (Switching Protocols) response or a 2xx (Successful) response to a CONNECT method, it will also write data to the writable side of the stream. This can be avoided by either rejecting all requests with the CONNECT method (which is what most normal origin HTTP servers would likely do) or or ensuring that only ever an instance of ReactPHP's ReadableStreamInterface is used. The 101 (Switching Protocols) response code is useful for the more advanced Upgrade requests, such as upgrading to the WebSocket protocol or implementing custom protocol logic that is out of scope of the HTTP specs and this HTTP library. If you want to handle the Upgrade: WebSocket header, you will likely want to look into using Ratchet instead. If you want to handle a custom protocol, you will likely want to look into the HTTP specs and also see examples #81 and #82 for more details. In particular, the 101 (Switching Protocols) response code MUST NOT be used unless you send an Upgrade response header value that is also present in the corresponding HTTP/1.1 Upgrade request header value. The server automatically takes care of sending a Connection: upgrade header value in this case, so you don't have to. The CONNECT method is useful in a tunneling setup (HTTPS proxy) and not something most origin HTTP servers would want to care about. The HTTP specs define an opaque \"tunneling mode\" for this method and make no use of the message body. For consistency reasons, this library uses a DuplexStreamInterface in the response body for tunneled application data. This implies that that a 2xx (Successful) response to a CONNECT request can in fact use a streaming response body for the tunneled application data, so that any raw data the client sends over the connection will be piped through the writable stream for consumption. Note that while the HTTP specs make no use of the request body for CONNECT requests, one may still be present. Normal request body processing applies here and the connection will only turn to \"tunneling mode\" after the request body has been processed (which should be empty in most cases). See also HTTP CONNECT server example for more details. Response length If the response body size is known, a Content-Length response header will be added automatically. This is the most common use case, for example when using a string response body like this: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); If the response body size is unknown, a Content-Length response header can not be added automatically. When using a streaming outgoing response without an explicit Content-Length response header, outgoing HTTP/1.1 response messages will automatically use Transfer-Encoding: chunked while legacy HTTP/1.0 response messages will contain the plain response body. If you know the length of your streaming response body, you MAY want to specify it explicitly like this: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { $stream = new ThroughStream(); $loop->addTimer(2.0, function () use ($stream) { $stream->end(\"Hello World!\\n\"); }); return new React\\Http\\Message\\Response( 200, array( 'Content-Length' => '13', 'Content-Type' => 'text/plain', ), $stream ); }); Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content) or 304 (Not Modified) status code will not include a message body as per the HTTP specs. This means that your callback does not have to take special care of this and any response body will simply be ignored. Similarly, any 2xx (Successful) response to a CONNECT request, any response with a 1xx (Informational) or 204 (No Content) status code will not include a Content-Length or Transfer-Encoding header as these do not apply to these messages. Note that a response to a HEAD request and any response with a 304 (Not Modified) status code MAY include these headers even though the message does not contain a response body, because these header would apply to the message if the same request would have used an (unconditional) GET. Invalid response As stated above, each outgoing HTTP response is always represented by the PSR-7 ResponseInterface. If your request handler function returns an invalid value or throws an unhandled Exception or Throwable, the server will automatically send a 500 (Internal Server Error) HTTP error response to the client. On top of this, it will emit an error event that can be used for logging purposes like this: $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; if ($e->getPrevious() !== null) { echo 'Previous: ' . $e->getPrevious()->getMessage() . PHP_EOL; } }); Note that the server will also emit an error event if the client sends an invalid HTTP request that never reaches your request handler function. See also invalid request for more details. Additionally, a streaming incoming request body can also emit an error event on the request body. The server will only send a very generic 500 (Interval Server Error) HTTP error response without any further details to the client if an unhandled error occurs. While we understand this might make initial debugging harder, it also means that the server does not leak any application details or stack traces to the outside by default. It is usually recommended to catch any Exception or Throwable within your request handler function or alternatively use a middleware to avoid this generic error handling and create your own HTTP response message instead. Default response headers When a response is returned from the request handler function, it will be processed by the Server and then sent back to the client. A Server: ReactPHP/1 response header will be added automatically. You can add a custom Server response header like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Server' => 'PHP/3' ) ); }); If you do not want to send this Sever response header at all (such as when you don't want to expose the underlying server software), you can use an empty string value like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Server' => '' ) ); }); A Date response header will be added automatically with the current system date and time if none is given. You can add a custom Date response header like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Date' => gmdate('D, d M Y H:i:s \\G\\M\\T') ) ); }); If you do not want to send this Date response header at all (such as when you don't have an appropriate clock to rely on), you can use an empty string value like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Date' => '' ) ); }); The Server class will automatically add the protocol version of the request, so you don't have to. For instance, if the client sends the request using the HTTP/1.1 protocol version, the response message will also use the same protocol version, no matter what version is returned from the request handler function. Note that persistent connections (Connection: keep-alive) are currently not supported. As such, HTTP/1.1 response messages will automatically include a Connection: close header, irrespective of what header values are passed explicitly. Middleware As documented above, the Server accepts a single request handler argument that is responsible for processing an incoming HTTP request and then creating and returning an outgoing HTTP response. Many common use cases involve validating, processing, manipulating the incoming HTTP request before passing it to the final business logic request handler. As such, this project supports the concept of middleware request handlers. Custom middleware A middleware request handler is expected to adhere the following rules: It is a valid callable. It accepts an instance implementing PSR-7 ServerRequestInterface as first argument and an optional callable as second argument. It returns either: An instance implementing PSR-7 ResponseInterface for direct consumption. Any promise which can be consumed by Promise\\resolve() resolving to a PSR-7 ResponseInterface for deferred consumption. It MAY throw an Exception (or return a rejected promise) in order to signal an error condition and abort the chain. It calls $next($request) to continue processing the next middleware request handler or returns explicitly without calling $next to abort the chain. The $next request handler (recursively) invokes the next request handler from the chain with the same logic as above and returns (or throws) as above. The $request may be modified prior to calling $next($request) to change the incoming request the next middleware operates on. The $next return value may be consumed to modify the outgoing response. The $next request handler MAY be called more than once if you want to implement custom \"retry\" logic etc. Note that this very simple definition allows you to use either anonymous functions or any classes that use the magic __invoke() method. This allows you to easily create custom middleware request handlers on the fly or use a class based approach to ease using existing middleware implementations. While this project does provide the means to use middleware implementations, it does not aim to define how middleware implementations should look like. We realize that there's a vivid ecosystem of middleware implementations and ongoing effort to standardize interfaces between these with PSR-15 (HTTP Server Request Handlers) and support this goal. As such, this project only bundles a few middleware implementations that are required to match PHP's request behavior (see below) and otherwise actively encourages Third-Party Middleware implementations. In order to use middleware request handlers, simply pass an array with all callables as defined above to the Server. The following example adds a middleware request handler that adds the current time to the request as a header (Request-Time) and a final request handler that always returns a 200 code without a body: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $request = $request->withHeader('Request-Time', time()); return $next($request); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response(200); } ); Note how the middleware request handler and the final request handler have a very simple (and similar) interface. The only difference is that the final request handler does not receive a $next handler. Similarly, you can use the result of the $next middleware request handler function to modify the outgoing response. Note that as per the above documentation, the $next middleware request handler may return a PSR-7 ResponseInterface directly or one wrapped in a promise for deferred resolution. In order to simplify handling both paths, you can simply wrap this in a Promise\\resolve() call like this: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $promise = React\\Promise\\resolve($next($request)); return $promise->then(function (ResponseInterface $response) { return $response->withHeader('Content-Type', 'text/html'); }); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response(200); } ); Note that the $next middleware request handler may also throw an Exception (or return a rejected promise) as described above. The previous example does not catch any exceptions and would thus signal an error condition to the Server. Alternatively, you can also catch any Exception to implement custom error handling logic (or logging etc.) by wrapping this in a Promise like this: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $promise = new React\\Promise\\Promise(function ($resolve) use ($next, $request) { $resolve($next($request)); }); return $promise->then(null, function (Exception $e) { return new React\\Http\\Message\\Response( 500, array(), 'Internal error: ' . $e->getMessage() ); }); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { if (mt_rand(0, 1) === 1) { throw new RuntimeException('Database error'); } return new React\\Http\\Message\\Response(200); } ); Third-Party Middleware While this project does provide the means to use middleware implementations (see above), it does not aim to define how middleware implementations should look like. We realize that there's a vivid ecosystem of middleware implementations and ongoing effort to standardize interfaces between these with PSR-15 (HTTP Server Request Handlers) and support this goal. As such, this project only bundles a few middleware implementations that are required to match PHP's request behavior (see middleware implementations) and otherwise actively encourages third-party middleware implementations. While we would love to support PSR-15 directly in react/http, we understand that this interface does not specifically target async APIs and as such does not take advantage of promises for deferred responses. The gist of this is that where PSR-15 enforces a PSR-7 ResponseInterface return value, we also accept a PromiseInterface. As such, we suggest using the external PSR-15 middleware adapter that uses on the fly monkey patching of these return values which makes using most PSR-15 middleware possible with this package without any changes required. Other than that, you can also use the above middleware definition to create custom middleware. A non-exhaustive list of third-party middleware can be found at the middleware wiki. If you build or know a custom middleware, make sure to let the world know and feel free to add it to this list. API Browser The React\\Http\\Browser is responsible for sending HTTP requests to your HTTP server and keeps track of pending incoming HTTP responses. It also registers everything with the main EventLoop. $loop = React\\EventLoop\\Factory::create(); $browser = new React\\Http\\Browser($loop); If you need custom connector settings (DNS resolution, TLS parameters, timeouts, proxy servers etc.), you can explicitly pass a custom instance of the ConnectorInterface: $connector = new React\\Socket\\Connector($loop, array( 'dns' => '127.0.0.1', 'tcp' => array( 'bindto' => '192.168.10.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ) )); $browser = new React\\Http\\Browser($loop, $connector); Note that the browser class is final and shouldn't be extended, it is likely to be marked final in a future release. get() The get(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP GET request. $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); See also GET request client example. post() The post(string $url, array $headers = array(), string|ReadableStreamInterface $contents = ''): PromiseInterface method can be used to send an HTTP POST request. $browser->post( $url, [ 'Content-Type' => 'application/json' ], json_encode($data) )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump(json_decode((string)$response->getBody())); }); See also POST JSON client example. This method is also commonly used to submit HTML form data: $data = [ 'user' => 'Alice', 'password' => 'secret' ]; $browser->post( $url, [ 'Content-Type' => 'application/x-www-form-urlencoded' ], http_build_query($data) ); This method will automatically add a matching Content-Length request header if the outgoing request body is a string. If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->post($url, array('Content-Length' => '11'), $body); head() The head(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP HEAD request. $browser->head($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); patch() The patch(string $url, array $headers = array(), string|ReadableStreamInterface $contents = ''): PromiseInterface method can be used to send an HTTP PATCH request. $browser->patch( $url, [ 'Content-Type' => 'application/json' ], json_encode($data) )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump(json_decode((string)$response->getBody())); }); This method will automatically add a matching Content-Length request header if the outgoing request body is a string. If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->patch($url, array('Content-Length' => '11'), $body); put() The put(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP PUT request. $browser->put( $url, [ 'Content-Type' => 'text/xml' ], $xml->asXML() )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); See also PUT XML client example. This method will automatically add a matching Content-Length request header if the outgoing request body is a string. If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->put($url, array('Content-Length' => '11'), $body); delete() The delete(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP DELETE request. $browser->delete($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); request() The request(string $method, string $url, array $headers = array(), string|ReadableStreamInterface $body = ''): PromiseInterface method can be used to send an arbitrary HTTP request. The preferred way to send an HTTP request is by using the above request methods, for example the get() method to send an HTTP GET request. As an alternative, if you want to use a custom HTTP request method, you can use this method: $browser->request('OPTIONS', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); This method will automatically add a matching Content-Length request header if the size of the outgoing request body is known and non-empty. For an empty request body, if will only include a Content-Length: 0 request header if the request method usually expects a request body (only applies to POST, PUT and PATCH). If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->request('POST', $url, array('Content-Length' => '11'), $body); requestStreaming() The requestStreaming(string $method, string $url, array $headers = array(), string|ReadableStreamInterface $body = ''): PromiseInterface method can be used to send an arbitrary HTTP request and receive a streaming response without buffering the response body. The preferred way to send an HTTP request is by using the above request methods, for example the get() method to send an HTTP GET request. Each of these methods will buffer the whole response body in memory by default. This is easy to get started and works reasonably well for smaller responses. In some situations, it's a better idea to use a streaming approach, where only small chunks have to be kept in memory. You can use this method to send an arbitrary HTTP request and receive a streaming response. It uses the same HTTP message API, but does not buffer the response body in memory. It only processes the response body in small chunks as data is received and forwards this data through ReactPHP's Stream API. This works for (any number of) responses of arbitrary sizes. $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { $body = $response->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); $body->on('data', function ($chunk) { echo $chunk; }); $body->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage() . PHP_EOL; }); $body->on('close', function () { echo '[DONE]' . PHP_EOL; }); }); See also ReactPHP's ReadableStreamInterface and the streaming response for more details, examples and possible use-cases. This method will automatically add a matching Content-Length request header if the size of the outgoing request body is known and non-empty. For an empty request body, if will only include a Content-Length: 0 request header if the request method usually expects a request body (only applies to POST, PUT and PATCH). If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->requestStreaming('POST', $url, array('Content-Length' => '11'), $body); withTimeout() The withTimeout(bool|number $timeout): Browser method can be used to change the maximum timeout used for waiting for pending requests. You can pass in the number of seconds to use as a new timeout value: $browser = $browser->withTimeout(10.0); You can pass in a bool false to disable any timeouts. In this case, requests can stay pending forever: $browser = $browser->withTimeout(false); You can pass in a bool true to re-enable default timeout handling. This will respects PHP's default_socket_timeout setting (default 60s): $browser = $browser->withTimeout(true); See also timeouts for more details about timeout handling. Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given timeout value applied. withFollowRedirects() The withFollowRedirects(bool|int $followRedirects): Browser method can be used to change how HTTP redirects will be followed. You can pass in the maximum number of redirects to follow: $browser = $browser->withFollowRedirects(5); The request will automatically be rejected when the number of redirects is exceeded. You can pass in a 0 to reject the request for any redirects encountered: $browser = $browser->withFollowRedirects(0); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // only non-redirected responses will now end up here var_dump($response->getHeaders()); }); You can pass in a bool false to disable following any redirects. In this case, requests will resolve with the redirection response instead of following the Location response header: $browser = $browser->withFollowRedirects(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any redirects will now end up here var_dump($response->getHeaderLine('Location')); }); You can pass in a bool true to re-enable default redirect handling. This defaults to following a maximum of 10 redirects: $browser = $browser->withFollowRedirects(true); See also redirects for more details about redirect handling. Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given redirect setting applied. withRejectErrorResponse() The withRejectErrorResponse(bool $obeySuccessCode): Browser method can be used to change whether non-successful HTTP response status codes (4xx and 5xx) will be rejected. You can pass in a bool false to disable rejecting incoming responses that use a 4xx or 5xx response status code. In this case, requests will resolve with the response message indicating an error condition: $browser = $browser->withRejectErrorResponse(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any HTTP response will now end up here var_dump($response->getStatusCode(), $response->getReasonPhrase()); }); You can pass in a bool true to re-enable default status code handling. This defaults to rejecting any response status codes in the 4xx or 5xx range with a ResponseException: $browser = $browser->withRejectErrorResponse(true); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any successful HTTP response will now end up here var_dump($response->getStatusCode(), $response->getReasonPhrase()); }, function (Exception $e) { if ($e instanceof React\\Http\\Message\\ResponseException) { // any HTTP response error message will now end up here $response = $e->getResponse(); var_dump($response->getStatusCode(), $response->getReasonPhrase()); } else { var_dump($e->getMessage()); } }); Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given setting applied. withBase() The withBase(string|null $baseUrl): Browser method can be used to change the base URL used to resolve relative URLs to. If you configure a base URL, any requests to relative URLs will be processed by first resolving this relative to the given absolute base URL. This supports resolving relative path references (like ../ etc.). This is particularly useful for (RESTful) API calls where all endpoints (URLs) are located under a common base URL. $browser = $browser->withBase('http://api.example.com/v3/'); // will request http://api.example.com/v3/users $browser->get('users')->then(…); You can pass in a null base URL to return a new instance that does not use a base URL: $browser = $browser->withBase(null); Accordingly, any requests using relative URLs to a browser that does not use a base URL can not be completed and will be rejected without sending a request. This method will throw an InvalidArgumentException if the given $baseUrl argument is not a valid URL. Notice that the Browser is an immutable object, i.e. the withBase() method actually returns a new Browser instance with the given base URL applied. withProtocolVersion() The withProtocolVersion(string $protocolVersion): Browser method can be used to change the HTTP protocol version that will be used for all subsequent requests. All the above request methods default to sending requests as HTTP/1.1. This is the preferred HTTP protocol version which also provides decent backwards-compatibility with legacy HTTP/1.0 servers. As such, there should rarely be a need to explicitly change this protocol version. If you want to explicitly use the legacy HTTP/1.0 protocol version, you can use this method: $browser = $browser->withProtocolVersion('1.0'); $browser->get($url)->then(…); Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the new protocol version applied. withResponseBuffer() The withResponseBuffer(int $maximumSize): Browser method can be used to change the maximum size for buffering a response body. The preferred way to send an HTTP request is by using the above request methods, for example the get() method to send an HTTP GET request. Each of these methods will buffer the whole response body in memory by default. This is easy to get started and works reasonably well for smaller responses. By default, the response body buffer will be limited to 16 MiB. If the response body exceeds this maximum size, the request will be rejected. You can pass in the maximum number of bytes to buffer: $browser = $browser->withResponseBuffer(1024 * 1024); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // response body will not exceed 1 MiB var_dump($response->getHeaders(), (string) $response->getBody()); }); Note that the response body buffer has to be kept in memory for each pending request until its transfer is completed and it will only be freed after a pending request is fulfilled. As such, increasing this maximum buffer size to allow larger response bodies is usually not recommended. Instead, you can use the requestStreaming() method to receive responses with arbitrary sizes without buffering. Accordingly, this maximum buffer size setting has no effect on streaming responses. Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given setting applied. React\\Http\\Message Response The React\\Http\\Message\\Response class can be used to represent an outgoing server response message. $response = new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/html' ), \"Hello world!\\n\" ); This class implements the PSR-7 ResponseInterface which in turn extends the PSR-7 MessageInterface. Internally, this implementation builds on top of an existing incoming response message and only adds required streaming support. This base class is considered an implementation detail that may change in the future. ServerRequest The React\\Http\\Message\\ServerRequest class can be used to respresent an incoming server request message. This class implements the PSR-7 ServerRequestInterface which extends the PSR-7 RequestInterface which in turn extends the PSR-7 MessageInterface. This is mostly used internally to represent each incoming request message. Likewise, you can also use this class in test cases to test how your web application reacts to certain HTTP requests. Internally, this implementation builds on top of an existing outgoing request message and only adds required server methods. This base class is considered an implementation detail that may change in the future. ResponseException The React\\Http\\Message\\ResponseException is an Exception sub-class that will be used to reject a request promise if the remote server returns a non-success status code (anything but 2xx or 3xx). You can control this behavior via the withRejectErrorResponse() method. The getCode(): int method can be used to return the HTTP response status code. The getResponse(): ResponseInterface method can be used to access its underlying response object. React\\Http\\Middleware StreamingRequestMiddleware The React\\Http\\Middleware\\StreamingRequestMiddleware can be used to process incoming requests with a streaming request body (without buffering). This allows you to process requests of any size without buffering the request body in memory. Instead, it will represent the request body as a ReadableStreamInterface that emit chunks of incoming data as it is received: $server = new React\\Http\\Server(array( new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = $request->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); return new React\\Promise\\Promise(function ($resolve) use ($body) { $bytes = 0; $body->on('data', function ($chunk) use (&$bytes) { $bytes += \\count($chunk); }); $body->on('close', function () use (&$bytes, $resolve) { $resolve(new React\\Http\\Message\\Response( 200, [], \"Received $bytes bytes\\n\" )); }); }); } )); See also streaming incoming request for more details. Additionally, this middleware can be used in combination with the LimitConcurrentRequestsMiddleware and RequestBodyBufferMiddleware (see below) to explicitly configure the total number of requests that can be handled at once: $server = new React\\Http\\Server(array( new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler )); Internally, this class is used as a \"marker\" to not trigger the default request buffering behavior in the Server. It does not implement any logic on its own. LimitConcurrentRequestsMiddleware The React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware can be used to limit how many next handlers can be executed concurrently. If this middleware is invoked, it will check if the number of pending handlers is below the allowed limit and then simply invoke the next handler and it will return whatever the next handler returns (or throws). If the number of pending handlers exceeds the allowed limit, the request will be queued (and its streaming body will be paused) and it will return a pending promise. Once a pending handler returns (or throws), it will pick the oldest request from this queue and invokes the next handler (and its streaming body will be resumed). The following example shows how this middleware can be used to ensure no more than 10 handlers will be invoked at once: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(10), $handler ); Similarly, this middleware is often used in combination with the RequestBodyBufferMiddleware (see below) to limit the total number of requests that can be buffered at once: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); More sophisticated examples include limiting the total number of requests that can be buffered at once and then ensure the actual request handler only processes one request after another without any concurrency: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(1), // only execute 1 handler (no concurrency) $handler ); RequestBodyBufferMiddleware One of the built-in middleware is the React\\Http\\Middleware\\RequestBodyBufferMiddleware which can be used to buffer the whole incoming request body in memory. This can be useful if full PSR-7 compatibility is needed for the request handler and the default streaming request body handling is not needed. The constructor accepts one optional argument, the maximum request body size. When one isn't provided it will use post_max_size (default 8 MiB) from PHP's configuration. (Note that the value from your matching SAPI will be used, which is the CLI configuration in most cases.) Any incoming request that has a request body that exceeds this limit will be accepted, but its request body will be discarded (empty request body). This is done in order to avoid having to keep an incoming request with an excessive size (for example, think of a 2 GB file upload) in memory. This allows the next middleware handler to still handle this request, but it will see an empty request body. This is similar to PHP's default behavior, where the body will not be parsed if this limit is exceeded. However, unlike PHP's default behavior, the raw request body is not available via php://input. The RequestBodyBufferMiddleware will buffer requests with bodies of known size (i.e. with Content-Length header specified) as well as requests with bodies of unknown size (i.e. with Transfer-Encoding: chunked header). All requests will be buffered in memory until the request body end has been reached and then call the next middleware handler with the complete, buffered request. Similarly, this will immediately invoke the next middleware handler for requests that have an empty request body (such as a simple GET request) and requests that are already buffered (such as due to another middleware). Note that the given buffer size limit is applied to each request individually. This means that if you allow a 2 MiB limit and then receive 1000 concurrent requests, up to 2000 MiB may be allocated for these buffers alone. As such, it's highly recommended to use this along with the LimitConcurrentRequestsMiddleware (see above) to limit the total number of concurrent requests. Usage: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(16 * 1024 * 1024), // 16 MiB function (Psr\\Http\\Message\\ServerRequestInterface $request) { // The body from $request->getBody() is now fully available without the need to stream it return new React\\Http\\Message\\Response(200); }, ); RequestBodyParserMiddleware The React\\Http\\Middleware\\RequestBodyParserMiddleware takes a fully buffered request body (generally from RequestBodyBufferMiddleware), and parses the form values and file uploads from the incoming HTTP request body. This middleware handler takes care of applying values from HTTP requests that use Content-Type: application/x-www-form-urlencoded or Content-Type: multipart/form-data to resemble PHP's default superglobals $_POST and $_FILES. Instead of relying on these superglobals, you can use the $request->getParsedBody() and $request->getUploadedFiles() methods as defined by PSR-7. Accordingly, each file upload will be represented as instance implementing the PSR-7 UploadedFileInterface. Due to its blocking nature, the moveTo() method is not available and throws a RuntimeException instead. You can use $contents = (string)$file->getStream(); to access the file contents and persist this to your favorite data store. $handler = function (Psr\\Http\\Message\\ServerRequestInterface $request) { // If any, parsed form fields are now available from $request->getParsedBody() $body = $request->getParsedBody(); $name = isset($body['name']) ? $body['name'] : 'unnamed'; $files = $request->getUploadedFiles(); $avatar = isset($files['avatar']) ? $files['avatar'] : null; if ($avatar instanceof Psr\\Http\\Message\\UploadedFileInterface) { if ($avatar->getError() === UPLOAD_ERR_OK) { $uploaded = $avatar->getSize() . ' bytes'; } elseif ($avatar->getError() === UPLOAD_ERR_INI_SIZE) { $uploaded = 'file too large'; } else { $uploaded = 'with error'; } } else { $uploaded = 'nothing'; } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $name . ' uploaded ' . $uploaded ); }; $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(16 * 1024 * 1024), // 16 MiB new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); See also form upload server example for more details. By default, this middleware respects the upload_max_filesize (default 2M) ini setting. Files that exceed this limit will be rejected with an UPLOAD_ERR_INI_SIZE error. You can control the maximum filesize for each individual file upload by explicitly passing the maximum filesize in bytes as the first parameter to the constructor like this: new React\\Http\\Middleware\\RequestBodyParserMiddleware(8 * 1024 * 1024); // 8 MiB limit per file By default, this middleware respects the file_uploads (default 1) and max_file_uploads (default 20) ini settings. These settings control if any and how many files can be uploaded in a single request. If you upload more files in a single request, additional files will be ignored and the getUploadedFiles() method returns a truncated array. Note that upload fields left blank on submission do not count towards this limit. You can control the maximum number of file uploads per request by explicitly passing the second parameter to the constructor like this: new React\\Http\\Middleware\\RequestBodyParserMiddleware(10 * 1024, 100); // 100 files with 10 KiB each Note that this middleware handler simply parses everything that is already buffered in the request body. It is imperative that the request body is buffered by a prior middleware handler as given in the example above. This previous middleware handler is also responsible for rejecting incoming requests that exceed allowed message sizes (such as big file uploads). The RequestBodyBufferMiddleware used above simply discards excessive request bodies, resulting in an empty body. If you use this middleware without buffering first, it will try to parse an empty (streaming) body and may thus assume an empty data structure. See also RequestBodyBufferMiddleware for more details. PHP's MAX_FILE_SIZE hidden field is respected by this middleware. Files that exceed this limit will be rejected with an UPLOAD_ERR_FORM_SIZE error. This middleware respects the max_input_vars (default 1000) and max_input_nesting_level (default 64) ini settings. Note that this middleware ignores the enable_post_data_reading (default 1) ini setting because it makes little sense to respect here and is left up to higher-level implementations. If you want to respect this setting, you have to check its value and effectively avoid using this middleware entirely. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/http:^1.2 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"3.Protocol-Components/HttpClient.html":{"url":"3.Protocol-Components/HttpClient.html","title":"HttpClient","keywords":"","body":"Deprecation notice This package has now been migrated over to react/http and only exists for BC reasons. $ composer require react/http If you've previously used this package, upgrading may take a moment or two. The new API has been updated to use Promises and PSR-7 message abstractions. This means it's now more powerful and easier to use than ever: // old $client = new React\\HttpClient\\Client($loop); $request = $client->request('GET', 'https://example.com/'); $request->on('response', function ($response) { $response->on('data', function ($chunk) { echo $chunk; }); }); $request->end(); // new $browser = new React\\Http\\Browser($loop); $browser->get('https://example.com/')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { echo $response->getBody(); }); See react/http for more details. The below documentation applies to the last release of this package. Further development will take place in the updated react/http, so you're highly recommended to upgrade as soon as possible. Deprecated HttpClient Event-driven, streaming HTTP client for ReactPHP. Table of Contents Basic usage Client Example Advanced usage Unix domain sockets Install Tests License Basic usage Client The Client is responsible for communicating with HTTP servers, managing the connection state and sending your HTTP requests. It also registers everything with the main EventLoop. $loop = React\\EventLoop\\Factory::create(); $client = new Client($loop); If you need custom connector settings (DNS resolution, TLS parameters, timeouts, proxy servers etc.), you can explicitly pass a custom instance of the ConnectorInterface: $connector = new \\React\\Socket\\Connector($loop, array( 'dns' => '127.0.0.1', 'tcp' => array( 'bindto' => '192.168.10.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ) )); $client = new Client($loop, $connector); The request(string $method, string $uri, array $headers = array(), string $version = '1.0'): Request method can be used to prepare new Request objects. The optional $headers parameter can be used to pass additional request headers. You can use an associative array (key=value) or an array for each header value (key=values). The Request will automatically include an appropriate Host, User-Agent: react/alpha and Connection: close header if applicable. You can pass custom header values or use an empty array to omit any of these. The Request#write(string $data) method can be used to write data to the request body. Data will be buffered until the underlying connection is established, at which point buffered data will be sent and all further data will be passed to the underlying connection immediately. The Request#end(?string $data = null) method can be used to finish sending the request. You may optionally pass a last request body data chunk that will be sent just like a write() call. Calling this method finalizes the outgoing request body (which may be empty). Data will be buffered until the underlying connection is established, at which point buffered data will be sent and all further data will be ignored. The Request#close() method can be used to forefully close sending the request. Unlike the end() method, this method discards any buffers and closes the underlying connection if it is already established or cancels the pending connection attempt otherwise. Request implements WritableStreamInterface, so a Stream can be piped to it. Interesting events emitted by Request: response: The response headers were received from the server and successfully parsed. The first argument is a Response instance. drain: The outgoing buffer drained and the response is ready to accept more data for the next write() call. error: An error occurred, an Exception is passed as first argument. If the response emits an error event, this will also be emitted here. close: The request is closed. If an error occurred, this event will be preceeded by an error event. For a successful response, this will be emitted only once the response emits the close event. Response implements ReadableStreamInterface. Interesting events emitted by Response: data: Passes a chunk of the response body as first argument. When a response encounters a chunked encoded response it will parse it transparently for the user and removing the Transfer-Encoding header. error: An error occurred, an Exception is passed as first argument. This will also be forwarded to the request and emit an error event there. end: The response has been fully received. close: The response is closed. If an error occured, this event will be preceeded by an error event. This will also be forwarded to the request and emit a close event there. Example request('GET', 'https://github.com/'); $request->on('response', function ($response) { $response->on('data', function ($chunk) { echo $chunk; }); $response->on('end', function() { echo 'DONE'; }); }); $request->on('error', function (\\Exception $e) { echo $e; }); $request->end(); $loop->run(); See also the examples. Advanced Usage Unix domain sockets By default, this library supports transport over plaintext TCP/IP and secure TLS connections for the http:// and https:// URI schemes respectively. This library also supports Unix domain sockets (UDS) when explicitly configured. In order to use a UDS path, you have to explicitly configure the connector to override the destination URI so that the hostname given in the request URI will no longer be used to establish the connection: $connector = new FixedUriConnector( 'unix:///var/run/docker.sock', new UnixConnector($loop) ); $client = new Client($loop, $connector); $request = $client->request('GET', 'http://localhost/info'); See also example #11. Install The recommended way to install this library is through Composer. New to Composer? This will install the latest supported version: $ composer require react/http-client:^0.5.10 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that send test HTTP requests against the online service http://httpbin.org and thus rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"4.Utility-Components/Cache.html":{"url":"4.Utility-Components/Cache.html","title":"Cache","keywords":"","body":"Cache Async, Promise-based cache interface for ReactPHP. The cache component provides a Promise-based CacheInterface and an in-memory ArrayCache implementation of that. This allows consumers to type hint against the interface and third parties to provide alternate implementations. This project is heavily inspired by PSR-16: Common Interface for Caching Libraries, but uses an interface more suited for async, non-blocking applications. Table of Contents Usage CacheInterface get() set() delete() getMultiple() setMultiple() deleteMultiple() clear() has() ArrayCache Common usage Fallback get Fallback-get-and-set Install Tests License Usage CacheInterface The CacheInterface describes the main interface of this component. This allows consumers to type hint against the interface and third parties to provide alternate implementations. get() The get(string $key, mixed $default = null): PromiseInterface method can be used to retrieve an item from the cache. This method will resolve with the cached value on success or with the given $default value when no item can be found or when an error occurs. Similarly, an expired cache item (once the time-to-live is expired) is considered a cache miss. $cache ->get('foo') ->then('var_dump'); This example fetches the value of the key foo and passes it to the var_dump function. You can use any of the composition provided by promises. set() The set(string $key, mixed $value, ?float $ttl = null): PromiseInterface method can be used to store an item in the cache. This method will resolve with true on success or false when an error occurs. If the cache implementation has to go over the network to store it, it may take a while. The optional $ttl parameter sets the maximum time-to-live in seconds for this cache item. If this parameter is omitted (or null), the item will stay in the cache for as long as the underlying implementation supports. Trying to access an expired cache item results in a cache miss, see also get(). $cache->set('foo', 'bar', 60); This example eventually sets the value of the key foo to bar. If it already exists, it is overridden. This interface does not enforce any particular TTL resolution, so special care may have to be taken if you rely on very high precision with millisecond accuracy or below. Cache implementations SHOULD work on a best effort basis and SHOULD provide at least second accuracy unless otherwise noted. Many existing cache implementations are known to provide microsecond or millisecond accuracy, but it's generally not recommended to rely on this high precision. This interface suggests that cache implementations SHOULD use a monotonic time source if available. Given that a monotonic time source is only available as of PHP 7.3 by default, cache implementations MAY fall back to using wall-clock time. While this does not affect many common use cases, this is an important distinction for programs that rely on a high time precision or on systems that are subject to discontinuous time adjustments (time jumps). This means that if you store a cache item with a TTL of 30s and then adjust your system time forward by 20s, the cache item SHOULD still expire in 30s. delete() The delete(string $key): PromiseInterface method can be used to delete an item from the cache. This method will resolve with true on success or false when an error occurs. When no item for $key is found in the cache, it also resolves to true. If the cache implementation has to go over the network to delete it, it may take a while. $cache->delete('foo'); This example eventually deletes the key foo from the cache. As with set(), this may not happen instantly and a promise is returned to provide guarantees whether or not the item has been removed from cache. getMultiple() The getMultiple(string[] $keys, mixed $default = null): PromiseInterface method can be used to retrieve multiple cache items by their unique keys. This method will resolve with an array of cached values on success or with the given $default value when an item can not be found or when an error occurs. Similarly, an expired cache item (once the time-to-live is expired) is considered a cache miss. $cache->getMultiple(array('name', 'age'))->then(function (array $values) { $name = $values['name'] ?? 'User'; $age = $values['age'] ?? 'n/a'; echo $name . ' is ' . $age . PHP_EOL; }); This example fetches the cache items for the name and age keys and prints some example output. You can use any of the composition provided by promises. setMultiple() The setMultiple(array $values, ?float $ttl = null): PromiseInterface method can be used to persist a set of key => value pairs in the cache, with an optional TTL. This method will resolve with true on success or false when an error occurs. If the cache implementation has to go over the network to store it, it may take a while. The optional $ttl parameter sets the maximum time-to-live in seconds for these cache items. If this parameter is omitted (or null), these items will stay in the cache for as long as the underlying implementation supports. Trying to access an expired cache items results in a cache miss, see also getMultiple(). $cache->setMultiple(array('foo' => 1, 'bar' => 2), 60); This example eventually sets the list of values - the key foo to 1 value and the key bar to 2. If some of the keys already exist, they are overridden. deleteMultiple() The setMultiple(string[] $keys): PromiseInterface method can be used to delete multiple cache items in a single operation. This method will resolve with true on success or false when an error occurs. When no items for $keys are found in the cache, it also resolves to true. If the cache implementation has to go over the network to delete it, it may take a while. $cache->deleteMultiple(array('foo', 'bar, 'baz')); This example eventually deletes keys foo, bar and baz from the cache. As with setMultiple(), this may not happen instantly and a promise is returned to provide guarantees whether or not the item has been removed from cache. clear() The clear(): PromiseInterface method can be used to wipe clean the entire cache. This method will resolve with true on success or false when an error occurs. If the cache implementation has to go over the network to delete it, it may take a while. $cache->clear(); This example eventually deletes all keys from the cache. As with deleteMultiple(), this may not happen instantly and a promise is returned to provide guarantees whether or not all the items have been removed from cache. has() The has(string $key): PromiseInterface method can be used to determine whether an item is present in the cache. This method will resolve with true on success or false when no item can be found or when an error occurs. Similarly, an expired cache item (once the time-to-live is expired) is considered a cache miss. $cache ->has('foo') ->then('var_dump'); This example checks if the value of the key foo is set in the cache and passes the result to the var_dump function. You can use any of the composition provided by promises. NOTE: It is recommended that has() is only to be used for cache warming type purposes and not to be used within your live applications operations for get/set, as this method is subject to a race condition where your has() will return true and immediately after, another script can remove it making the state of your app out of date. ArrayCache The ArrayCache provides an in-memory implementation of the CacheInterface. $cache = new ArrayCache(); $cache->set('foo', 'bar'); Its constructor accepts an optional ?int $limit parameter to limit the maximum number of entries to store in the LRU cache. If you add more entries to this instance, it will automatically take care of removing the one that was least recently used (LRU). For example, this snippet will overwrite the first value and only store the last two entries: $cache = new ArrayCache(2); $cache->set('foo', '1'); $cache->set('bar', '2'); $cache->set('baz', '3'); This cache implementation is known to rely on wall-clock time to schedule future cache expiration times when using any version before PHP 7.3, because a monotonic time source is only available as of PHP 7.3 (hrtime()). While this does not affect many common use cases, this is an important distinction for programs that rely on a high time precision or on systems that are subject to discontinuous time adjustments (time jumps). This means that if you store a cache item with a TTL of 30s on PHP set() for more details. Common usage Fallback get A common use case of caches is to attempt fetching a cached value and as a fallback retrieve it from the original data source if not found. Here is an example of that: $cache ->get('foo') ->then(function ($result) { if ($result === null) { return getFooFromDb(); } return $result; }) ->then('var_dump'); First an attempt is made to retrieve the value of foo. A callback function is registered that will call getFooFromDb when the resulting value is null. getFooFromDb is a function (can be any PHP callable) that will be called if the key does not exist in the cache. getFooFromDb can handle the missing key by returning a promise for the actual value from the database (or any other data source). As a result, this chain will correctly fall back, and provide the value in both cases. Fallback get and set To expand on the fallback get example, often you want to set the value on the cache after fetching it from the data source. $cache ->get('foo') ->then(function ($result) { if ($result === null) { return $this->getAndCacheFooFromDb(); } return $result; }) ->then('var_dump'); public function getAndCacheFooFromDb() { return $this->db ->get('foo') ->then(array($this, 'cacheFooFromDb')); } public function cacheFooFromDb($foo) { $this->cache->set('foo', $foo); return $foo; } By using chaining you can easily conditionally cache the value if it is fetched from the database. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/cache:^1.1 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/ChildProcess.html":{"url":"4.Utility-Components/ChildProcess.html","title":"ChildProcess","keywords":"","body":"Child Process Event-driven library for executing child processes with ReactPHP. This library integrates Program Execution with the EventLoop. Child processes launched may be signaled and will emit an exit event upon termination. Additionally, process I/O streams (i.e. STDIN, STDOUT, STDERR) are exposed as Streams. Table of contents Quickstart example Process Stream Properties Command Termination Custom pipes Sigchild Compatibility Windows Compatibility Install Tests License Quickstart example $loop = React\\EventLoop\\Factory::create(); $process = new React\\ChildProcess\\Process('echo foo'); $process->start($loop); $process->stdout->on('data', function ($chunk) { echo $chunk; }); $process->on('exit', function($exitCode, $termSignal) { echo 'Process exited with code ' . $exitCode . PHP_EOL; }); $loop->run(); See also the examples. Process Stream Properties Once a process is started, its I/O streams will be constructed as instances of React\\Stream\\ReadableStreamInterface and React\\Stream\\WritableStreamInterface. Before start() is called, these properties are not set. Once a process terminates, the streams will become closed but not unset. Following common Unix conventions, this library will start each child process with the three pipes matching the standard I/O streams as given below by default. You can use the named references for common use cases or access these as an array with all three pipes. $stdin or $pipes[0] is a WritableStreamInterface $stdout or $pipes[1] is a ReadableStreamInterface $stderr or $pipes[2] is a ReadableStreamInterface Note that this default configuration may be overridden by explicitly passing custom pipes, in which case they may not be set or be assigned different values. In particular, note that Windows support is limited in that it doesn't support non-blocking STDIO pipes. The $pipes array will always contain references to all pipes as configured and the standard I/O references will always be set to reference the pipes matching the above conventions. See custom pipes for more details. Because each of these implement the underlying ReadableStreamInterface or WritableStreamInterface, you can use any of their events and methods as usual: $process = new Process($command); $process->start($loop); $process->stdout->on('data', function ($chunk) { echo $chunk; }); $process->stdout->on('end', function () { echo 'ended'; }); $process->stdout->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage(); }); $process->stdout->on('close', function () { echo 'closed'; }); $process->stdin->write($data); $process->stdin->end($data = null); // … For more details, see the ReadableStreamInterface and WritableStreamInterface. Command The Process class allows you to pass any kind of command line string: $process = new Process('echo test'); $process->start($loop); The command line string usually consists of a whitespace-separated list with your main executable bin and any number of arguments. Special care should be taken to escape or quote any arguments, escpecially if you pass any user input along. Likewise, keep in mind that especially on Windows, it is rather common to have path names containing spaces and other special characters. If you want to run a binary like this, you will have to ensure this is quoted as a single argument using escapeshellarg() like this: $bin = 'C:\\\\Program files (x86)\\\\PHP\\\\php.exe'; $file = 'C:\\\\Users\\\\me\\\\Desktop\\\\Application\\\\main.php'; $process = new Process(escapeshellarg($bin) . ' ' . escapeshellarg($file)); $process->start($loop); By default, PHP will launch processes by wrapping the given command line string in a sh command on Unix, so that the first example will actually execute sh -c echo test under the hood on Unix. On Windows, it will not launch processes by wrapping them in a shell. This is a very useful feature because it does not only allow you to pass single commands, but actually allows you to pass any kind of shell command line and launch multiple sub-commands using command chains (with &&, ||, ; and others) and allows you to redirect STDIO streams (with 2>&1 and family). This can be used to pass complete command lines and receive the resulting STDIO streams from the wrapping shell command like this: $process = new Process('echo run && demo || echo failed'); $process->start($loop); Note that Windows support is limited in that it doesn't support STDIO streams at all and also that processes will not be run in a wrapping shell by default. If you want to run a shell built-in function such as echo hello or sleep 10, you may have to prefix your command line with an explicit shell like cmd /c echo hello. In other words, the underlying shell is responsible for managing this command line and launching the individual sub-commands and connecting their STDIO streams as appropriate. This implies that the Process class will only receive the resulting STDIO streams from the wrapping shell, which will thus contain the complete input/output with no way to discern the input/output of single sub-commands. If you want to discern the output of single sub-commands, you may want to implement some higher-level protocol logic, such as printing an explicit boundary between each sub-command like this: $process = new Process('cat first && echo --- && cat second'); $process->start($loop); As an alternative, considering launching one process at a time and listening on its exit event to conditionally start the next process in the chain. This will give you an opportunity to configure the subsequent process I/O streams: $first = new Process('cat first'); $first->start($loop); $first->on('exit', function () use ($loop) { $second = new Process('cat second'); $second->start($loop); }); Keep in mind that PHP uses the shell wrapper for ALL command lines on Unix. While this may seem reasonable for more complex command lines, this actually also applies to running the most simple single command: $process = new Process('yes'); $process->start($loop); This will actually spawn a command hierarchy similar to this on Unix: 5480 … \\_ php example.php 5481 … \\_ sh -c yes 5482 … \\_ yes This means that trying to get the underlying process PID or sending signals will actually target the wrapping shell, which may not be the desired result in many cases. If you do not want this wrapping shell process to show up, you can simply prepend the command string with exec on Unix platforms, which will cause the wrapping shell process to be replaced by our process: $process = new Process('exec yes'); $process->start($loop); This will show a resulting command hierarchy similar to this: 5480 … \\_ php example.php 5481 … \\_ yes This means that trying to get the underlying process PID and sending signals will now target the actual command as expected. Note that in this case, the command line will not be run in a wrapping shell. This implies that when using exec, there's no way to pass command lines such as those containing command chains or redirected STDIO streams. As a rule of thumb, most commands will likely run just fine with the wrapping shell. If you pass a complete command line (or are unsure), you SHOULD most likely keep the wrapping shell. If you're running on Unix and you want to pass an invidual command only, you MAY want to consider prepending the command string with exec to avoid the wrapping shell. Termination The exit event will be emitted whenever the process is no longer running. Event listeners will receive the exit code and termination signal as two arguments: $process = new Process('sleep 10'); $process->start($loop); $process->on('exit', function ($code, $term) { if ($term === null) { echo 'exit with code ' . $code . PHP_EOL; } else { echo 'terminated with signal ' . $term . PHP_EOL; } }); Note that $code is null if the process has terminated, but the exit code could not be determined (for example sigchild compatibility was disabled). Similarly, $term is null unless the process has terminated in response to an uncaught signal sent to it. This is not a limitation of this project, but actual how exit codes and signals are exposed on POSIX systems, for more details see also here. It's also worth noting that process termination depends on all file descriptors being closed beforehand. This means that all process pipes will emit a close event before the exit event and that no more data events will arrive after the exit event. Accordingly, if either of these pipes is in a paused state (pause() method or internally due to a pipe() call), this detection may not trigger. The terminate(?int $signal = null): bool method can be used to send the process a signal (SIGTERM by default). Depending on which signal you send to the process and whether it has a signal handler registered, this can be used to either merely signal a process or even forcefully terminate it. $process->terminate(SIGUSR1); Keep the above section in mind if you want to forcefully terminate a process. If your process spawn sub-processes or implicitly uses the wrapping shell mentioned above, its file descriptors may be inherited to child processes and terminating the main process may not necessarily terminate the whole process tree. It is highly suggested that you explicitly close() all process pipes accordingly when terminating a process: $process = new Process('sleep 10'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { foreach ($process->pipes as $pipe) { $pipe->close(); } $process->terminate(); }); For many simple programs these seamingly complicated steps can also be avoided by prefixing the command line with exec to avoid the wrapping shell and its inherited process pipes as mentioned above. $process = new Process('exec sleep 10'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { $process->terminate(); }); Many command line programs also wait for data on STDIN and terminate cleanly when this pipe is closed. For example, the following can be used to \"soft-close\" a cat process: $process = new Process('cat'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { $process->stdin->end(); }); While process pipes and termination may seem confusing to newcomers, the above properties actually allow some fine grained control over process termination, such as first trying a soft-close and then applying a force-close after a timeout. Custom pipes Following common Unix conventions, this library will start each child process with the three pipes matching the standard I/O streams by default. For more advanced use cases it may be useful to pass in custom pipes, such as explicitly passing additional file descriptors (FDs) or overriding default process pipes. Note that passing custom pipes is considered advanced usage and requires a more in-depth understanding of Unix file descriptors and how they are inherited to child processes and shared in multi-processing applications. If you do not want to use the default standard I/O pipes, you can explicitly pass an array containing the file descriptor specification to the constructor like this: $fds = array( // standard I/O pipes for stdin/stdout/stderr 0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'w'), // example FDs for files or open resources 4 => array('file', '/dev/null', 'r'), 6 => fopen('log.txt','a'), 8 => STDERR, // example FDs for sockets 10 => fsockopen('localhost', 8080), 12 => stream_socket_server('tcp://0.0.0.0:4711') ); $process = new Process($cmd, null, null, $fds); $process->start($loop); Unless your use case has special requirements that demand otherwise, you're highly recommended to (at least) pass in the standard I/O pipes as given above. The file descriptor specification accepts arguments in the exact same format as the underlying proc_open() function. Once the process is started, the $pipes array will always contain references to all pipes as configured and the standard I/O references will always be set to reference the pipes matching common Unix conventions. This library supports any number of pipes and additional file descriptors, but many common applications being run as a child process will expect that the parent process properly assigns these file descriptors. Sigchild Compatibility Internally, this project uses a work-around to improve compatibility when PHP has been compiled with the --enable-sigchild option. This should not affect most installations as this configure option is not used by default and many distributions (such as Debian and Ubuntu) are known to not use this by default. Some installations that use Oracle OCI8 may use this configure option to circumvent defunct processes. When PHP has been compiled with the --enable-sigchild option, a child process' exit code cannot be reliably determined via proc_close() or proc_get_status(). To work around this, we execute the child process with an additional pipe and use that to retrieve its exit code. This work-around incurs some overhead, so we only trigger this when necessary and when we detect that PHP has been compiled with the --enable-sigchild option. Because PHP does not provide a way to reliably detect this option, we try to inspect output of PHP's configure options from the phpinfo() function. The static setSigchildEnabled(bool $sigchild): void method can be used to explicitly enable or disable this behavior like this: // advanced: not recommended by default Process::setSigchildEnabled(true); Note that all processes instantiated after this method call will be affected. If this work-around is disabled on an affected PHP installation, the exit event may receive null instead of the actual exit code as described above. Similarly, some distributions are known to omit the configure options from phpinfo(), so automatic detection may fail to enable this work-around in some cases. You may then enable this explicitly as given above. Note: The original functionality was taken from Symfony's Process compoment. Windows Compatibility Due to platform constraints, this library provides only limited support for spawning child processes on Windows. In particular, PHP does not allow accessing standard I/O pipes without blocking. As such, this project will not allow constructing a child process with the default process pipes and will instead throw a LogicException on Windows by default: // throws LogicException on Windows $process = new Process('ping example.com'); $process->start($loop); There are a number of alternatives and workarounds as detailed below if you want to run a child process on Windows, each with its own set of pros and cons: This package does work on Windows Subsystem for Linux (or WSL) without issues. When you are in control over how your application is deployed, we recommend installing WSL when you want to run this package on Windows. If you only care about the exit code of a child process to check if its execution was successful, you can use custom pipes to omit any standard I/O pipes like this: $process = new Process('ping example.com', null, null, array()); $process->start($loop); $process->on('exit', function ($exitcode) { echo 'exit with ' . $exitcode . PHP_EOL; }); Similarly, this is also useful if your child process communicates over sockets with remote servers or even your parent process using the Socket component. This is usually considered the best alternative if you have control over how your child process communicates with the parent process. If you only care about command output after the child process has been executed, you can use custom pipes to configure file handles to be passed to the child process instead of pipes like this: $process = new Process('ping example.com', null, null, array( array('file', 'nul', 'r'), $stdout = tmpfile(), array('file', 'nul', 'w') )); $process->start($loop); $process->on('exit', function ($exitcode) use ($stdout) { echo 'exit with ' . $exitcode . PHP_EOL; // rewind to start and then read full file (demo only, this is blocking). // reading from shared file is only safe if you have some synchronization in place // or after the child process has terminated. rewind($stdout); echo stream_get_contents($stdout); fclose($stdout); }); Note that this example uses tmpfile()/fopen() for illustration purposes only. This should not be used in a truly async program because the filesystem is inherently blocking and each call could potentially take several seconds. See also the Filesystem component as an alternative. If you want to access command output as it happens in a streaming fashion, you can use redirection to spawn an additional process to forward your standard I/O streams to a socket and use custom pipes to omit any actual standard I/O pipes like this: $server = new React\\Socket\\Server('127.0.0.1:0', $loop); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->on('data', function ($chunk) { echo $chunk; }); }); $command = 'ping example.com | foobar ' . escapeshellarg($server->getAddress()); $process = new Process($command, null, null, array()); $process->start($loop); $process->on('exit', function ($exitcode) use ($server) { $server->close(); echo 'exit with ' . $exitcode . PHP_EOL; }); Note how this will spawn another fictional foobar helper program to consume the standard output from the actual child process. This is in fact similar to the above recommendation of using socket connections in the child process, but in this case does not require modification of the actual child process. In this example, the fictional foobar helper program can be implemented by simply consuming all data from standard input and forwarding it to a socket connection like this: $socket = stream_socket_client($argv[1]); do { fwrite($socket, $data = fread(STDIN, 8192)); } while (isset($data[0])); Accordingly, this example can also be run with plain PHP without having to rely on any external helper program like this: $code = '$s=stream_socket_client($argv[1]);do{fwrite($s,$d=fread(STDIN, 8192));}while(isset($d[0]));'; $command = 'ping example.com | php -r ' . escapeshellarg($code) . ' ' . escapeshellarg($server->getAddress()); $process = new Process($command, null, null, array()); $process->start($loop); See also example #23. Note that this is for illustration purposes only and you may want to implement some proper error checks and/or socket verification in actual production use if you do not want to risk other processes connecting to the server socket. In this case, we suggest looking at the excellent createprocess-windows. Additionally, note that the command given to the Process will be passed to the underlying Windows-API (CreateProcess) as-is and the process will not be launched in a wrapping shell by default. In particular, this means that shell built-in functions such as echo hello or sleep 10 may have to be prefixed with an explicit shell command like this: $process = new Process('cmd /c echo hello', null, null, $pipes); $process->start($loop); Install The recommended way to install this library is through Composer. New to Composer? This will install the latest supported version: $ composer require react/child-process:^0.6.1 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. See above note for limited Windows Compatibility. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/PromiseStream.html":{"url":"4.Utility-Components/PromiseStream.html","title":"PromiseStream","keywords":"","body":"PromiseStream The missing link between Promise-land and Stream-land for ReactPHP. Table of Contents Usage buffer() first() all() unwrapReadable() unwrapWritable() Install Tests License Usage This lightweight library consists only of a few simple functions. All functions reside under the React\\Promise\\Stream namespace. The below examples assume you use an import statement similar to this: use React\\Promise\\Stream; Stream\\buffer(…); Alternatively, you can also refer to them with their fully-qualified name: \\React\\Promise\\Stream\\buffer(…); buffer() The buffer(ReadableStreamInterface $stream, ?int $maxLength = null): PromiseInterface function can be used to create a Promise which resolves with the stream data buffer. $stream = accessSomeJsonStream(); Stream\\buffer($stream)->then(function ($contents) { var_dump(json_decode($contents)); }); The promise will resolve with all data chunks concatenated once the stream closes. The promise will resolve with an empty string if the stream is already closed. The promise will reject if the stream emits an error. The promise will reject if it is cancelled. The optional $maxLength argument defaults to no limit. In case the maximum length is given and the stream emits more data before the end, the promise will be rejected with an \\OverflowException. $stream = accessSomeToLargeStream(); Stream\\buffer($stream, 1024)->then(function ($contents) { var_dump(json_decode($contents)); }, function ($error) { // Reaching here when the stream buffer goes above the max size, // in this example that is 1024 bytes, // or when the stream emits an error. }); first() The first(ReadableStreamInterface|WritableStreamInterface $stream, string $event = 'data'): PromiseInterface function can be used to create a Promise which resolves once the given event triggers for the first time. $stream = accessSomeJsonStream(); Stream\\first($stream)->then(function ($chunk) { echo 'The first chunk arrived: ' . $chunk; }); The promise will resolve with whatever the first event emitted or null if the event does not pass any data. If you do not pass a custom event name, then it will wait for the first \"data\" event and resolve with a string containing the first data chunk. The promise will reject if the stream emits an error – unless you're waiting for the \"error\" event, in which case it will resolve. The promise will reject once the stream closes – unless you're waiting for the \"close\" event, in which case it will resolve. The promise will reject if the stream is already closed. The promise will reject if it is cancelled. all() The all(ReadableStreamInterface|WritableStreamInterface $stream, string $event = 'data'): PromiseInterface function can be used to create a Promise which resolves with an array of all the event data. $stream = accessSomeJsonStream(); Stream\\all($stream)->then(function ($chunks) { echo 'The stream consists of ' . count($chunks) . ' chunk(s)'; }); The promise will resolve with an array of whatever all events emitted or null if the events do not pass any data. If you do not pass a custom event name, then it will wait for all the \"data\" events and resolve with an array containing all the data chunks. The promise will resolve with an array once the stream closes. The promise will resolve with an empty array if the stream is already closed. The promise will reject if the stream emits an error. The promise will reject if it is cancelled. unwrapReadable() The unwrapReadable(PromiseInterface $promise): ReadableStreamInterface function can be used to unwrap a Promise which resolves with a ReadableStreamInterface. This function returns a readable stream instance (implementing ReadableStreamInterface) right away which acts as a proxy for the future promise resolution. Once the given Promise resolves with a ReadableStreamInterface, its data will be piped to the output stream. //$promise = someFunctionWhichResolvesWithAStream(); $promise = startDownloadStream($uri); $stream = Stream\\unwrapReadable($promise); $stream->on('data', function ($data) { echo $data; }); $stream->on('end', function () { echo 'DONE'; }); If the given promise is either rejected or fulfilled with anything but an instance of ReadableStreamInterface, then the output stream will emit an error event and close: $promise = startDownloadStream($invalidUri); $stream = Stream\\unwrapReadable($promise); $stream->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage(); }); The given $promise SHOULD be pending, i.e. it SHOULD NOT be fulfilled or rejected at the time of invoking this function. If the given promise is already settled and does not resolve with an instance of ReadableStreamInterface, then you will not be able to receive the error event. You can close() the resulting stream at any time, which will either try to cancel() the pending promise or try to close() the underlying stream. $promise = startDownloadStream($uri); $stream = Stream\\unwrapReadable($promise); $loop->addTimer(2.0, function () use ($stream) { $stream->close(); }); unwrapWritable() The unwrapWritable(PromiseInterface $promise): WritableStreamInterface function can be used to unwrap a Promise which resolves with a WritableStreamInterface. This function returns a writable stream instance (implementing WritableStreamInterface) right away which acts as a proxy for the future promise resolution. Any writes to this instance will be buffered in memory for when the promise resolves. Once the given Promise resolves with a WritableStreamInterface, any data you have written to the proxy will be forwarded transparently to the inner stream. //$promise = someFunctionWhichResolvesWithAStream(); $promise = startUploadStream($uri); $stream = Stream\\unwrapWritable($promise); $stream->write('hello'); $stream->end('world'); $stream->on('close', function () { echo 'DONE'; }); If the given promise is either rejected or fulfilled with anything but an instance of WritableStreamInterface, then the output stream will emit an error event and close: $promise = startUploadStream($invalidUri); $stream = Stream\\unwrapWritable($promise); $stream->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage(); }); The given $promise SHOULD be pending, i.e. it SHOULD NOT be fulfilled or rejected at the time of invoking this function. If the given promise is already settled and does not resolve with an instance of WritableStreamInterface, then you will not be able to receive the error event. You can close() the resulting stream at any time, which will either try to cancel() the pending promise or try to close() the underlying stream. $promise = startUploadStream($uri); $stream = Stream\\unwrapWritable($promise); $loop->addTimer(2.0, function () use ($stream) { $stream->close(); }); Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/promise-stream:^1.2 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/PromiseTimer.html":{"url":"4.Utility-Components/PromiseTimer.html","title":"PromiseTimer","keywords":"","body":"PromiseTimer A trivial implementation of timeouts for Promises, built on top of ReactPHP. Table of contents Usage timeout() Timeout cancellation Cancellation handler Input cancellation Output cancellation Collections resolve() Resolve cancellation reject() Reject cancellation TimeoutException Install Tests License Usage This lightweight library consists only of a few simple functions. All functions reside under the React\\Promise\\Timer namespace. The below examples assume you use an import statement similar to this: use React\\Promise\\Timer; Timer\\timeout(…); Alternatively, you can also refer to them with their fully-qualified name: \\React\\Promise\\Timer\\timeout(…); timeout() The timeout(PromiseInterface $promise, $time, LoopInterface $loop) function can be used to cancel operations that take too long. You need to pass in an input $promise that represents a pending operation and timeout parameters. It returns a new Promise with the following resolution behavior: If the input $promise resolves before $time seconds, resolve the resulting promise with its fulfillment value. If the input $promise rejects before $time seconds, reject the resulting promise with its rejection value. If the input $promise does not settle before $time seconds, cancel the operation and reject the resulting promise with a TimeoutException. Internally, the given $time value will be used to start a timer that will cancel the pending operation once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. If the input $promise is already settled, then the resulting promise will resolve or reject immediately without starting a timer at all. A common use case for handling only resolved values looks like this: $promise = accessSomeRemoteResource(); Timer\\timeout($promise, 10.0, $loop)->then(function ($value) { // the operation finished within 10.0 seconds }); A more complete example could look like this: $promise = accessSomeRemoteResource(); Timer\\timeout($promise, 10.0, $loop)->then( function ($value) { // the operation finished within 10.0 seconds }, function ($error) { if ($error instanceof Timer\\TimeoutException) { // the operation has failed due to a timeout } else { // the input operation has failed due to some other error } } ); Or if you're using react/promise v2.2.0 or up: Timer\\timeout($promise, 10.0, $loop) ->then(function ($value) { // the operation finished within 10.0 seconds }) ->otherwise(function (Timer\\TimeoutException $error) { // the operation has failed due to a timeout }) ->otherwise(function ($error) { // the input operation has failed due to some other error }) ; Timeout cancellation As discussed above, the timeout() function will cancel the underlying operation if it takes too long. This means that you can be sure the resulting promise will then be rejected with a TimeoutException. However, what happens to the underlying input $promise is a bit more tricky: Once the timer fires, we will try to call $promise->cancel() on the input $promise which in turn invokes its cancellation handler. This means that it's actually up the input $promise to handle cancellation support. A common use case involves cleaning up any resources like open network sockets or file handles or terminating external processes or timers. If the given input $promise does not support cancellation, then this is a NO-OP. This means that while the resulting promise will still be rejected, the underlying input $promise may still be pending and can hence continue consuming resources. See the following chapter for more details on the cancellation handler. Cancellation handler For example, an implementation for the above operation could look like this: function accessSomeRemoteResource() { return new Promise( function ($resolve, $reject) use (&$socket) { // this will be called once the promise is created // a common use case involves opening any resources and eventually resolving $socket = createSocket(); $socket->on('data', function ($data) use ($resolve) { $resolve($data); }); }, function ($resolve, $reject) use (&$socket) { // this will be called once calling `cancel()` on this promise // a common use case involves cleaning any resources and then rejecting $socket->close(); $reject(new \\RuntimeException('Operation cancelled')); } ); } In this example, calling $promise->cancel() will invoke the registered cancellation handler which then closes the network socket and rejects the Promise instance. If no cancellation handler is passed to the Promise constructor, then invoking its cancel() method it is effectively a NO-OP. This means that it may still be pending and can hence continue consuming resources. For more details on the promise cancellation, please refer to the Promise documentation. Input cancellation Irrespective of the timeout handling, you can also explicitly cancel() the input $promise at any time. This means that the timeout() handling does not affect cancellation of the input $promise, as demonstrated in the following example: $promise = accessSomeRemoteResource(); $timeout = Timer\\timeout($promise, 10.0, $loop); $promise->cancel(); The registered cancellation handler is responsible for handling the cancel() call: A described above, a common use involves resource cleanup and will then reject the Promise. If the input $promise is being rejected, then the timeout will be aborted and the resulting promise will also be rejected. If the input $promise is still pending, then the timout will continue running until the timer expires. The same happens if the input $promise does not register a cancellation handler. Output cancellation Similarily, you can also explicitly cancel() the resulting promise like this: $promise = accessSomeRemoteResource(); $timeout = Timer\\timeout($promise, 10.0, $loop); $timeout->cancel(); Note how this looks very similar to the above input cancellation example. Accordingly, it also behaves very similar. Calling cancel() on the resulting promise will merely try to cancel() the input $promise. This means that we do not take over responsibility of the outcome and it's entirely up to the input $promise to handle cancellation support. The registered cancellation handler is responsible for handling the cancel() call: As described above, a common use involves resource cleanup and will then reject the Promise. If the input $promise is being rejected, then the timeout will be aborted and the resulting promise will also be rejected. If the input $promise is still pending, then the timout will continue running until the timer expires. The same happens if the input $promise does not register a cancellation handler. To re-iterate, note that calling cancel() on the resulting promise will merely try to cancel the input $promise only. It is then up to the cancellation handler of the input promise to settle the promise. If the input promise is still pending when the timeout occurs, then the normal timeout cancellation handling will trigger, effectively rejecting the output promise with a TimeoutException. This is done for consistency with the timeout cancellation handling and also because it is assumed this is often used like this: $timeout = Timer\\timeout(accessSomeRemoteResource(), 10.0, $loop); $timeout->cancel(); As described above, this example works as expected and cleans up any resources allocated for the input $promise. Note that if the given input $promise does not support cancellation, then this is a NO-OP. This means that while the resulting promise will still be rejected after the timeout, the underlying input $promise may still be pending and can hence continue consuming resources. Collections If you want to wait for multiple promises to resolve, you can use the normal promise primitives like this: $promises = array( accessSomeRemoteResource(), accessSomeRemoteResource(), accessSomeRemoteResource() ); $promise = \\React\\Promise\\all($promises); Timer\\timeout($promise, 10, $loop)->then(function ($values) { // *all* promises resolved }); The applies to all promise collection primitives alike, i.e. all(), race(), any(), some() etc. For more details on the promise primitives, please refer to the Promise documentation. resolve() The resolve($time, LoopInterface $loop) function can be used to create a new Promise that resolves in $time seconds with the $time as the fulfillment value. Timer\\resolve(1.5, $loop)->then(function ($time) { echo 'Thanks for waiting ' . $time . ' seconds' . PHP_EOL; }); Internally, the given $time value will be used to start a timer that will resolve the promise once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. Resolve cancellation You can explicitly cancel() the resulting timer promise at any time: $timer = Timer\\resolve(2.0, $loop); $timer->cancel(); This will abort the timer and reject with a RuntimeException. reject() The reject($time, LoopInterface $loop) function can be used to create a new Promise which rejects in $time seconds with a TimeoutException. Timer\\reject(2.0, $loop)->then(null, function (TimeoutException $e) { echo 'Rejected after ' . $e->getTimeout() . ' seconds ' . PHP_EOL; }); Internally, the given $time value will be used to start a timer that will reject the promise once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. This function complements the resolve() function and can be used as a basic building block for higher-level promise consumers. Reject cancellation You can explicitly cancel() the resulting timer promise at any time: $timer = Timer\\reject(2.0, $loop); $timer->cancel(); This will abort the timer and reject with a RuntimeException. TimeoutException The TimeoutException extends PHP's built-in RuntimeException. The getTimeout() method can be used to get the timeout value in seconds. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/promise-timer:^1.6 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "}}