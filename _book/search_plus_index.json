{"./":{"url":"./","title":"简介","keywords":"","body":" 事件驱动,非阻塞I/O的PHP ReactPHP是PHP中用于事件驱动编程的底层库。它的核心是一个事件循环，在此基础上它提供了底层实用程序，例如：流抽象、异步DNS解析器、网络客户端/服务器、HTTP客户端/服务器以及进程间通信。第三方库可以使用这些组件创建异步网络客户端/服务器等。 $loop = React\\EventLoop\\Factory::create(); $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); $socket = new React\\Socket\\Server(8080, $loop); $server->listen($socket); echo \"Server running at http://127.0.0.1:8080\\n\"; $loop->run(); 这个用ReactPHP编写的简单的Web服务器对每个请求都响应 \"Hello World\" ReactPHP是PHP中用于事件驱动编程的底层库。 核心是一个事件循环，它在其上提供底层实用程序， 例如：流抽象，异步DNS解析器，网络客户端/服务器，HTTP客户机/服务器和与进程的交互。 第三方库可以使用这些用于创建异步网络客户端/服务器等的组件。 ReactPHP已经可用于生产环境，并且经过来自世界各地的各种项目数百万次的安装测试。 由于事件驱动架构，使它非常适合高效的网络服务器和处理数百或数千个并发连接，长期运行的应用程序和许多其他无阻塞I / O操作的协作多任务形式。 ReactPHP之所以与众不同，是因为其活跃的生态系统具有数百个第三方库，可让您与许多现有系统集成 ，例如公共网络服务、数据库系统和其他第三方API。 生产就绪，并经过了实战测试。 稳固的，具有稳定的长期支持（LTS）版本。 不需要扩展，并且可以在任何平台上运行-没有任何借口！ 利用可选扩展来获得更好的性能（如果可用）。 强烈建议使用最新版本的PHP 7 +，以获得最佳性能和支持。 支持旧版PHP 5.3+和HHVM，以实现最大兼容性。 精心设计的和可重复使用的组件。 分离的零件，因此可以用其他实现方式替换它们。 经过测试（单位和功能）。 尽可能采用标准PSR，以实现最大的互操作性。 旨在“技术中立”，因此您可以使用首选的应用程序堆栈。 小型核心专业团队由外部贡献者的大型网络支持。 默认情况下，ReactPHP是非阻塞的，workers阻止I / O。 事件循环基于反应堆模式（因此命名），并且强烈受诸如EventMachine（Ruby），Twisted（Python）和 Node.js（V8）。 核心组件 EventLoop ReactPHP的核心反应器event-loop 文档 Stream 事件驱动的可读写流，用于ReactPHP中的非阻塞I / O 文档 Promise Promises/A 的PHP实现 文档 网络组件 Socket 异步，流式传输纯文本TCP / IP以及安全TLS套接字服务器和客户端连接 文档 Datagram 事件驱动的UDP客户端和服务器套接字 文档 协议组件 HTTP 事件驱动的流式纯文本HTTP和安全HTTPS服务器 文档 HTTPClient 事件驱动的HTTP流客户端 文档 DNS 异步DNS解析器 文档 实用组件 Cache 异步缓存 文档 ChildProcess 执行子进程的库。 文档 PromiseTimer ReactPHP的Promise库的简单超时实现。 文档 PromiseStream 在ReactPHP之上构建的Promise和Stream之间的衔接环节。 文档 "},"1.Core-Components/EventLoop.html":{"url":"1.Core-Components/EventLoop.html","title":"EventLoop","keywords":"","body":"EventLoop ReactPHP的核心事件循环，用于事件I/O 为了使基于异步的库可互操作，它们需要使用相同的事件循环。 该组件提供了一个任何库都可以定位的通用公共LoopInterface， 这使它们可以在同一循环中使用，并由用户控制一个 run()调用。 目录 快速开始 用法 Factory create() Loop implementations StreamSelectLoop ExtEventLoop ExtLibeventLoop ExtLibevLoop ExtEvLoop ExtUvLoop LoopInterface run() stop() addTimer() addPeriodicTimer() cancelTimer() futureTick() addSignal() removeSignal() addReadStream() addWriteStream() removeReadStream() removeWriteStream() 安装 测试 License 快速开始 这里是一个仅使用事件循环构建的异步HTTP服务器。 $loop = React\\EventLoop\\Factory::create(); $server = stream_socket_server('tcp://127.0.0.1:8080'); stream_set_blocking($server, false); $loop->addReadStream($server, function ($server) use ($loop) { $conn = stream_socket_accept($server); $data = \"HTTP/1.1 200 OK\\r\\nContent-Length: 3\\r\\n\\r\\nHi\\n\"; $loop->addWriteStream($conn, function ($conn) use (&$data, $loop) { $written = fwrite($conn, $data); if ($written === strlen($data)) { fclose($conn); $loop->removeWriteStream($conn); } else { $data = substr($data, $written); } }); }); $loop->addPeriodicTimer(5, function () { $memory = memory_get_usage() / 1024; $formatted = number_format($memory, 3).'K'; echo \"Current memory usage: {$formatted}\\n\"; }); $loop->run(); 查看示例. 用法 典型的应用程序：开始时创建的单个事件循环，程序结束时运行。 // [1] $loop = React\\EventLoop\\Factory::create(); // [2] $loop->addPeriodicTimer(1, function () { echo \"Tick\\n\"; }); $stream = new React\\Stream\\ReadableResourceStream( fopen('file.txt', 'r'), $loop ); // [3] $loop->run(); 在程序开始时创建循环实例React\\EventLoop\\Factory::create() 并选择最佳的可用循环实现. 2.循环实例可直接使用或传递给库和应用程序代码。 在此示例中，向事件循环注册了一个定期定时器，该循环每秒输出一次 Tick ， 并使用ReactPHPstream组件 创建可读流进行演示。 3.循环在程序最后通过单个$loop->run()运行。 Factory Factory 类是一个提供便捷创建循环实例的最佳类 事件循环实现. create() create()：LoopInterface 方法可用于创建新的事件循环 例子: $loop = React\\EventLoop\\Factory::create(); 该方法返回实现LoopInterface的实例，事件循环实现是一个具体实现。 该方法通常只能在程序开始时调用一次。 Loop implementations 除了LoopInterface之外，还有一些提供了事件循环实现。 所有事件循环都支持以下功能： 文件描述符轮询 一次性定时器 周期定时器 在未来循环中延迟执行 对于此软件包的大多数使用者而言，底层事件循环实现是具体实现。 您应该使用Factory自动创建一个新实例。 高级！ 如果您明确需要某个事件循环实现，则可以手动实例化以下类之一。 请注意，您可能必须为其安装相应的PHP扩展，否则它们将在创建时抛出 BadMethodCallException 异常。 StreamSelectLoop 基于stream_select()的事件循环。 使用stream_select() 函数，它是唯一一个使用PHP开箱即用的实现。 在php5.3到php7+和HHVM上，这个事件循环是开箱即用的。这意味着不需要额外安装其他扩展，而且这个库可以在所有支持的PHP的平台上工作。 因此，如果您没有安装下面列出的事件循环扩展， Factory将默认使用此事件循环。 在后台，它执行一个简单的 select 系统调用。 该系统调用限于 FD_SETSIZE 的最大文件描述符数量（取决于平台，通常为1024），并以 O(m) （ m 是传递的最大文件描述符数量）进行缩放。 这意味着在同时处理数千个流时，您可能会遇到问题，并且在这种情况下，您可能想研究使用下面列出的事件循环实现之一替代。 如果您的用例属于仅涉及一次处理数十个或几百个流，则此事件循环实现的执行效果非常好。 如果要使用信号处理（另请参阅下面的addSignal() ），此事件循环实现需要安装ext-pcntl扩展。 此扩展仅适用于类Unix平台，不支持Windows, 该扩展通常作为许多PHP发行版的一部分安装。 如果缺少此扩展名（或您正在Windows上运行），则不支持信号处理，将抛出BadMethodCallException异常。 PHP 7.3之前的版本，该事件循环都依赖于时钟时间来安排将来的定时器，因为单调时间源仅从PHP 7.3+ 可用（hrtime()）。 尽管这并不影响大部分应用程序，但这对于依赖于高时间精度的程序或受不连续时间调整（时间跳跃）影响的系统而言，是一个重要的区别。 这意味着，如果您安排一个定时器在PHP addTimer()。 ExtEventLoop 基于ext-event的事件循环。 使用event PECL extension 扩展，与libevent相同。 此循环可用于PHP 5.4到PHP 7+。 ExtEvLoop 基于ext-ev的事件循环。 使用 ev PECL extension 扩展，提供 libev 库的接口。 此循环可用于PHP 5.4到PHP 7+。 ExtUvLoop 基于ext-uv的事件循环。 使用 uv PECL extension 扩展， 提供 libuv 库的接口。 此循环可用于PHP 7+。 ExtLibeventLoop 基于ext-libevent的事件循环。 使用 libevent PECL extension 扩展。 libevent 本身支持许多特定于系统的后端（epoll，kqueue）。 此事件循环仅适用于PHP 5。 存在用于PHP 7 的版本 非正式更新 ，但已知由于SEGFAULT导致定期崩溃。 重申一下：不建议在PHP 7上使用此事件循环。 因此Factory将不会尝试在PHP 7上使用此事件循环。 已知只有在流变得可读（边缘触发）时才触发事件侦听器，并且如果从一开始就已经可读该流，则可能不会触发。 这也意味着，当数据仍留在PHP的内部流缓冲区中时，该流可能不被视为可读。 因此，在这种情况下，建议使用stream_set_read_buffer($stream, 0);禁用PHP的内部读取缓冲区。 另请参阅addReadStream()。 ExtLibevLoop 基于ext-libev的事件循环。 使用非正式的 libev 扩展名 扩展，与libevent相同。 此循环仅适用于PHP 5。 PHP 7的更新不太可能 LoopInterface run() 使用 run(): void 方法执行事件循环，直到没有任务执行为止。 对于大部分应用程序，该方法是事件循环上唯一直接可见的调用。 根据经验，通常建议将所有内容附加到同一循环实例，然后在应用程序的最底端运行一次循环。 $loop->run(); 此方法将使循环保持运行状态，直到没有其他任务可以执行为止。 换句话说：此方法将阻塞直到最后一个定时器，流 和/或 信号被删除为止。 同样，必须确保应用程序实际调用此方法一次。如果将侦听器添加到循环中而没有执行该方法，任何附加的监听器将不再等待，应用程序会直接退出。 循环已在运行时，不能调用此方法。此方法在显式调用stop()ped后或由于以前不再有任何操作而自动停止后，可能会被多次调用。 stop() 运行stop(): void方法将停止正在运行的事件循环。 此方法为高级用法，应小心使用。通常建议仅当循环不再有任何事情要做时才自动停止。 此方法用于显式指示事件循环停止： $loop->addTimer(3.0, function () use ($loop) { $loop->stop(); }); 对当前未运行的循环实例或已停止的循环实例调用此方法无效。 addTimer() addTimer(float $interval, callable $callback): TimerInterface 方法可用于将要在设定间隔（秒）后调用回调。 定时器回调函数必须能够接受单个参数，定时器实例也是由这个方法返回的，或者您可以使用一个完全没有参数的函数。 定时器回调函数不能抛出Exception。 定时器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 与addPeriodicTimer()不同，此方法将确保在设定间隔（秒）后只调用一次回调。 您可以调用cancelTimer来取消挂起的定时器。 $loop->addTimer(0.8, function () { echo 'world!' . PHP_EOL; }); $loop->addTimer(0.3, function () { echo 'hello '; }); 示例#1. 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： function hello($name, LoopInterface $loop) { $loop->addTimer(1.0, function () use ($name) { echo \"hello $name\\n\"; }); } hello('Tester', $loop); 此接口不强制任意间隔的定时器，因此如果您依赖毫秒或以下的非常高的精度，可能需要特别小心。除非另有说明，否则事件循环实现应尽力提供高精度间隔，并应至少提供毫秒精度。 已知许多现有的事件循环实现提供微秒精度，但通常不建议依赖这种高精度。 类似地，不能保证在同一时间（在其可能的精度范围内）被调度执行的定时器的执行顺序。 此接口建议事件循环实现应使用单调时间源（如果可用）。假设单调时间源在默认情况下仅在php7.3中可用，那么事件循环实现可能会退回到使用挂钟时间。 虽然这不会影响许多常见的用例，但对于依赖高时间精度或受不连续时间调整（时间跳跃）影响的系统的程序来说，这是很重要的一点。 这意味着如果你安排一个定时器在30秒后触发，然后调整你的系统时间向前20秒，定时器仍应在30秒后触发。 有关详细信息，请参阅事件循环实现 addPeriodicTimer() addPeriodicTimer(float $interval, callable $callback): TimerInterface 方法可用于将要在设定间隔（秒）后重复调用的回调。 定时器回调函数必须能够接受单个参数，定时器实例也是由这个方法返回的，或者您可以使用一个完全没有参数的函数。 定时器回调函数不能抛出Exception。 定时器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 与addTimer()不同，此方法将确保在设定间隔（秒）后重复调用回调。 您可以调用cancelTimer来取消挂起的定时器。 $timer = $loop->addPeriodicTimer(0.1, function () { echo 'tick!' . PHP_EOL; }); $loop->addTimer(1.0, function () use ($loop, $timer) { $loop->cancelTimer($timer); echo 'Done' . PHP_EOL; }); 示例#2. 如果要限制执行次数，可以将控制变量通过use绑定的回调闭包中，如下所示： function hello($name, LoopInterface $loop) { $n = 3; $loop->addPeriodicTimer(1.0, function ($timer) use ($name, $loop, &$n) { if ($n > 0) { --$n; echo \"hello $name\\n\"; } else { $loop->cancelTimer($timer); } }); } hello('Tester', $loop); 此接口不强制任意间隔的定时器，因此如果您依赖毫秒或以下的非常高的精度，可能需要特别小心。除非另有说明，否则事件循环实现应尽力提供高精度间隔，并应至少提供毫秒精度。 已知许多现有的事件循环实现提供微秒精度，但通常不建议依赖这种高精度。 类似地，不能保证在同一时间（在其可能的精度范围内）被调度执行的定时器的执行顺序。 此接口建议事件循环实现应使用单调时间源（如果可用）。假设单调时间源在默认情况下仅在php7.3中可用，那么事件循环实现可能会退回到使用挂钟时间。 虽然这不会影响许多常见的用例，但对于依赖高时间精度或受不连续时间调整（时间跳跃）影响的系统的程序来说，这是很重要的一点。 这意味着如果你安排一个定时器在30秒后触发，然后调整你的系统时间向前20秒，定时器仍应在30秒后触发。 有关详细信息，请参阅事件循环实现 此外，由于每次调用后都要进行重新调度，周期性定时器可能会发生定时器漂移。 因此，通常不建议在毫秒级或以下的高精度间隔中使用此方法。 cancelTimer() cancelTimer(TimerInterface $timer): void 方法可用于取消待处理的定时器。 addPeriodicTimer() 示例#2. 对没有添加到循环实例的定时器或已取消的定时器调用此方法无效。 futureTick() futureTick(callable $listener): void 方法可用于安排在事件循环的未来时刻调用的回调。 这与间隔为 0 秒的定时器非常相似，但是它不会被插入定时器队列中，进而减少队列开销。 tick回调函数必须能够接受零参数。tick回调函数不抛出Exception。 tick回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： function hello($name, LoopInterface $loop) { $loop->futureTick(function () use ($name) { echo \"hello $name\\n\"; }); } hello('Tester', $loop); 与定时器不同，tick回调保证按其入队的顺序执行。同样，一旦将回调放入队列，就无法取消此操作。 这通常用于将较大的任务分解为较小的步骤（一种协作式多任务处理形式）。 $loop->futureTick(function () { echo 'b'; }); $loop->futureTick(function () { echo 'c'; }); echo 'a'; 示例#3. addSignal() addSignal(int $signal, callable $listener): void 方法可用于注册一个侦听器，以便在此过程捕获到信号时得到通知。 这对于从supervisor 或 systemd之类的工具捕获用户中断信号或关闭信号很有用。 通过此方法添加的信号，侦听器回调函数必须能够接受单个参数或者您可以使用完全不带参数的函数。 侦听器回调函数不得抛出 Exception 监听器回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 $loop->addSignal(SIGINT, function (int $signal) { echo 'Caught user interrupt signal' . PHP_EOL; }); 示例#4. 信号仅在类似Unix的平台上可用，由于操作系统限制，不支持Windows。 如果此平台不支持信号，例如缺少所需的扩展名，则此方法可能抛出BadMethodCallException。 注意 ：一个监听器只能添加到同一信号一次，多次添加将被忽略。 removeSignal() removeSignal(int $signal, callable $listener): void 方法可用于删除先前添加的信号监听器。 $loop->removeSignal(SIGINT, $listener); 删除未注册的监听器将被忽略。 addReadStream() 高级！ 请注意，此底层API被视为高级用法。 大多数用例可能应该使用更高级别的API来替代 可读流API addReadStream(resource $stream, callable $callback): void 方法可用于注册侦听器，以便在流准备好读取时收到通知。 第一个参数必须是一个有效的流资源，它支持检查循环实现是否可以读取它。 单个流资源不能添加多次。 但可以先调用removeReadStream()，或者使用单个侦听器对此事件做出反应，然后从此侦听器中进行调度。如果循环实现不支持给定的资源类型，则此方法可能引发Exception 添加的流资源侦听器回调函数必须能够接受单个参数或者您可以使用完全没有参数的函数。 侦听器回调函数不能抛出Exception 侦听器回调函数的返回值将被忽略，并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： $loop->addReadStream($stream, function ($stream) use ($name) { echo $name . ' said: ' . fread($stream); }); 示例#11. 您可以调用 removeReadStream() 删除此流的读取事件侦听器。 无法保证多个流同时准备就绪时侦听器的执行顺序。 某些事件循环实现仅在流变得可读（边缘触发）时才触发侦听器，并且如果从一开始就已经可读该流，则可能不会触发。 这也意味着，当数据仍留在PHP的内部流缓冲区中时，该流可能不被视为可读。 在这种情况下，建议使用stream_set_read_buffer($stream, 0);禁用PHP的内部读取缓冲区。 addWriteStream() 高级！ 请注意，此底层API被视为高级用法。大多数用例可能应该使用更高级别的API替代可写流API addWriteStream(resource $stream, callable $callback): void 方法可用于注册一个侦听器，以便在流准备好写入时得到通知。 第一个参数务必是有效的流资源，它支持检查是否已准备好通过此循环实现进行写入。 单个流资源不得多次添加。 相反，请先调用removeWriteStream()或使用单个侦听器对此事件做出反应，然后从该事件进行分派监听。 如果此循环实现不支持给定的资源类型，则此方法可以抛出 Exception 添加的流资源侦听器回调函数必须能够接受单个参数或者您可以使用完全没有参数的函数。 侦听器回调函数不得抛出Exception 监听器回调函数的返回值将被忽略并且不起作用，因此出于性能原因，建议您不要返回任何过多的数据结构。 如果要在回调函数中访问变量，可以将任意数据变量通过 use 绑定到回调闭包中，如下所示： $loop->addWriteStream($stream, function ($stream) use ($name) { fwrite($stream, 'Hello ' . $name); }); 示例#12. 您可以调用 removeWriteStream() 删除此流的写入事件侦听器。 无法保证多个流同时准备就绪时侦听器的执行顺序。 removeReadStream() removeReadStream(resource $stream): void 方法可用于删除给定流的可读事件监听器。 从循环中删除已删除的流，或尝试删除从未添加过或无效的流时此方法无效。 removeWriteStream() removeWriteStream(resource $stream): void 方法可用于删除给定流的可写事件监听器。 从循环中删除已删除的流，或尝试删除从未添加过或无效的流时此方法无效。 安装 推荐安装 通过Composer. Composer新手? 该项目遵循 SemVer. 这将安装最新的受支持版本： $ composer require react/event-loop:^1.1.1 另请参阅 CHANGELOG ，以获取有关版本升级的详细信息。 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈建议在这个项目中使用PHP7+。 建议安装任何一个事件循环扩展，但完全是可选的。 有关详细信息，请参阅事件循环实现 测试 要运行测试套件，首先需要克隆此存储库，然后安装所有依赖项 通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行： $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"1.Core-Components/Promise.html":{"url":"1.Core-Components/Promise.html","title":"Promise","keywords":"","body":"Promise PHP的 CommonJS Promises/A 的轻量级实现。 主分支包含即将发布的3.0版本的代码。 对于当前稳定的2.x版本的代码，请检查 2.x分支 即将发布的3.0版本将是此软件包的主发展方向。 但是，对于尚未安装PHP 7+的用户，我们仍将积极支持2.0和1.0。 目录 简介 概念 Deferred（延迟） Promise（承诺） API Deferred Deferred::promise() Deferred::resolve() Deferred::reject() PromiseInterface PromiseInterface::then() PromiseInterface::done() PromiseInterface::otherwise() PromiseInterface::always() PromiseInterface::cancel() Promise Functions resolve() reject() all() race() any() some() map() reduce() PromisorInterface 示例 如何使用Deferred 承诺转发的工作原理 转发履行 转发拒绝 转发履行和拒绝 done() vs. then() Credits License 简介 Promise是一个为PHP实现CommonJS Promises/A 的库。 它还提供了其他一些与承诺相关的有用概念，例如加入多个承诺以及映射和减少承诺集合。 如果您以前从未听说过诺言，请先阅读此内容 概念 Deferred（延迟） Deferred 表示可能尚未完成的计算或工作单元。 通常（但并非总是）该计算将异步执行并在将来的某个时刻完成。 Promise（承诺） Deferred 表示计算本身，而 Promise 表示该计算的结果。 因此，每个Deferred 者都有一个承诺，可以充当其实际结果的占位符。 API Deferred Deferred 表示其解析挂起的操作。它有单独的promise和resolver部分。 $deferred = new React\\Promise\\Deferred(); $promise = $deferred->promise(); $deferred->resolve(mixed $value = null); $deferred->reject(\\Throwable $reason); promise 方法返回延迟的承诺。 resolve和reject 方法控制延迟状态。 Deferred的构造函数接受一个可选的$canceller参数。有关更多信息，请参阅Promise Deferred::promise() $promise = $deferred->promise(); 返回延期的承诺，您可以将其分发给其他人，同时保留自行修改其状态的权限。 Deferred::resolve() $deferred->resolve(mixed $value = null); 解决promise()返回的承诺。 $value调用 $onFulfilled来通知所有消费者（它们通过$promise->then() 注册）。 如果$value本身是一个承诺，那么一旦这个承诺被解决，它将转换到这个承诺的状态。 Deferred::reject() $deferred->reject(\\Throwable $reason); 拒绝promise()返回的承诺，表示延迟的计算失败。 所有消费者都会收到通知，方法是使用$reason调用$onRejected（它们通过$promise->then()注册）。 PromiseInterface PromiseInterface 为所有promise实现提供公共接口。 请参阅Promise以获取此包唯一公共实现。 一个承诺代表一个最终的结果，要么是实现（成功）和相关的结果，要么是拒绝（失败）和相关的原因。 一旦承诺处于履行或拒绝的状态，承诺就变得不可更改。 它的状态和结果（或错误）都不能修改。 PromiseInterface::then() $transformedPromise = $promise->then(callable $onFulfilled = null, callable $onRejected = null); 通过对承诺的履行或拒绝的结果，应用函数来转换承诺的状态值并返回转换结果的新承诺。 then() 方法用于一个promise注册新的已完成和拒绝处理程序（所有参数都是可选的）： 一旦承诺实现，其结果将作为第一个参数传递，就会调用$onFulfilled 一旦承诺被拒绝，其原因作为第一个参数传递，就会调用$onRejected $onFulfilled或$onRejected的返回一个新的promise，无论哪个被调用，或者其中一个抛出异常则抛出异常。 promise 对在then()的同一调用中注册的处理回调做出以下保证： 1.仅会调用$onFulfilled 或 $onRejected中的一个，两者不会都调用。 2.$onFulfilled 和 $onRejected 不会被调用一次以上。 另请参阅 resolve() - 创造承诺 reject() - 创建拒绝的承诺 PromiseInterface::done() done() vs. then() PromiseInterface::done() $promise->done(callable $onFulfilled = null, callable $onRejected = null); 如果承诺履行或拒绝，则耗费承诺的最终结果。 如果 $onFulfilled 或 $onRejected抛出或返回被拒绝的诺言，将导致致命错误(E_USER_ERROR) 由于done()的目的是消费而不是转换，所以done()总是返回null。 另请参阅 PromiseInterface::then() done() vs. then() PromiseInterface::otherwise() $promise->otherwise(callable $onRejected); 注册拒绝处理程序以进行承诺。 快捷操作方式如下： $promise->then(null, $onRejected); 另外，您可以传入提示$onRejected的$reason参数，仅捕获特定的错误。 $promise ->otherwise(function (\\RuntimeException $reason) { // Only catch \\RuntimeException instances // All other types of errors will propagate automatically }) ->otherwise(function (\\Throwable $reason) { // Catch other errors )}; PromiseInterface::always() $newPromise = $promise->always(callable $onFulfilledOrRejected); 允许您在承诺链中执行“清理”类型的任务。 当promise被履行或被拒绝时调用$onFulfilledOrRejected(不带任何参数)回调 如果$promise履行，并且$onFulfilledOrRejected成功返回，则$newPromise履行与$promise相同的值。 如果$promise履行，并且$onFulfilledOrRejected抛出或返回被拒绝的承诺，$newPromise将抛出的异常或拒绝的承诺的原因。 如果$promise拒绝，并且$onFulfilledOrRejected成功返回，则$newPromise与$promise以相同的原因拒绝。 如果$promise拒绝，并且$onFulfilledOrRejected抛出或返回被拒绝的承诺，$newPromise将抛出的异常或拒绝的承诺的原因。 always()的行为于synchronous finally语句类似。当与otherwise()结合使用时，always()允许您编写于熟悉的同步catch/finally类似的代码。 考虑以下同步代码： try { return doSomething(); } catch (\\Throwable $e) { return handleError($e); } finally { cleanup(); } 可以编写类似的异步代码（doSomething()返回承诺）： return doSomething() ->otherwise('handleError') ->always('cleanup'); PromiseInterface::cancel() $promise->cancel(); cancel() 方法通知承诺创建者对操作的结果不再感兴趣。 一旦兑现了承诺（无论是履行还是拒绝），对承诺调用cancel()无效。 Promise 创建一个promise，其状态由传$resolver函数控制。 $resolver = function (callable $resolve, callable $reject) { // Do some work, possibly asynchronously, and then // resolve or reject. $resolve($awesomeResult); // or throw new Exception('Promise rejected'); // or $resolve($anotherPromise); // or $reject($nastyError); }; $canceller = function () { // Cancel/abort any running operations like network connections, streams etc. // Reject promise by throwing an exception throw new Exception('Promise cancelled'); }; $promise = new React\\Promise\\Promise($resolver, $canceller); promise构造函数将接收一个resolver函数和一个可选的canceller函数，这两个函数都将使用3个参数进行调用： $resolve($value) - 包装返回的promise的主要函数。 接受非承诺值或其他承诺。 当用非承诺值调用时，用该值实现承诺。当以另一个承诺被调用时， 例如 $resolve($otherPromise)，包装返回的promise等同于$otherPromise。 $rejec($reason) - 拒绝承诺的函数。建议只抛出异常，而不要使用$reject()。 如果resolver或canceller抛出异常，则将以该抛出的异常作为拒绝原因来拒绝承诺。 resolver函数将立即被调用，只有当所有使用者调用promise的cancel()方法时，canceller函数才会被调用。 Functions 用于创建、连接、映射和减少承诺集合的有用函数。 所有处理承诺集合的功能（例如all()，race()，some()等）都支持取消。 这意味着，如果您对返回的诺言调用cancel()，则集合中的所有诺言都会被取消。 resolve() $promise = React\\Promise\\resolve(mixed $promiseOrValue); 为$promiseOrValue创建一个承诺。 如果$promiseOrValue是一个值，它将是返回承诺 如果$promiseOrValue拥有thenable能力（提供then()方法的对象），则返回跟随thenable状态的可信承诺。 如果$promiseOrValue是一个承诺，它将按原样返回。 reject() $promise = React\\Promise\\reject(\\Throwable $reason); 为$reason创建一个拒绝的promise。 注意\\Throwable PHP7中引入的接口包括两个用户区域 \\Exception 和 \\Error 内部PHP错误。 通过强制使用\\Throwable作为拒绝承诺的理由，任何语言错误或用户地异常都可以用来拒绝承诺。 all() $promise = React\\Promise\\all(array $promisesOrValues); 返回一个承诺，该承诺仅在$promisesOrValues中的所有项都已解析时才会解析。 返回的承诺的解析值将是一个数组，其中包含$promisesOrValues中每个项的解析值。 race() $promise = React\\Promise\\race(array $promisesOrValues); 发起一场允许一名获胜者参加的竞赛。返回一个承诺，该承诺的解决方式与第一个履行的承诺解决方式相同。 如果$promisesOrValues包含0项，则返回的承诺将无限挂起。 any() $promise = React\\Promise\\any(array $promisesOrValues); 返回将在$promisesOrValues中的任何一项兑现的承诺。返回的承诺的值将是触发项的值。 只有在$promisesOrValues中的 所有 项被拒绝时，返回的承诺才会被拒绝。 拒绝值将是React\\Promise\\Exception\\CompositeException，其中包含所有拒绝原因。 拒绝原因可以通过CompositeException::getThrowables()获得。 如果$promisesOrValues包含0项，则返回的承诺也将拒绝， 并带有React\\Promise\\Exception\\LengthException some() $promise = React\\Promise\\some(array $promisesOrValues, integer $howMany); 返回一个承诺，当$promisesOrValues中至少有$howMany个提供的项兑现时，该承诺将被兑现。 返回的承诺的值将是一个长度为$howMany的数组，该数组包含首先解析的$howMany已兑现承诺的值。 如果$howMany项无法兑现（即(count($promisesOrValues)-$howMany)+1项拒绝）， 则返回的承诺将拒绝。拒绝值将是一个React\\Promise\\Exception\\CompositeException, 其中包含(count($promisesOrValues)-$howMany)+1拒绝原因。 拒绝原因可以通过CompositeException::getExceptions()获得。 如果$promisesOrValues包含的项目少于$howMany，则返回的承诺也将被拒绝， 并带有React\\Promise\\Exception\\LengthException。 map() $promise = React\\Promise\\map(array $promisesOrValues, callable $mapFunc); 传统的map函数，类似于array_map()，但允许输入包含承诺 和/或 值，$mapFunc可以返回值或承诺。 map函数接收每个项作为参数，其中item是$promisesOrValues中的promise或value的完全解析值。 reduce() $promise = React\\Promise\\reduce(array $promisesOrValues, callable $reduceFunc, $initialValue = null); 传统的reduce函数，类似于array_reduce()，但输入可以包含承诺 和/或 值， $reduceFunc可以返回值或承诺 和 $initialValue可以是承诺或起始值。 PromisorInterface React\\Promise\\PromisorInterface提供实现承诺的公共接口。 React\\Promise\\Deferred实现了它，但是由于它是公共API的一部分，任何人都可以实现它。 示例 如何使用Deferred function getAwesomeResultPromise() { $deferred = new React\\Promise\\Deferred(); // Execute a Node.js-style function using the callback pattern computeAwesomeResultAsynchronously(function (\\Throwable $error, $result) use ($deferred) { if ($error) { $deferred->reject($error); } else { $deferred->resolve($result); } }); // Return the promise return $deferred->promise(); } getAwesomeResultPromise() ->then( function ($value) { // Deferred resolved, do something with $value }, function (\\Throwable $reason) { // Deferred rejected, do something with $reason } ); 承诺转发的工作原理 几个简单的例子来展示promise/A转发机制是如何工作的。 当然，这些示例是精心设计的，在实际使用中，承诺链通常会分布在几个函数调用中，甚至是应用程序架构的几个级别。 转发履行 已履行承诺将值转发给下一个承诺。 第一个承诺$deferred->promise()将用下面传递给$deferred->resolve()的值来进行解析。 每次调用then()都会返回一个新的承诺，该承诺将使用前一个处理程序的返回值进行解析。这里创建了一个承诺“管道”。 $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { // $x will be the value passed to $deferred->resolve() below // and returns a *new promise* for $x + 1 return $x + 1; }) ->then(function ($x) { // $x === 2 // This handler receives the return value of the // previous handler. return $x + 1; }) ->then(function ($x) { // $x === 3 // This handler receives the return value of the // previous handler. return $x + 1; }) ->then(function ($x) { // $x === 4 // This handler receives the return value of the // previous handler. echo 'Resolve ' . $x; }); $deferred->resolve(1); // Prints \"Resolve 4\" 转发拒绝 被拒绝的承诺的行为与try/catch类似，工作方式也与此类似:当你捕获一个异常时，你必须重新抛出进而继续向下传播。 同样，当您处理被拒绝的承诺时且传播拒绝，需通过返回被拒绝的承诺或实际抛出“重新抛出”它（因为promise将抛出的异常转换为拒绝） $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { throw new \\Exception($x + 1); }) ->otherwise(function (\\Exception $x) { // Propagate the rejection throw $x; }) ->otherwise(function (\\Exception $x) { // Can also propagate by returning another rejection return React\\Promise\\reject( new \\Exception($x->getMessage() + 1) ); }) ->otherwise(function ($x) { echo 'Reject ' . $x->getMessage(); // 3 }); $deferred->resolve(1); // Prints \"Reject 3\" 转发履行和拒绝 就像try/catch一样，您可以选择是否传播。转发履行和拒绝仍将以可预测的方式转发回调结果。 $deferred = new React\\Promise\\Deferred(); $deferred->promise() ->then(function ($x) { return $x + 1; }) ->then(function ($x) { throw new \\Exception($x + 1); }) ->otherwise(function (\\Exception $x) { // Handle the rejection, and don't propagate. // This is like catch without a rethrow return $x->getMessage() + 1; }) ->then(function ($x) { echo 'Mixed ' . $x; // 4 }); $deferred->resolve(1); // Prints \"Mixed 4\" done() vs. then() 黄金法则是： 返回您的诺言，或调用done()方法. 乍一看，then() 和 done()看起来非常相似。 但是，有重要的区别。 then()的目的是转换promise的值，并将转换后的值传递或返回一个新的promise到代码的其他部分。 done()的目的是消费promise的值，并将转换后的值转移到代码中。 除了转换值之外，then()还允许您从中间错误中恢复或传播。 未处理的任何错误都将由Promise机制捕获，并用于拒绝then()返回的承诺。 调用done()将错误的所有责任转移到代码中。 如果错误（抛出的异常或返回的拒绝）未能在您提供done()的$onFulfilled 或 $onRejected回调中捕获，它将导致致命错误。 function getJsonResult() { return queryApi() ->then( // Transform API results to an object function ($jsonResultString) { return json_decode($jsonResultString); }, // Transform API errors to an exception function ($jsonErrorString) { $object = json_decode($jsonErrorString); throw new ApiErrorException($object->errorMessage); } ); } // Here we provide no rejection handler. If the promise returned has been // rejected, the ApiErrorException will be thrown getJsonResult() ->done( // Consume transformed object function ($jsonResultObject) { // Do something with $jsonResultObject } ); // Here we provide a rejection handler which will either throw while debugging // or log the exception getJsonResult() ->done( function ($jsonResultObject) { // Do something with $jsonResultObject }, function (ApiErrorException $exception) { if (isDebug()) { throw $exception; } else { logException($exception); } } ); Credits 承诺是 when.js 的一部分，作者Brian Cavalier. 而且，大部分文档都是来源于when.js Wiki 和 API docs. License Released under the MIT license. "},"1.Core-Components/Stream.html":{"url":"1.Core-Components/Stream.html","title":"Stream","keywords":"","body":"Stream 事件驱动的可读流和可写流，用于 ReactPHP 中的非阻塞I/O 为了使 EventLoop 更容易使用，该组件引入了强大的“流”概念。 流允许您以小块的方式高效地处理大量数据(比如一个多GB的文件下载)，而不必一次将所有数据存储在内存中。 与PHP中的流非常相似，但有一个更适合异步、非阻塞I/O的接口。 目录 Stream用法 ReadableStreamInterface data事件 end事件 error事件 close事件 isReadable() pause() resume() pipe() close() WritableStreamInterface drain事件 pipe事件 error事件 close事件 isWritable() write() end() close() DuplexStreamInterface Creating streams ReadableResourceStream WritableResourceStream DuplexResourceStream ThroughStream CompositeStream 用法 安装 测试 License More stream用法 ReactPHP在其整个生态系统中使用“流”的概念，为处理任意数据内容和大小的流提供一致的高级抽象。 虽然流本身是一个非常底层的概念，但它可以作为一个强大的抽象来构建更高级的组件和协议。 如果你不熟悉这个概念，可以把它们想象成水管(pipe): 你可以从一个水源中取水，也可以产生水并将其输送到任何目的地水槽(sink)。 同样，流可以是 可读(如STDIN终端输入)或 可写(如STDOUT终端输出)或 双工(既可读又可写，例如TCP/IP连接) 因此，这个包定义了以下三个接口 ReadableStreamInterface WritableStreamInterface DuplexStreamInterface ReadableStreamInterface ReadableStreamInterface 负责为只读流和双工流的可读端。 除了定义一些方法之外，这个接口还实现了EventEmitterInterface允许你对特定的事件做出响应。 事件回调函数必须是一个有效的 callable ，遵守严格的参数定义，并且必须完全按照文档中描述的那样接受事件参数。 事件回调函数绝不能抛出Exception。 事件回调函数的返回值将被忽略，并且没有任何效果，因此出于性能原因，建议您不要返回任何过多的数据结构。 这个接口的每个实现都必须遵循这些事件语义，才能被认为是合法的流。 请注意，此接口的高级实现可能会选择使用专用语义来定义附加事件， 这些专用语义未定义为此低级流规范的一部分。 与这些事件语义的一致性超出了此接口的范围， 因此您可能还必须参考此类更高级别实现的文档。 data事件 当从该源流读取/接收数据时，将触发data事件。事件接收传入数据的单个混合参数。 $stream->on('data', function ($data) { echo $data; }); 该事件可能被触发任意次，如果该流根本不发送任何数据，则可能为零次。 在end或close事件之后不应该触发它。 给定的$data参数可能是混合类型，但通常建议它应该是string值， 或者可以使用允许表示为string的类型，以实现最大的兼容性。 许多常见流(如TCP/IP连接或基于文件的流)将发出原始(二进制)有效负载数据， 这些数据通过网络接收为string值块。 由于这种基于流的特性，发送方可以发送任意数量不同大小的块。 不能保证接收到的数据块与发送方打算发送的帧完全相同。 换句话说，许多底层协议(如TCP/IP)以块的形式传输数据， 这些块可能介于单字节到几十千字节之间。 为了实现正确的消息帧，您可能需要对这些数据块应用更高级别的协议。 end事件 源流成功到达流尾(EOF)后，将触发end事件。 $stream->on('end', function () { echo 'END'; }); 该事件最多触发一次，或者根本不触发，这取决于是否检测到成功结束。 它不应该在前一个end或close事件之后触发。 如果流未成功结束而关闭（例如在前一个close事件之后），则不能触发该事件。 流结束后，必须切换到不可读模式，另请参见isReadable() 只有成功到达end时才会触发此事件，如果流被不可恢复的错误中断或显式关闭则不会触发此事件。 并不是所有的流都知道“成功的结束”这个概念。 许多用例涉及检测流何时关闭(终止)，在这种情况下，您应该使用close事件。 流发出end事件后，通常应该跟在close事件后面。 如果远程端关闭连接或成功读取文件句柄直到其结束(EOF)，许多公共流（如TCP/IP连接或基于文件的流）都将发出此事件。 请注意，不应将此事件与end()方法混淆。 此事件定义从源流读取的成功结束，而end()方法定义向目标流写入的成功结束。 error事件 通常是在尝试从该流读取时发生致命错误，则会触发error事件。 事件为错误实例接收一个Exception参数。 $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); 一旦流检测到致命错误（如致命的传输错误）或意外的data或过早的end事件之后，就会触发此事件。 它不应在前一个error, end 或 close事件之后触发。 如果这不是致命的错误情况，例如没有导致任何数据丢失的临时网络问题，则不会触此事件。 出现流错误后，它必须关闭流，因此后面应该有一个close事件， 然后切换到不可读模式，另请参见close()和isReadable()。 许多常见的流（例如TCP/IP连接或基于文件的流）只处理数据传输， 并不对数据边界进行假设（例如意外的data或过早的end事件）。 换言之，许多较底层的协议（例如TCP/IP）可能会选择只在出现致命传输错误时触发事件，并在响应时关闭(终止)流。 如果这个流是DuplexStreamInterface，你也应该注意到流的可写端也实现了error事件。 换句话说，在读取或写入流时可能发生错误，这应该导致相同的错误处理。 close事件 一旦流关闭（终止），将触发close事件。 $stream->on('close', function () { echo 'CLOSED'; }); 根据流是否终止，这个事件应该被触发一次，或者根本不触发。 它不应该在前一个close事件之后触发。 流关闭后，必须切换到不可读模式， 另请参见isReadable()。 与end事件不同，每当流关闭时都应触发此事件，而不管此事件是由于不可恢复的错误隐式发生的，还是在任何一方关闭流时显式发生的。 如果只想检测成功结束，则应改用end事件。 许多常见的流（例如TCP / IP连接或基于文件的流）很可能在读取成功结束事件或致命的传输错误事件之后选择触发此事件。 如果此流是DuplexStreamInterface，则您还应该注意该流的可写端close事件的实现。 换句话说，在接收到该事件之后，流必须切换到不可写和不可读取模式，另请参见 isWritable()。 注意，该事件不应与end事件混淆。 isReadable() isReadable(): bool方法可用于检查此流是否处于可读状态（尚未关闭）。 此方法可用于检查流是否仍然接受传入的数据事件，或者它是否已结束或关闭。 一旦流不可读，就不再发出data或end事件。 assert($stream->isReadable() === false); $stream->on('data', assertNeverCalled()); $stream->on('end', assertNeverCalled()); 成功打开的流始终必须以可读模式启动。 一旦流结束或关闭，它必须切换到非可读模式。 这可以随时发生，通过close()显式地发生，或者由于远程关闭或不可恢复的传输错误而隐式地发生。 流一旦切换到非可读模式，就绝不能回到可读模式。 如果此流是DuplexStreamInterface，则您还应该注意该流的可写端isWritable()方法的实现。 除非这是一个半开双工流，否则它们通常应该具有相同的返回值。 pause() pause(): void方法可用于暂停读取传入的数据事件。 从事件循环中删除数据源文件描述符。 这使您可以限制传入的数据。 除非另有说明，否则成功打开的流不应暂停。 流暂停后，就不应再触发data或end事件 $stream->pause(); $stream->on('data', assertShouldNeverCalled()); $stream->on('end', assertShouldNeverCalled()); 该方法仅是建议性的，通常不建议调用，但该流可以继续emit(发出)data事件。 您可以通过再次调用resume()来继续处理事件。 注意，这两种方法都可以被调用多次，多次调用pause()无效。 另见resume() resume() resume(): void 方法可用于恢复data事件。 在pause()之后重新连接数据源。 $stream->pause(); $loop->addTimer(1.0, function () use ($stream) { $stream->resume(); }); 请注意，这两个方法都可以被调用任意次数，在没有pause()的情况下调用resume()无效。 请参见pause() pipe() pipe(WritableStreamInterface $dest, array $options = []) 方法可将此可读源中的所有数据通过管道传输到给定的可写目标源。 自动将所有传入数据发送到目标源。根据目标源可以处理的内容自动限制源。 $source->pipe($dest); 同样，您也可以通过管道将实现DuplexStreamInterface的实例导入自身，以便回写接收到的所有数据。 对于TCP/IP echo服务，这是一个有用的特性: $connection->pipe($connection); 这个方法按原样返回目标流，可以用来建立管道流链: $source->pipe($decodeGzip)->pipe($filterBadWords)->pipe($dest); 默认情况下，一旦源流发出end()事件，就会对目标流调用end()。可以这样禁用： $source->pipe($dest, array('end' => false)); 请注意，这只适用于end事件。 如果源流上发生 error 或显式close事件，则您必须手动关闭目标流： $source->pipe($dest); $source->on('close', function () use ($dest) { $dest->end('BYE!'); }); 如果源流不可读（关闭状态），则这是不可操作的。 $source->close(); $source->pipe($dest); // 禁止操作 如果目标流不可写（关闭状态），则这将简单地限制（暂停）源流： $dest->close(); $source->pipe($dest); // calls $source->pause() 同样，如果目标流在管道仍处于活动状态时关闭，它还将限制（暂停）源流： $source->pipe($dest); $dest->close(); // calls $source->pause() 一旦管道成功设置，目标流必须发出一个pipe事件，源流必须有一个 event 参数。 close() close(): void 方法可以用来关闭流(强制)。 $stream->close(); 一旦流被关闭，它应该触发一个close事件。 请注意，此事件不应触发多次。 调用此方法后，流必须切换到不可读模式，另请参见isReadable()。 这意味着不应再触发data或end事件。 $stream->close(); assert($stream->isReadable() === false); $stream->on('data', assertNeverCalled()); $stream->on('end', assertNeverCalled()); 如果此流是DuplexStreamInterface，则还应该注意流的可写端close()方法的实现。 换句话说，调用此方法后，流必须切换到不可写和不可读模式，另请参见iswriteable()。 请注意，此方法不应与end()方法混淆。 WritableStreamInterface WritableStreamInterface 为只写流和双工流的可写端接口。 除了定义一些方法外，这个接口还实现了EventEmitterInterface，它允许您对某些事件做出反应。 事件回调函数必须是一个有效的callable，它遵循严格的参数定义，并且必须完全按照文档所述接受事件参数。 事件回调函数不能抛出Exception。 事件回调函数的返回值将被忽略并且没有任何影响，因此出于性能原因，建议您不要返回任何过多的数据结构。 此接口的每个实现都必须遵循这些事件语义，才能被视为合法的流。 请注意，此接口的更高级别的实现可以选择使用未定义为该底层级别流规范一部分的专用语义来定义其他事件。 与这些事件语义的一致性超出了此接口的范围，因此您可能还必须参考此类更高级别的实现的文档。 drain事件 每写入缓冲区满时且有更多数据到达时，就会发出drain事件。 $stream->on('drain', function () use ($stream) { echo 'Stream is now ready to accept more data'; }); 每写入缓冲区满时且有更多数据到达时，就会发出drain事件。 换句话说，这个事件可以被触发多次，如果缓冲区不满，则该事件可能是零次。 如果缓冲区不满，则不应触发此事件。 该事件主要在内部使用，有关更多详细信息，请参见write() pipe事件 当一个可读流pipe()进入数据时，pipe事件将被触发。 事件接收源流的一个ReadableStreamInterface参数。 $stream->on('pipe', function (ReadableStreamInterface $source) use ($stream) { echo 'Now receiving piped data'; // explicitly close target if source emits an error $source->on('error', function () use ($stream) { $stream->close(); }); }); $source->pipe($stream); 对于每个成功导入目标流的可读流，此事件必须触发一次。 换句话说，这个事件可以被触发多次，如果没有数据流通过管道进入这个流，则可能是零次。 如果源不可读(已经关闭)或目标不可写(已经关闭)，则绝不能触发此事件。 此事件主要在内部使用，请参阅pipe()了解更多细节。 error 事件 一旦发生致命错误，则会触发error事件，通常是在试图写入该流时。 事件为错误实例接收一个Exception对象参数。 $stream->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); 一旦流检测到致命错误(例如致命传输错误)，就会触发此事件。 它不应该在前一个error 或 close事件之后触发。 如果不出现一个致命的错误情况，例如没有导致任何数据丢失的临时网络问题，则不会触发。 在流出错后，它必须关闭流，因此应该紧跟着一个close事件，然后切换到非可写模式，参见close()和isWritable()。 许多常见流（例如TCP / IP连接或基于文件的流）仅处理数据传输，并且可能会选择仅针对致命的传输错误触发一次，然后将其关闭（终止）作为响应。 如果这个流是一个DuplexStreamInterface，您还应该注意流的可读端error事件的实现。 换句话说，在读取或写入流时可能发生错误，这将导致相同的错误处理。 close 事件 一旦流关闭（终止），将发出close事件。 $stream->on('close', function () { echo 'CLOSED'; }); 根据流是否终止，此事件应触发一次或从不触发。 它不会在前一个close事件之后触发。 流关闭后，必须切换到不可写模式， 另请参见isWritable() 无论是由于不可恢复的错误而隐式触发还是在任何一方关闭流时显式触发，只要流关闭，都应触发此事件。 许多常见的流(例如TCP/IP连接或基于文件的流)可能会选择在end()方法刷新缓冲区后、在接收到成功 end 事件或致命的传输error事件后触发此事件。 如果此流是DuplexStreamInterface，则还应注意该流的可读端close事件的实现。 换句话说，接收到该事件后，流必须切换到不可写和不可读取模式，另请参见isReadable()。 注意，该事件不应与end事件混淆。 isWritable() isWritable(): bool方法可用于检查此流是否处于可写状态（尚未关闭）。 此方法可用于检查流是否仍接受写入数据，或者是否已结束或关闭。 将数据写入不可写流是不可操作的： assert($stream->isWritable() === false); $stream->write('end'); // NO-OP $stream->end('end'); // NO-OP 成功打开的流必须始终以可写模式。 一旦流结束或关闭，它必须切换到不可写模式。 这种情况随时可能发生，可以通过end()或close()显式发生，也可以由于远程关闭或不可恢复的传输错误而隐式发生。 一旦流切换到不可写模式，它就不能转换回可写模式。 如果此流是DuplexStreamInterface实现，则还应该注意流的可读端isReadable()方法的实现。除非这是半开放双工流，否则它们通常应该具有相同的返回值。 write() 使用write(mixed $data): bool方法将数据写入流。 必须使用布尔值true来确认成功写入，这意味着要么立即写入（刷新）数据，要么对数据进行缓冲和调度以备将来写入。 请注意，这个接口无法控制显式刷新缓冲数据，因为寻找合适的刷新时间超出了这个接口的范围，要由这个接口的实现来决定。 许多常见的流（例如TCP / IP连接或基于文件的流）可以选择缓冲所有给定的数据，并通过使用底层的EventLoop来检查资源何时实际可写来计划将来的刷新。 如果流不能处理写入（或刷新）数据的操作，它应该发出一个error事件，如果流不能从这个错误中恢复，则可能close()该流。 如果在添加$data后内部缓冲区已满，那么write()应该返回false，表明调用者应该停止发送数据，直到缓冲区耗尽。 一旦缓冲区准备好接受更多数据，流应该发送drain事件。 同样，如果流是不可写的(已经处于关闭状态)，它一定不能处理给定的$data，并且应该返回false，表明调用者应该停止发送数据。 给定的$data参数可能是混合类型，但通常建议它应该是一个string值，或者使用允许转化为string的类型，以最大限度地兼容。 许多常见的流（例如TCP / IP连接或基于文件的流）仅接受原始（二进制）有效载荷数据，这些数据通过网络作为string值的块传输。 由于这种基于流的特性，发送方可以发送任意数量大小不同的块。无法保证这些数据块将以发送方打算发送的完全相同的顺序接收。 换言之，许多较底层的协议（如TCP/IP）以块的形式传输数据，这些块的大小可能介于单个字节到几十千字节之间。 您需要对这些数据块应用更高级的协议，以便实现正确的消息帧。 end() end(mixed $data = null): void方法可用于成功结束流（可选地发送一些最终数据）。 这个方法可以用来成功地结束流，例如，在发送出所有当前缓存的数据后关闭流。 $stream->write('hello'); $stream->write('world'); $stream->end(); 如果当前没有缓冲的数据，也没有需要刷新的数据，那么这个方法可以立即close()流。 如果缓冲区中仍有需要首先刷新的数据，则该方法应该尝试写出这些数据，然后才使用close()关闭流。 一旦流关闭，它会触发close事件。 请注意，这个接口无法控制显式刷新缓冲数据，因为寻找合适的刷新时间超出了这个接口的范围，要由这个接口的实现来决定。 许多常见的流（例如TCP / IP连接或基于文件的流）可以选择缓冲所有给定的数据，并通过使用底层的EventLoop来检查资源何时实际可写来计划将来的刷新。 您可以选择在结束流之前将一些最终数据传递给流。 如果将非null值指定为$data，则此方法的行为就像在没有结束之前调用write($data)一样。 // shorter version $stream->end('bye'); // same as longer version $stream->write('bye'); $stream->end(); 调用此方法后，流必须切换到不可写模式，另请参见isWritable()。 这意味着不可能再进行写操作，因此任何其他的write()或end()调用均无效。 $stream->end(); assert($stream->isWritable() === false); $stream->write('nope'); // NO-OP $stream->end(); // NO-OP 如果此流是DuplexStreamInterface实现，则调用此方法也应结束其可读端，除非该流支持半开模式。 换句话说，调用此方法后，这些流应该切换到不可写和不可读取的模式，另请参见isReadable() 这意味着在这种情况下，流不再应该发出任何data或end事件。 流可能会选择使用pause()方法逻辑，但必须特别注意确保对resume()方法的后续调用不应继续发出可读事件。 注意，该方法不应与close()方法混淆。 close() close(): void 方法可用于（强制）关闭流。 此方法可用于强制关闭流，即在不等待刷新任何缓冲数据的情况下关闭流。 如果缓冲区中仍有数据，则会丢弃此数据。 $stream->close(); 一旦流关闭，它应该发出一个close事件。 请注意，不应多次触发此事件。 调用此方法后，流必须切换到不可写模式，另请参见isWritable()。 这意味着不可能再进行写操作，因此任何其他的write()或end()调用均无效。 $stream->close(); assert($stream->isWritable() === false); $stream->write('nope'); // NO-OP $stream->end(); // NO-OP 注意，该方法不应与end()方法混淆。 与end()方法不同，此方法不处理任何现有缓冲区，而只是丢弃缓冲区内容。 同样，也可以在对流调用end()之后调用此方法，以停止等待流刷新其最终数据。 同样，为了停止等待流刷新其最终数据，也可以在流上调用end()之后调用此方法。 $stream->end(); $loop->addTimer(1.0, function () use ($stream) { $stream->close(); }); 如果此流是DuplexStreamInterface，则还应该注意流的可读端如何实现close() 方法。 换句话说，调用此方法后，流必须切换到不可写和不可读模式，另请参见isReadable()。 DuplexStreamInterface DuplexStreamInterface为双工流（可读写）提供接口。 它建立在用于可读和可写流的现有接口之上，并遵循完全相同的方法和事件语义。 如果您是这个概念的新手，则应该先阅读ReadableStreamInterface和WritableStreamInterface。 除了定义一些方法外，该接口还实现了EventEmitterInterface， 它使您能够对ReadbleStreamInterface和WritableStreamInterface上定义的相同事件做出反应。 事件回调函数必须是一个有效的callable，遵守严格的参数定义，并且必须完全按照文档中描述接受事件参数。 事件回调函数绝不能抛出Exception。 事件回调函数的返回值将被忽略，并且没有任何效果，因此出于性能原因，建议您不要返回任何过多的数据结构。 这个接口的每个实现都必须遵循这些事件语义，才能被认为是合法流。 请注意，此接口的高级实现可能会选择使用专用语义来定义附加事件， 这些专用语义未定义为此低级流规范的一部分。 与这些事件语义的一致性超出了此接口的范围， 因此您可能还必须参考此类更高级别实现的文档。 另请参阅 ReadableStreamInterface和WritableStreamInterface。 Creating streams ReactPHP在其整个生态系统中都使用streams的概念，所以这个包的许多高级用户只处理流使用。 流实例通常是在一些更高级别的组件中创建的，许多用户实际上从来不需要处理创建流实例的问题。 如果你想接受传入或建立传出的明文TCP/IP或安全TLS socket连接流，使用react/socket 如果你想接收一个http请求体流，请使用react/http 如果你想通过诸如STDIN, STDOUT, STDERR等进程管道与子进程通信，请使用react/child-process 如果你想对文件系统进行读写操作，请使用 react/filesystem 参见最后一章更多真实应用。 但是，如果您正在编写一个底层组件，或者想要从一个流资源创建一个流实例，那么下面的章节就是为您准备的。 请注意，以下示例使用fopen()和stream_socket_client()只是为了说明。 这些函数不应该在真正的异步程序中使用，因为每个调用可能需要几秒钟才能完成，否则将阻塞EventLoop。 此外，fopen() 调用将在某些平台上返回一个文件句柄，这可能是所有EventLoop实现所支持的，也可能不是。 作为一种替代方案，您可能希望使用上面列出的高级库。 ReadableResourceStream ReadableResourceStream是PHP流资源ReadableStreamInterface的具体实现。 这可以用来表示只读资源，比如以可读模式打开的文件流，或者像STDIN这样的流: $stream = new ReadableResourceStream(STDIN, $loop); $stream->on('data', function ($chunk) { echo $chunk; }); $stream->on('end', function () { echo 'END'; }); 请参阅ReadableStreamInterface. 构造函数的第一个参数必须是一个以读取模式打开的有效的流资源(例如:fopen()的模式r)。 否则，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException $stream = new ReadableResourceStream(false, $loop); 另请参阅DuplexResourceStream了解读写流资源。 该类内部试图在流资源上启用非阻塞模式，这可能不支持所有的流资源。 最值得注意的是，Windows上的管道(STDIN等)不支持这一点。 如果失败，它将抛出RuntimeException: // throws RuntimeException on Windows $stream = new ReadableResourceStream(STDIN, $loop); 一旦使用有效的流资源调用构造函数，该类将负责底层的流资源。 您应该只使用它的公共API，而不应该手动干扰底层的流资源。 该类接受一个可选参数int|null $readChunkSize，该参数控制一次从流中读取的最大缓冲区大小(以字节为单位)。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 这可以是一个正数，这意味着一次最多可以从底层流资源读取X个字节。注意，如果流资源当前可用的字节数小于X字节，则实际读取的字节数可能更低。 这可以是-1，表示从底层流资源中读取所有可用的内容。 这应该读取直到流资源不再可读(即底层缓冲区耗尽)，注意这并不一定意味着它到达了EOF。 $stream = new ReadableResourceStream(STDIN, $loop, 8192); PHP bug警告:如果PHP进程在没有STDIN流的情况下显式启动， 那么尝试从STDIN读取数据可能会从其他流资源返回数据。 如果以空流(如php test.php 而不是php test.php )开始，则不会发生这种情况。 请参阅#81 了解更多细节。 WritableResourceStream WritableResourceStream是PHP流资源的WritableStreamInterface的具体实现。 这可以用来表示只写的资源，比如以可写模式打开的文件流，或者像STDOUT或STDERR这样的流: $stream = new WritableResourceStream(STDOUT, $loop); $stream->write('hello!'); $stream->end(); 请参阅WritableStreamInterface 构造函数的第一个参数必须是打开用于写入的有效流资源。 否则，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException $stream = new WritableResourceStream(false, $loop); 另请参阅DuplexResourceStream了解读写流资源。 该类内部试图在流资源上启用非阻塞模式，这可能不支持所有的流资源。 最值得注意的是，Windows上的管道(STDOUT、STDERR等)不支持这一点。 如果失败，它将抛出RuntimeException: // throws RuntimeException on Windows $stream = new WritableResourceStream(STDOUT, $loop); 一旦使用有效的流资源调用构造函数，该类将负责底层的流资源。 您应该只使用它的公共API，而不应该手动干扰底层的流资源。 对这个类的任何write()调用都不会立即执行，而是在EventLoop报告流资源准备好接受数据后异步执行。 为此，它使用一个内存缓冲区字符串来收集所有未完成的写操作。 这个缓冲区应用了一个软限制，它定义了在调用者停止发送进一步数据之前，它愿意接受多少数据。 该类接受一个可选参数int|null $writeBufferSoftLimit，以字节为单位控制最大缓冲区大小。 您可以在这里使用null值来应用其默认值。 否则不应该更改此值，除非您知道自己在做什么。 $stream = new WritableResourceStream(STDOUT, $loop, 8192); 该类接受一个可选参数int|null $writeChunkSize，该参数以字节为单位控制一次写入流的最大缓冲区大小。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 这可以是一个正数，这意味着一次最多将写入X个字节到底层流资源。注意，如果流资源当前可用的字节数小于X字节，则实际写入的字节数可能更低。 这可以是-1，意思是将所有可用的内容写入底层流资源。 $stream = new WritableResourceStream(STDOUT, $loop, null, 8192); 请参阅write()了解更多细节。 DuplexResourceStream DuplexResourceStream是PHP流资源DuplexStreamInterface的具体实现。 用来表示读写资源，比如以读写模式打开的文件流，或者像TCP/IP连接这样的流: $conn = stream_socket_client('tcp://google.com:80'); $stream = new DuplexResourceStream($conn, $loop); $stream->write('hello!'); $stream->end(); 请参阅DuplexStreamInterface 了解更多细节。 构造函数的第一个参数必须是一个有效的流资源，该流资源被打开用于读取和写入。 否则，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException $stream = new DuplexResourceStream(false, $loop); 另请参阅只读的ReadableResourceStream和只写流资源的WritableResourceStream。 该类内部试图在流资源上启用非阻塞模式，这可能不支持所有的流资源。 最值得注意的是，Windows上的管道(STDOUT、STDERR等)不支持这一点。 如果失败，它将抛出RuntimeException: // throws RuntimeException on Windows $stream = new DuplexResourceStream(STDOUT, $loop); 一旦使用有效的流资源调用构造函数，该类将负责底层的流资源。 您应该只使用它的公共API，而不应该手动干扰底层的流资源。 该类接受一个可选参数int|null $readChunkSize，该参数控制一次从流中读取的最大缓冲区大小(以字节为单位)。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 这可以是一个正数，这意味着一次最多可以从底层流资源读取X个字节。注意，如果流资源当前可用的字节数小于X字节，则实际读取的字节数可能更低。 这可以是-1，表示从底层流资源中读取所有可用的内容。 这应该读取直到流资源不再可读(即底层缓冲区耗尽)，注意这并不一定意味着它到达了EOF。 $conn = stream_socket_client('tcp://google.com:80'); $stream = new DuplexResourceStream($conn, $loop, 8192); 对这个类的任何write()调用都不会立即执行，而是在EventLoop报告流资源准备好接受数据后异步执行。 为此，它使用一个内存缓冲区字符串来收集所有未完成的写操作。 这个缓冲区应用了一个软限制，它定义了在调用者停止发送进一步数据之前，它愿意接受多少数据。 这个类接受另一个可选参数WritableStreamInterface|null $buffer，控制这个流的写行为。 您可以在这里使用null值来应用其默认值。 除非您知道自己在做什么，否则不应该更改此值。 如果你想改变写缓冲区软限制，你可以传递一个WritableResourceStream 的实例，像这样: $conn = stream_socket_client('tcp://google.com:80'); $buffer = new WritableResourceStream($conn, $loop, 8192); $stream = new DuplexResourceStream($conn, $loop, null, $buffer); 参见 WritableResourceStream 了解更多细节。 ThroughStream ThroughStream实现了DuplexStreamInterface ，并将任何你写入它的数据传递到它的可读端。 $through = new ThroughStream(); $through->on('data', $this->expectCallableOnceWith('hello')); $through->write('hello'); 同样，end() 方法将结束流并触发end，然后close()流。 close() 方法 将关闭流并发出close. 相应地，这也可以像这样在pipe()上下文中使用: $through = new ThroughStream(); $source->pipe($through)->pipe($dest); 可选，它的构造函数接受任何可调用的函数，然后这些函数将被用来 filter（过滤） 任何写入它的数据。 此函数在传递到可写端时接收单个数据参数，并且在传递到可读端时必须返回数据： $through = new ThroughStream('strtoupper'); $source->pipe($through)->pipe($dest); 请注意，这个类不假设任何数据类型。这可用于转换数据，例如将任何结构化数据转换为换行符分隔的JSON（NDJSON）流，如下所示： $through = new ThroughStream(function ($data) { return json_encode($data) . PHP_EOL; }); $through->on('data', $this->expectCallableOnceWith(\"[2, true]\\n\")); $through->write(array(2, true)); 允许回调函数抛出Exception。在这种情况下，流将发出一个error事件，然后close()流。 $through = new ThroughStream(function ($data) { if (!is_string($data)) { throw new \\UnexpectedValueException('Only strings allowed'); } return $data; }); $through->on('error', $this->expectCallableOnce())); $through->on('close', $this->expectCallableOnce())); $through->on('data', $this->expectCallableNever())); $through->write(2); CompositeStream CompositeStream实现了DuplexStreamInterface， 并可用于从两个分别实现ReadableStreamInterface和 WritableStreamInterface的单独流中创建一个双工流。 这对于一些可能需要单个DuplexStreamInterface 的api很有用， 或者只是因为像这样使用单个流实例通常更方便: $stdin = new ReadableResourceStream(STDIN, $loop); $stdout = new WritableResourceStream(STDOUT, $loop); $stdio = new CompositeStream($stdin, $stdout); $stdio->on('data', function ($chunk) use ($stdio) { $stdio->write('You said: ' . $chunk); }); 这是一个合法流，它从底层流转发所有的流事件，并将所有的流调用转发给底层流。 如果你 write() 写入双工流，它将简单地将 write() 写入可写端并返回其状态。 如果end()双工流，则可写流将end()，可读流将pause()。 如果close()双工流，两个输入流都将被关闭。 如果两个输入流中的任何一个发出close事件，双工流也将关闭。 如果两个输入流中的任何一个在构造双工流时已经关闭，它将close()另一端并返回一个关闭的流。 用法 下面的例子可以用来将源文件的内容管道到目标文件中，而不必将整个文件读入内存: $loop = new React\\EventLoop\\StreamSelectLoop; $source = new React\\Stream\\ReadableResourceStream(fopen('source.txt', 'r'), $loop); $dest = new React\\Stream\\WritableResourceStream(fopen('destination.txt', 'w'), $loop); $source->pipe($dest); $loop->run(); 注意，这个例子使用fopen()只是为了说明。 在真正的异步程序中不应该使用这种方法，因为文件系统本身就是阻塞的，而且每次调用都可能需要几秒钟的时间。 参见创建流获取更复杂的示例。 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/stream:^1.1.1 有关版本升级的详细信息，请参见CHANGELOG 。 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过 PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈推荐在这个项目中使用PHP 7+，因为它有巨大的性能改进。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit 该测试套件还包含许多依赖稳定internet连接的功能集成测试。 如果您不想运行这些，则可以像这样跳过它们： $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. More 有关在实际应用程序中如何创建流的更多信息，请参见创建流。 请参阅我们的用户Wiki 和Packagist依赖项 在实际应用程序中使用流的软件包列表。 "},"2.Network-Components/Datagram.html":{"url":"2.Network-Components/Datagram.html","title":"Datagram","keywords":"","body":"Datagram Event-driven UDP datagram socket client and server for ReactPHP. Quickstart example Once installed, you can use the following code to connect to an UDP server listening on localhost:1234 and send and receive UDP datagrams: $loop = React\\EventLoop\\Factory::create(); $factory = new React\\Datagram\\Factory($loop); $factory->createClient('localhost:1234')->then(function (React\\Datagram\\Socket $client) { $client->send('first'); $client->on('message', function($message, $serverAddress, $client) { echo 'received \"' . $message . '\" from ' . $serverAddress. PHP_EOL; }); }); $loop->run(); See also the examples. Usage This library's API is modelled after node.js's API for UDP / Datagram Sockets (dgram.Socket). Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/datagram:^1.5 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"2.Network-Components/Socket.html":{"url":"2.Network-Components/Socket.html","title":"Socket","keywords":"","body":"Socket ReactPHP 的异步，流式纯文本TCP / IP以及安全的TLS套接字服务器和客户端连接。 套接字库基于EventLoop 和 Stream 组件为套接字层服务器和客户端提供了可重用的接口。 服务器组件允许您构建接受来自网络客户端连接的网络服务器(如HTTP服务器)。 客户端组件允许您构建建立到网络服务器外发连接的网络客户端(例如HTTP或数据库客户端)。 这个库为这些提供了异步、流的方式，因此您可以在不阻塞的情况下处理多个并发连接。 目录 快速开始 连接用法 ConnectionInterface getRemoteAddress() getLocalAddress() 服务端用法 ServerInterface connection event error event getAddress() pause() resume() close() Server 高级服务端使用 TcpServer SecureServer UnixServer LimitingServer getConnections() 客服端用法 ConnectorInterface connect() Connector 高级客户端使用 TcpConnector HappyEyeBallsConnector DnsConnector SecureConnector TimeoutConnector UnixConnector FixUriConnector 安装 测试 License 快速开始 如果您发送任何连接，这是一个关闭连接的服务器： $loop = React\\EventLoop\\Factory::create(); $socket = new React\\Socket\\Server('127.0.0.1:8080', $loop); $socket->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"Hello \" . $connection->getRemoteAddress() . \"!\\n\"); $connection->write(\"Welcome to this amazing server!\\n\"); $connection->write(\"Here's a tip: don't say anything.\\n\"); $connection->on('data', function ($data) use ($connection) { $connection->close(); }); }); $loop->run(); 另请参阅示例 这是一个客户端，该客户端输出所述服务器的输出，然后尝试向其发送字符串： $loop = React\\EventLoop\\Factory::create(); $connector = new React\\Socket\\Connector($loop); $connector->connect('127.0.0.1:8080')->then(function (React\\Socket\\ConnectionInterface $connection) use ($loop) { $connection->pipe(new React\\Stream\\WritableResourceStream(STDOUT, $loop)); $connection->write(\"Hello World!\\n\"); }); $loop->run(); 连接用法 ConnectionInterface ConnectionInterface 用于表示任何传入和传出的连接，例如普通的TCP / IP连接。 传入或传出连接是实现React DuplexStreamInterface 的双工流（可读和可写）。 它包含已建立到/来自此连接的本地和远程地址（客户端IP）的附加属性。 最常见的情况是，所有实现ServerInterface的类都会触发实现这个ConnectionInterface的实例， 并由所有实现ConnectorInterface的类使用。 因为ConnectionInterface实现了底层的DuplexStreamInterface 所以你可以像往常一样使用它的所有事件和方法: $connection->on('data', function ($chunk) { echo $chunk; }); $connection->on('end', function () { echo 'ended'; }); $connection->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage(); }); $connection->on('close', function () { echo 'closed'; }); $connection->write($data); $connection->end($data = null); $connection->close(); // … 更多细节，请参阅DuplexStreamInterface. getRemoteAddress() getRemoteAddress(): ?string 方法返回已经建立连接的完整远程地址(URI)。 $address = $connection->getRemoteAddress(); echo 'Connection with ' . $address . PHP_EOL; 如果此时无法确定或未知远程地址(比如在连接关闭后)，它可能会返回一个NULL值。 否则，它将返回完整地址(URI)作为字符串值，例如tcp://127.0.0.1:8080， tcp://[::1]:80， tls://127.0.0.1:443， unix://example.sock 或 unix:///path/to/example.sock 请注意，单个URI组件是特定于应用程序的，并依赖于底层传输协议。 如果这是一个基于TCP/IP的连接，而你只想要远程IP，你可以这样使用: $address = $connection->getRemoteAddress(); $ip = trim(parse_url($address, PHP_URL_HOST), '[]'); echo 'Connection with ' . $ip . PHP_EOL; getLocalAddress() getLocalAddress(): ?string 方法返回已经建立连接的完整本地地址(URI)。 $address = $connection->getLocalAddress(); echo 'Connection with ' . $address . PHP_EOL; 如果此时无法确定或未知本地地址(比如在连接关闭后)，它可能会返回一个NULL值。 否则，它将返回完整地址(URI)作为字符串值，例如tcp://127.0.0.1:8080， tcp://[::1]:80， tls://127.0.0.1:443， unix://example.sock 或 unix:///path/to/example.sock 请注意，单个URI组件是特定于应用程序的，并依赖于底层传输协议。 这个方法是getRemoteAddress() 方法的补充，所以不应该混淆它们。 如果你的TcpServer实例正在监听多个接口(例如使用地址0.0.0.0)， 你可以使用这个方法找出哪个接口实际上接受了这个连接(例如一个公共的或本地的接口)。 如果您的系统具有多个接口（例如WAN和LAN接口），则可以使用此方法找出实际用于该连接的接口。 服务端用法 ServerInterface ServerInterface 提供一个接收流连接的接口，比如一个正常的TCP/IP连接。 大多数更高级别的组件（例如HTTP服务器）都接受实现此接口的实例，以接受传入的流连接。 通常这是通过依赖项注入完成的，便于你将该实现替换为该接口的其他实现。 这意味着您应该对此接口进行类型提示，而不是对此接口的具体实现。 除了定义一些方法之外，这个接口还实现了EventEmitterInterface ，它允许您对某些事件作出反应。 connection event 当建立了一个新的连接时，就会触发connection事件，例如，一个新的客户端连接到这个服务器套接字: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'new connection' . PHP_EOL; }); 请参阅ConnectionInterface以获得有关处理传入连接的更多细节。 error event 当从客户端接收新连接时发生错误时，将触发error事件。 $server->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage() . PHP_EOL; }); 注意，这不是一个致命错误事件，也就是说，即使在这个事件之后，服务器仍然在监听新的连接。 getAddress() getAddress(): ?string 方法可以用来返回服务器当前正在监听的完整地址(URI)。 $address = $server->getAddress(); echo 'Server listening on ' . $address . PHP_EOL; 如果此时地址无法确定或未知(例如在套接字关闭后)，它可能会返回一个NULL值。 否则，它将返回完整地址(URI)作为字符串值，例如tcp://127.0.0.1:8080, tcp://[::1]:80, tls://127.0.0.1:443，unix://example.sock 或 unix:///path/to/example.sock 请注意，单个URI组件是特定于应用程序的，并依赖于底层传输协议。 如果这是一个基于TCP/IP的服务器，你只需要本地端口，你可以这样使用: $address = $server->getAddress(); $port = parse_url($address, PHP_URL_PORT); echo 'Server listening on port ' . $port . PHP_EOL; pause() pause(): void方法可以用于暂停接受新的传入连接。 从EventLoop中删除套接字资源，从而停止接受新连接。注意，监听套接字保持活动并不是关闭了。 这意味着新的传入连接将在操作系统backlog中保持挂起状态，直到其可配置的backlog被填满为止。 一旦积压被填满，操作系统可能会拒绝新传入的连接，直到再次通过恢复接受新的连接来耗尽积压。 一旦服务器暂停，就不应该触发更多的connection事件。 $server->pause(); $server->on('connection', assertShouldNeverCalled()); 此方法仅供参考，但通常不推荐使用，服务器可以继续触发connection事件。 除非另有说明，成功打开的服务器不应在暂停状态下启动。 您可以通过再次调用resume()继续处理事件。 请注意，这两个方法都可以被调用多次，特别是多次调用pause()无效。 同样，在close()之后调用这个函数也是无效操作。 resume() resume(): void方法可以用来恢复接收新的连接。 在前一个pause()之后重新将套接字资源附加到EventLoop。 $server->pause(); $loop->addTimer(1.0, function () use ($server) { $server->resume(); }); 请注意，这两个方法都可以被多次调用，之前没有调用pause()函数，调用resume()无效。 同样，在close()之后调用这个函数也是一个无效操作。 close() close(): void方法可以用来关闭这个监听套接字。 这将停止侦听这个套接字上的新传入连接。 echo 'Shutting down server socket' . PHP_EOL; $server->close(); 在同一个实例上多次调用这个方法是无效的。 Server Server类是这个包中的主要类，它实现了ServerInterface， 并允许您接受传入的流连接，例如明文TCP/IP或安全TLS连接流。 Unix域套接字也可以接受连接。 $server = new React\\Socket\\Server(8080, $loop); 如上所述，$uri参数可以只包含一个端口，在这种情况下，服务器将默认侦听本地主机地址127.0.0.1，这意味着从系统外部无法访问该地址。 为了使用一个随机的端口分配，你可以使用端口0: $server = new React\\Socket\\Server(0, $loop); $address = $server->getAddress(); 为了改变套接字正在监听的主机，你可以给构造函数的第一个参数提供一个IP地址，可以在IP前面加上tcp://方案: $server = new React\\Socket\\Server('192.168.0.1:8080', $loop); 如果你想监听一个IPv6地址，你必须用方括号括起主机: $server = new React\\Socket\\Server('[::1]:8080', $loop); 要在Unix域套接字(UDS)路径上监听，必须在URI前面加上Unix://方案: $server = new React\\Socket\\Server('unix:///tmp/server.sock', $loop); 如果给定的URI无效，不包含端口，任何其他方案，或者包含主机名，它将抛出一个InvalidArgumentException: // throws InvalidArgumentException due to missing port $server = new React\\Socket\\Server('127.0.0.1', $loop); 如果给定的URI看起来是有效的，但是监听失败(比如端口已经被使用或者端口低于1024可能需要root访问等等)， 它将抛出一个RuntimeException: $first = new React\\Socket\\Server(8080, $loop); // throws RuntimeException because port is already in use $second = new React\\Socket\\Server(8080, $loop); 请注意，这些错误条件可能因您的系统和/或配置而异。 有关实际错误条件的详细信息，请参阅异常消息和代码。 您还可以为底层流套接字资源指定TCP socket context options 如下所示: $server = new React\\Socket\\Server('[::1]:8080', $loop, array( 'tcp' => array( 'backlog' => 200, 'so_reuseport' => true, 'ipv6_v6only' => true ) )); 请注意，可用的socket context options, 它们的默认值和更改这些选项的效果可能会根据您的系统和/或PHP版本而有所不同，传递未知的上下文选项没有效果。 除非明确给出，否则backlog上下文选项默认为511。 出于BC原因，您还可以将TCP套接字上下文选项作为一个简单的数组传递，而不必将其包装在TCP键下的另一个数组中。 您可以启动一个安全TLS(以前称为SSL)服务器，只需在TLS:// URI前添加一个前缀。 它内部将等待明文TCP/IP连接，然后对每个连接执行TLS握手。 因此，它需要有效的TLS上下文选项 , 如果您使用PEM编码的证书文件,它在其最基本的形式可能看起来像这样: $server = new React\\Socket\\Server('tls://127.0.0.1:8080', $loop, array( 'tls' => array( 'local_cert' => 'server.pem' ) )); 注意，证书文件不会在实例化时加载，而是在传入连接初始化其TLS上下文时加载。 这意味着任何无效的证书文件路径或内容只会在以后的时间导致error事件。 如果您的私钥已使用密码加密，则必须像这样指定它： $server = new React\\Socket\\Server('tls://127.0.0.1:8000', $loop, array( 'tls' => array( 'local_cert' => 'server.pem', 'passphrase' => 'secret' ) )); 默认情况下，此服务器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本： $server = new React\\Socket\\Server('tls://127.0.0.1:8000', $loop, array( 'tls' => array( 'local_cert' => 'server.pem', 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_SERVER ) )); 请注意，使用TLS context options, 它们的默认值和更改这些值的效果可能会因您的系统和/或PHP版本而异。 外部上下文数组允许您同时使用tcp（可能还有更多）上下文选项。 传递未知的上下文选项无效。 如果您不使用tls：//方案，那么传递tls上下文选项将无效。 每当客户端连接时，它将通过实现ConnectionInterface的连接实例触发connection事件： $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Plaintext connection from ' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 另请参阅 ServerInterface 注意，Server类是TCP / IP套接字的具体实现。 如果要在更高级别的协议实现中类型提示，则应改用通用的 ServerInterface 高级服务端使用 TcpServer TcpServer类实现 ServerInterface，并负责接受明文TCP/IP连接。 $server = new React\\Socket\\TcpServer(8080, $loop); 如上所述，$uri参数可以只包含一个端口，在这种情况下，服务器将默认侦听本地主机地址127.0.0.1，这意味着从系统外部无法访问该地址。 为了使用一个随机的端口分配，你可以使用端口0: $server = new React\\Socket\\TcpServer(0, $loop); $address = $server->getAddress(); 为了改变套接字正在监听的主机，你可以通过提供给构造函数的第一个参数提供一个IP地址，在此参数之前有一个tcp://方案: $server = new React\\Socket\\TcpServer('192.168.0.1:8080', $loop); 如果你想监听一个IPv6地址，你必须用方括号括起主机: $server = new React\\Socket\\TcpServer('[::1]:8080', $loop); 如果给定的URI无效，不包含端口，任何其他方案，或者包含主机名，则将抛出InvalidArgumentException： // throws InvalidArgumentException due to missing port $server = new React\\Socket\\TcpServer('127.0.0.1', $loop); 如果给定的URI似乎有效，但是对其进行侦听失败（例如，如果端口已在使用中，或者端口低于1024，则可能需要root用户访问权限等）， 它将抛出RuntimeException： $first = new React\\Socket\\TcpServer(8080, $loop); // throws RuntimeException because port is already in use $second = new React\\Socket\\TcpServer(8080, $loop); 请注意，这些错误情况可能会因您的系统和/或配置而异。 有关实际错误情况的更多详细信息，请参阅异常消息和代码。 您还可以为底层流套接字资源指定socket context options ，如下所示: $server = new React\\Socket\\TcpServer('[::1]:8080', $loop, array( 'backlog' => 200, 'so_reuseport' => true, 'ipv6_v6only' => true )); 请注意，可用的socket context options, 它们的默认值和更改这些选项的效果可能会根据您的系统和/或PHP版本而有所不同，传递未知的上下文选项没有效果。 除非明确给出，否则backlog上下文选项默认为511。 当客户端连接时，它将发出一个connection事件，该事件的连接实例实现了 ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Plaintext connection from ' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 更多细节请参阅ServerInterface SecureServer SecureServer类实现了ServerInterface，负责提供安全的TLS(以前称为SSL)服务器。 它通过包装一个TcpServer实例实现，该实例等待明文TCP/IP连接，然后对每个连接执行TLS握手。 因此，它需要有效的TLS context options ， 如果您使用PEM编码的证书文件,其最基本的形式可能看起来像这样，: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem' )); 注意，证书文件不会在实例化时加载，而是在传入连接初始化其TLS上下文时加载。 这意味着任何无效的证书文件路径或内容只会在以后的时间导致error事件。 如果你的私钥是用密码加密的，你必须这样指定: $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem', 'passphrase' => 'secret' )); 默认情况下，此服务器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本： $server = new React\\Socket\\TcpServer(8000, $loop); $server = new React\\Socket\\SecureServer($server, $loop, array( 'local_cert' => 'server.pem', 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_SERVER )); 请注意，使用TLS context options ， 它们的默认值和更改它们的效果可能会因系统和/或PHP版本而异。 传递未知的上下文选项无效。 每当客户端完成TLS握手时，它将发出带有实现ConnectionInterface的连接实例的connection事件： $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'Secure connection from' . $connection->getRemoteAddress() . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 每当客户端未能成功执行TLS握手时，客户端都会触发error事件，然后关闭基础TCP / IP连接： $server->on('error', function (Exception $e) { echo 'Error' . $e->getMessage() . PHP_EOL; }); 另请参阅ServerInterface 请注意，SecureServer类是TLS套接字的具体实现。 如果你想在高级协议实现中类型提示，你应该使用通用的ServerInterface来代替。 高级用法：尽管允许将任何ServerInterface作为第一个参数，但应该将TcpServer实例作为第一个参数传递，除非您知道自己在做什么。 SecureServer内部必须在底层流资源上设置所需的TLS上下文选项。 这些资源不会通过此包中定义的任何接口，而只能通过内部Connection类公开。 TcpServer类保证发出实现ConnectionInterface的连接，并使用内部Connection类来公开这些底层资源。 如果使用自定义ServerInterface且其connection事件不满足此要求，SecureServer将触发error事件，然后关闭连接。 UnixServer UnixServer类实现了ServerInterface，并负责接受Unix域套接字(UDS)上的连接。 $server = new React\\Socket\\UnixServer('/tmp/server.sock', $loop); 如上所述，$uri参数只能由一个套接字路径或以unix://方案为前缀的套接字。 如果给定的URI看起来是有效的，但是监听失败(比如socket已经在使用或者文件不能访问等等)， 它将抛出一个RuntimeException: $first = new React\\Socket\\UnixServer('/tmp/same.sock', $loop); // throws RuntimeException because socket is already in use $second = new React\\Socket\\UnixServer('/tmp/same.sock', $loop); 请注意，这些错误条件可能因您的系统和/或配置而异。 特别是，当UDS路径已经存在且不能被绑定时，Zend PHP只会报告\"Unknown error\"。 在这种情况下，您可能需要检查指定UDS路径上的is_file()，以报告更友好的错误消息。 有关实际错误条件的详细信息，请参阅异常消息和代码。 当客户端连接时，它将发出一个connection事件，该事件的连接实例实现了 ConnectionInterface: $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { echo 'New connection' . PHP_EOL; $connection->write('hello there!' . PHP_EOL); … }); 更多细节请参阅 ServerInterface LimitingServer LimitingServer装饰器包装了一个给定的ServerInterface，并负责限制和跟踪到这个服务器实例的打开连接。 每当底层服务器发出connection事件时，将检查其限制，做出以下两种情况之一 通过将该连接添加到打开的连接列表中来跟踪该连接，然后触发connection事件 或者当连接超出限制时拒绝(关闭)连接，并将触发error事件。 当一个连接关闭时，它将从打开的连接列表中删除该连接。 $server = new React\\Socket\\LimitingServer($server, 100); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); 更多细节请参阅第二个示例 您必须传递打开连接的最大数量，以确保一旦超过这个限制，服务器将自动拒绝(关闭)连接。 在本例中，它将发出一个error事件来通知此情况，而不会触发connection事件。 $server = new React\\Socket\\LimitingServer($server, 100); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); 您可以传递一个null限制，以便不限制打开连接的数量，并一直接受新连接，直到耗尽操作系统资源(例如打开的文件句柄)。 如果您不想注意应用限制，但仍然想使用getConnections()方法，这很有用。 您可以配置服务器连接限制上限设置，到达上限就暂停接受新连接。在这种情况下，它将暂停底层服务器，不再处理任何新连接，因此也不再关闭任何过多的连接。 底层操作系统负责保持等待连接的积压，直到达到极限为止，此时它将开始拒绝新的连接。 当服务器低于连接限制，它将继续使用backlog中的连接，并在每个连接上处理未完成的数据。 这种模式对于一些设计为等待响应消息的协议(比如HTTP)可能很有用，但是对于要求立即响应的其他协议(比如交互式聊天中的“welcome”消息)就不适用了。 $server = new React\\Socket\\LimitingServer($server, 100, true); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->write('hello there!' . PHP_EOL); … }); getConnections() getConnections(): ConnectionInterface[]方法可以用来返回一个包含所有当前活动连接的数组。 foreach ($server->getConnection() as $connection) { $connection->write('Hi!'); } 客服端用法 ConnectorInterface ConnectorInterface 提供一个用于建立流连接的接口，例如普通的TCP / IP连接。 这是此包中定义的主要接口，并且在整个React的广阔生态系统中使用。 大多数更高级别的组件（例如HTTP，数据库或其他网络服务客户端）都接受实现此接口的实例，创建其与基础网络服务的TCP / IP连接。 通常这是通过依赖项注入完成的，便于你将该实现替换为该接口的其他实现。 该接口仅提供一种方法： connect() connect(string $uri): PromiseInterface方法可用于创建到给定远程地址的流式连接。 返回一个Promise ， 它在成功时以实现ConnectionInterface的流来实现， 或者在连接不成功时以Exception拒绝。 ： $connector->connect('google.com:443')->then( function (React\\Socket\\ConnectionInterface $connection) { // connection successfully established }, function (Exception $error) { // failed to connect due to $error } ); 另请参阅ConnectionInterface 返回的Promise必须以这样的方式实现：在尚待处理时可以将其取消。 取消未决的承诺必须以Exception拒绝其值。 它应清理所有适用的基础资源和参考： $promise = $connector->connect($uri); $promise->cancel(); Connector Connector类是这个包中的主要类，它实现了ConnectorInterface接口，并允许您创建流连接。 您可以使用此连接器创建任何类型的流连接，例如明文TCP/IP、安全TLS或本地Unix连接流。 它绑定到主事件循环，可以像这样使用: $loop = React\\EventLoop\\Factory::create(); $connector = new React\\Socket\\Connector($loop); $connector->connect($uri)->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 为了创建一个明文TCP/IP连接，你可以简单地传递一个主机和端口组合: $connector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 如果你没有在目标URI中指定一个URI方案，它将假定tcp://为默认值，并建立一个明文TCP/IP连接。 注意，TCP/IP连接需要目的地主机和端口 像上面一样，所有其他URI组件都是可选的。 In order to create a secure TLS connection, you can use the tls:// URI scheme like this: 创建一个安全的TLS连接，你可以使用tls:// URI方案: $connector->connect('tls://www.google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 创建一个本地的Unix域套接字连接，你可以使用unix:// URI方案: $connector->connect('unix:///tmp/demo.sock')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); getRemoteAddress()方法将返回给定给connect()方法的目标Unix域套接字(UDS)路径， 包括unix://方案，例如unix:///tmp/demo.sock。 getLocalAddress()方法很可能返回一个null值，因为这个值不适用于这里的UDS连接。 在底层，Connector被实现为此软件包中实现的较低层连接器的高层门面。 这意味着它还共享所有功能和实现细节。 如果要在更高级别的协议实现中类型提示，则应改用通用的ConnectorInterface 从v1.4.0开始，Connector类默认使用happy eyeballs algorithm 在指定主机名时自动通过IPv4或IPv6连接。 它会自动尝试同时使用IPv4和IPv6连接(更偏向IPv6)，从而避免用户使用不完善的IPv6连接或设置所面临的常见问题。 如果你想恢复到只做一个IPv4查找并且只尝试一个IPv4连接的旧行为，你可以这样设置Connector: $connector = new React\\Socket\\Connector($loop, array( 'happy_eyeballs' => false )); 同样，您还可以如下影响默认的DNS行为。 Connector类将尝试检测您的系统DNS设置（如果无法确定您的系统设置，并使用Google的公共DNS服务器8.8.8.8作为备用）， 默认情况下会将所有公共主机名解析为基础IP地址。 如果您确定要使用自定义DNS服务器（例如本地DNS中继或公司范围的DNS服务器），则可以按以下方式设置Connector： $connector = new React\\Socket\\Connector($loop, array( 'dns' => '127.0.1.1' )); $connector->connect('localhost:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 如果您想直接连接IP地址，不使用DNS解析器，可以这样设置Connector： $connector = new React\\Socket\\Connector($loop, array( 'dns' => false )); $connector->connect('127.0.0.1:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 高级:如果你需要一个自定义的DNS React\\Dns\\Resolver\\ResolverInterface实例，你也可以这样设置你的连接器: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $resolver = $dnsResolverFactory->createCached('127.0.1.1', $loop); $connector = new React\\Socket\\Connector($loop, array( 'dns' => $resolver )); $connector->connect('localhost:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 默认情况下，tcp:// 和 tls:// URI方案将使用超时值，遵循default_socket_timeout ini 设置(默认为60s)。 如果你想要一个自定义的超时值，你可以这样设置: $connector = new React\\Socket\\Connector($loop, array( 'timeout' => 10.0 )); 同样，如果你不想使用超时，并让操作系统处理它，你可以传递一个bool标志，像这样: $connector = new React\\Socket\\Connector($loop, array( 'timeout' => false )); 默认情况下，Connector支持tcp://, tls:// 和 unix:// URI模式。 如果你想禁止用，你可以这样设置: // 只允许安全的TLS连接 $connector = new React\\Socket\\Connector($loop, array( 'tcp' => false, 'tls' => true, 'unix' => false, )); $connector->connect('tls://google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); tcp:// 和 tls://也接受传递给底层连接器附加的上下文选项。 如果你想显式地传递额外的上下文选项，你可以想这样传递上下文选项数组: // 允许不安全的TLS连接 $connector = new React\\Socket\\Connector($loop, array( 'tcp' => array( 'bindto' => '192.168.0.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ), )); $connector->connect('tls://localhost:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); 默认情况下，此连接器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本： $connector = new React\\Socket\\Connector($loop, array( 'tls' => array( 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT ) )); 有关上下文选项的更多详细信息，请参阅有关socket context options 和SSL context options 高级：默认情况下，Connector支持tcp://, tls:// 和 unix:// URI方案。 为此，它会自动设置所需的连接器类。如果您想显式传递自定义连接器， 则可以传递一个实现ConnectorInterface的实例，如下所示： $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $resolver = $dnsResolverFactory->createCached('127.0.1.1', $loop); $tcp = new React\\Socket\\HappyEyeBallsConnector($loop, new React\\Socket\\TcpConnector($loop), $resolver); $tls = new React\\Socket\\SecureConnector($tcp, $loop); $unix = new React\\Socket\\UnixConnector($loop); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $tcp, 'tls' => $tls, 'unix' => $unix, 'dns' => false, 'timeout' => false, )); $connector->connect('google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); tcp：//连接器将始终由DNS解析器包装，禁用DNS除外。 在这种情况下，tcp：//连接器将接收实际的主机名执行查找，而不是仅接收解析的IP地址。 在内部，自动创建的tls：//连接器始终包装基础的tcp：//连接器， 以在启用安全TLS模式之前建立基础的纯文本TCP / IP连接。 如果您只想将自定义基础tcp：//连接器仅用于安全的TLS连接，则可以像上面那样显式地传递tls：//连接器。 tcp：//和tls：//连接器将始终由TimeoutConnector包装，禁用超时除外。 高级客户端使用 TcpConnector TcpConnector类实现ConnectorInterface，并允许您创建到任何IP端口组合的纯文本TCP / IP连接： $tcpConnector = new React\\Socket\\TcpConnector($loop); $tcpConnector->connect('127.0.0.1:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 参阅 examples. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示： $promise = $tcpConnector->connect('127.0.0.1:80'); $promise->cancel(); 对挂起的承诺调用cancel()将关闭底层套接字资源，从而取消挂起的TCP/IP连接，并拒绝生成的承诺。 您可以选择将其他socket context options 传递给构造函数，如下所示： $tcpConnector = new React\\Socket\\TcpConnector($loop, array( 'bindto' => '192.168.0.1:0' )); 请注意，此类仅允许您连接到IP端口组合。 如果给定的URI无效，不包含有效的IP地址和端口或包含任何其他方案，则它将以InvalidArgumentException拒绝： 如果给定的URI似乎有效，但是连接失败（例如，远程主机拒绝连接等），它将以RuntimeException拒绝。 如果要连接到主机名-端口组合，请参见以下章节。 高级用法:TcpConnector内部为每个流资源分配一个空的context资源。 如果目标URI包含一个hostname查询参数，则它的值将用于设置TLS对等名称。 SecureConnector和DnsConnector会使用它来验证对端名称，如果您想要自定义TLS对端名称，也可以使用它。 HappyEyeBallsConnector HappyEyeBallsConnector类实现了ConnectorInterface， 并允许您创建到任何主机名-端口组合的纯文本TCP/IP连接。 内部实现了happy eyeballs算法RFC6555 和RFC8305来支持IPv6和IPv4主机名。 它通过装饰给定的TcpConnector实例来实现， 首先通过DNS(如果适用的话)查找给定的域名，然后建立到已解析的目标IP地址的底层TCP/IP连接。 设置你的DNS解析器和底层TCP连接器: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $dns = $dnsResolverFactory->createCached('8.8.8.8', $loop); $dnsConnector = new React\\Socket\\HappyEyeBallsConnector($loop, $tcpConnector, $dns); $dnsConnector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 参阅 examples. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示： $promise = $dnsConnector->connect('www.google.com:80'); $promise->cancel(); 对挂起的承诺调用cancel()将取消基础DNS查找和/或基础TCP/IP连接，并拒绝产生的承诺。 高级用法:HappyEyeBallsConnector内部依赖于一个Resolver(解析器)来查找给定主机名的IP地址。 然后，它将用这个IP的主机名替换目标URI中的主机名，并附加一个hostname查询参数，并将这个更新后的URI传递给底层连接器。 Happy Eye Balls算法描述为给定的主机名查找IPv6和IPv4地址，因此该连接器发送两个DNS查找A和AAAA记录。 然后，它使用所有IP地址(包括v6和v4)，并尝试以50ms的间隔连接到所有IP地址。在IPv6和IPv4地址之间切换。 当连接建立时，所有其他DNS查找和连接尝试都被取消。 DnsConnector DnsConnector类实现了ConnectorInterface，并允许您创建到任何主机名-端口组合的纯文本TCP/IP连接。 它通过装饰给定的TcpConnector实例来实现，首先通过DNS(如果适用的话)查找给定的域名，然后建立到已解析的目标IP地址的底层TCP/IP连接。 这样设置你的DNS解析器和底层TCP连接器: $dnsResolverFactory = new React\\Dns\\Resolver\\Factory(); $dns = $dnsResolverFactory->createCached('8.8.8.8', $loop); $dnsConnector = new React\\Socket\\DnsConnector($tcpConnector, $dns); $dnsConnector->connect('www.google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write('...'); $connection->end(); }); $loop->run(); 参阅 examples. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示： $promise = $dnsConnector->connect('www.google.com:80'); $promise->cancel(); 对挂起的承诺调用cancel()将取消基础DNS查找和/或基础TCP/IP连接，并拒绝产生的承诺。 高级用法:DnsConnector内部依赖于React\\Dns\\Resolver\\ResolverInterface来查找给定主机名的IP地址。 然后，它将用这个IP替换目标URI中的主机名，并附加一个hostname查询参数，并将这个更新后的URI传递给底层连接器。 因此，底层连接器负责创建到目标IP地址的连接，而此查询参数可用于检查原始主机名，并由TcpConnector用于设置TLS对等名称。 如果显式地给出了hostname，则不会修改此查询参数，如果您想要自定义TLS对等端名称会，这会很有用。 SecureConnector SecureConnector类实现了ConnectorInterface，并允许您创建到任何主机名-端口组合的安全TLS(以前称为SSL)连接。 通过装饰给定的DnsConnector实例来实现，首先创建一个明文TCP/IP连接，然后在此流上启用TLS加密。 $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop); $secureConnector->connect('www.google.com:443')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"GET / HTTP/1.0\\r\\nHost: www.google.com\\r\\n\\r\\n\"); ... }); $loop->run(); 参阅 examples. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示： $promise = $secureConnector->connect('www.google.com:443'); $promise->cancel(); 对挂起的承诺调用cancel()将取消底层TCP/IP连接和/或SSL/TLS协商，并拒绝产生的承诺。 您可以选择传递额外的SSL context options 到构造函数，像这样： $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop, array( 'verify_peer' => false, 'verify_peer_name' => false )); 默认情况下，此连接器支持TLSv1.0 +，并且不支持旧版SSLv2 / SSLv3。 从PHP 5.6+开始，您还可以显式选择要与远程端协商的TLS版本： $secureConnector = new React\\Socket\\SecureConnector($dnsConnector, $loop, array( 'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT )); 高级用法：SecureConnector 内部依赖于在基础流资源上设置所需的context options。 因此，它应该与连接器堆栈中某处的TcpConnector一起使用，以便它可以为每个流资源分配一个空的context资源并验证对等名称 否则所有流资源都将使用单个共享的default context资源，可能会导致TLS对等名称不匹配错误或某些难以跟踪的竞争条件。 TimeoutConnector TimeoutConnector类实现了ConnectorInterface，并允许您将超时处理添加到现有的连接器实例中。 通过装饰给定的 ConnectorInterface实例并启动一个计时器来完成，如果时间太长，该计时器将自动拒绝并中止连接尝试。 $timeoutConnector = new React\\Socket\\TimeoutConnector($connector, 3.0, $loop); $timeoutConnector->connect('google.com:80')->then(function (React\\Socket\\ConnectionInterface $connection) { // connection succeeded within 3.0 seconds }); 另请参阅 examples. 挂起的连接可以通过取消其挂起的承诺来取消，如下所示： $promise = $timeoutConnector->connect('google.com:80'); $promise->cancel(); 对挂起的承诺调用cancel()将取消基础连接尝试，中止计时器并拒绝产生的承诺。 UnixConnector UnixConnector类实现了ConnectorInterface ，并允许你连接到Unix域套接字(UDS)路径，如下所示: $connector = new React\\Socket\\UnixConnector($loop); $connector->connect('/tmp/demo.sock')->then(function (React\\Socket\\ConnectionInterface $connection) { $connection->write(\"HELLO\\n\"); }); $loop->run(); 连接到Unix域套接字是一个原子操作，即它的承诺将立即兑现(履行或拒绝)。 因此，对产生的promise调用cancel()不起作用。 getRemoteAddress()方法将返回与connect()方法相同的目标Unix域套接字(UDS)路径， 前面加上unix://方案，例如unix:///tmp/demo.sock。 [getLocalAddress()]方法很可能返回一个null值，因为这个值不适用于这里的UDS连接。 FixedUriConnector FixedUriConnector类实现了ConnectorInterface， 并装饰现有的连接器，以始终使用固定的、预先配置的URI。 这对于不支持特定uri的用户很有用，比如当你想显式连接到Unix域套接字(UDS)路径，而不是连接到高级API假设的默认地址: $connector = new React\\Socket\\FixedUriConnector( 'unix:///var/run/docker.sock', new React\\Socket\\UnixConnector($loop) ); // destination will be ignored, actually connects to Unix domain socket $promise = $connector->connect('localhost:80'); 安装 推荐的安装这个库的方法是通过Composer。 Composer 新手? 该项目遵循SemVer ， 默认安装最新支持的版本: $ composer require react/socket:^1.6 有关版本升级的详细信息，请参阅CHANGELOG 该项目旨在在任何平台上运行，因此不需要任何PHP扩展，并支持通过当前PHP 7+和HHVM在旧版PHP 5.3上运行。 强烈建议对此项目使用PHP 7+，一是因为它的性能得到了很大的提高，二是因为旧版PHP版本需要采取以下几种解决方法。 安全TLS连接从PHP 5.6开始进行了一些重大升级，默认设置更加安全，而旧版本则需要显式设置上下文选项。 该库对这些上下文选项不承担任何责任，因此，由该库的使用者负责设置适当的上下文选项。 PHP PHP 这个项目也支持在HHVM上运行。 注意，HHVM stream_socket_enable_crypto()函数。 因此，尝试在受影响的版本上创建安全TLS连接将返回一个被拒绝的承诺。 我们的测试套件也涉及此问题，它将跳过受影响版本的相关测试。 测试 要运行测试套件，首先需要克隆这个存储库，然后安装所有依赖项通过Composer: $ composer install 要运行测试套件，请转到项目根目录并运行: $ php vendor/bin/phpunit 该测试套件还包含许多依赖稳定internet连接的功能集成测试。 如果您不想运行这些，则可以像这样跳过它们： $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"3.Protocol-Components/Dns.html":{"url":"3.Protocol-Components/Dns.html","title":"Dns","keywords":"","body":"Dns Async DNS resolver for ReactPHP. The main point of the DNS component is to provide async DNS resolution. However, it is really a toolkit for working with DNS messages, and could easily be used to create a DNS server. Table of contents Basic usage Caching Custom cache adapter ResolverInterface resolve() resolveAll() Advanced usage UdpTransportExecutor TcpTransportExecutor SelectiveTransportExecutor HostsFileExecutor Install Tests License References Basic usage The most basic usage is to just create a resolver through the resolver factory. All you need to give it is a nameserver, then you can start resolving names, baby! $loop = React\\EventLoop\\Factory::create(); $config = React\\Dns\\Config\\Config::loadSystemConfigBlocking(); $server = $config->nameservers ? reset($config->nameservers) : '8.8.8.8'; $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->create($server, $loop); $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); $loop->run(); See also the first example. The Config class can be used to load the system default config. This is an operation that may access the filesystem and block. Ideally, this method should thus be executed only once before the loop starts and not repeatedly while it is running. Note that this class may return an empty configuration if the system config can not be loaded. As such, you'll likely want to apply a default nameserver as above if none can be found. Note that the factory loads the hosts file from the filesystem once when creating the resolver instance. Ideally, this method should thus be executed only once before the loop starts and not repeatedly while it is running. But there's more. Caching You can cache results by configuring the resolver to use a CachedExecutor: $loop = React\\EventLoop\\Factory::create(); $config = React\\Dns\\Config\\Config::loadSystemConfigBlocking(); $server = $config->nameservers ? reset($config->nameservers) : '8.8.8.8'; $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->createCached($server, $loop); $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); ... $dns->resolve('igor.io')->then(function ($ip) { echo \"Host: $ip\\n\"; }); $loop->run(); If the first call returns before the second, only one query will be executed. The second result will be served from an in memory cache. This is particularly useful for long running scripts where the same hostnames have to be looked up multiple times. See also the third example. Custom cache adapter By default, the above will use an in memory cache. You can also specify a custom cache implementing CacheInterface to handle the record cache instead: $cache = new React\\Cache\\ArrayCache(); $loop = React\\EventLoop\\Factory::create(); $factory = new React\\Dns\\Resolver\\Factory(); $dns = $factory->createCached('8.8.8.8', $loop, $cache); See also the wiki for possible cache implementations. ResolverInterface resolve() The resolve(string $domain): PromiseInterface method can be used to resolve the given $domain name to a single IPv4 address (type A query). $resolver->resolve('reactphp.org')->then(function ($ip) { echo 'IP for reactphp.org is ' . $ip . PHP_EOL; }); This is one of the main methods in this package. It sends a DNS query for the given $domain name to your DNS server and returns a single IP address on success. If the DNS server sends a DNS response message that contains more than one IP address for this query, it will randomly pick one of the IP addresses from the response. If you want the full list of IP addresses or want to send a different type of query, you should use the resolveAll() method instead. If the DNS server sends a DNS response message that indicates an error code, this method will reject with a RecordNotFoundException. Its message and code can be used to check for the response code. If the DNS communication fails and the server does not respond with a valid response message, this message will reject with an Exception. Pending DNS queries can be cancelled by cancelling its pending promise like so: $promise = $resolver->resolve('reactphp.org'); $promise->cancel(); resolveAll() The resolveAll(string $host, int $type): PromiseInterface method can be used to resolve all record values for the given $domain name and query $type. $resolver->resolveAll('reactphp.org', Message::TYPE_A)->then(function ($ips) { echo 'IPv4 addresses for reactphp.org ' . implode(', ', $ips) . PHP_EOL; }); $resolver->resolveAll('reactphp.org', Message::TYPE_AAAA)->then(function ($ips) { echo 'IPv6 addresses for reactphp.org ' . implode(', ', $ips) . PHP_EOL; }); This is one of the main methods in this package. It sends a DNS query for the given $domain name to your DNS server and returns a list with all record values on success. If the DNS server sends a DNS response message that contains one or more records for this query, it will return a list with all record values from the response. You can use the Message::TYPE_* constants to control which type of query will be sent. Note that this method always returns a list of record values, but each record value type depends on the query type. For example, it returns the IPv4 addresses for type A queries, the IPv6 addresses for type AAAA queries, the hostname for type NS, CNAME and PTR queries and structured data for other queries. See also the Record documentation for more details. If the DNS server sends a DNS response message that indicates an error code, this method will reject with a RecordNotFoundException. Its message and code can be used to check for the response code. If the DNS communication fails and the server does not respond with a valid response message, this message will reject with an Exception. Pending DNS queries can be cancelled by cancelling its pending promise like so: $promise = $resolver->resolveAll('reactphp.org', Message::TYPE_AAAA); $promise->cancel(); Advanced Usage UdpTransportExecutor The UdpTransportExecutor can be used to send DNS queries over a UDP transport. This is the main class that sends a DNS query to your DNS server and is used internally by the Resolver for the actual message transport. For more advanced usages one can utilize this class directly. The following example looks up the IPv6 address for igor.io. $loop = Factory::create(); $executor = new UdpTransportExecutor('8.8.8.8:53', $loop); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); $loop->run(); See also the fourth example. Note that this executor does not implement a timeout, so you will very likely want to use this in combination with a TimeoutExecutor like this: $executor = new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ); Also note that this executor uses an unreliable UDP transport and that it does not implement any retry logic, so you will likely want to use this in combination with a RetryExecutor like this: $executor = new RetryExecutor( new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ) ); Note that this executor is entirely async and as such allows you to execute any number of queries concurrently. You should probably limit the number of concurrent queries in your application or you're very likely going to face rate limitations and bans on the resolver end. For many common applications, you may want to avoid sending the same query multiple times when the first one is still pending, so you will likely want to use this in combination with a CoopExecutor like this: $executor = new CoopExecutor( new RetryExecutor( new TimeoutExecutor( new UdpTransportExecutor($nameserver, $loop), 3.0, $loop ) ) ); Internally, this class uses PHP's UDP sockets and does not take advantage of react/datagram purely for organizational reasons to avoid a cyclic dependency between the two packages. Higher-level components should take advantage of the Datagram component instead of reimplementing this socket logic from scratch. TcpTransportExecutor The TcpTransportExecutor class can be used to send DNS queries over a TCP/IP stream transport. This is one of the main classes that send a DNS query to your DNS server. For more advanced usages one can utilize this class directly. The following example looks up the IPv6 address for reactphp.org. $loop = Factory::create(); $executor = new TcpTransportExecutor('8.8.8.8:53', $loop); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); $loop->run(); See also example #92. Note that this executor does not implement a timeout, so you will very likely want to use this in combination with a TimeoutExecutor like this: $executor = new TimeoutExecutor( new TcpTransportExecutor($nameserver, $loop), 3.0, $loop ); Unlike the UdpTransportExecutor, this class uses a reliable TCP/IP transport, so you do not necessarily have to implement any retry logic. Note that this executor is entirely async and as such allows you to execute queries concurrently. The first query will establish a TCP/IP socket connection to the DNS server which will be kept open for a short period. Additional queries will automatically reuse this existing socket connection to the DNS server, will pipeline multiple requests over this single connection and will keep an idle connection open for a short period. The initial TCP/IP connection overhead may incur a slight delay if you only send occasional queries – when sending a larger number of concurrent queries over an existing connection, it becomes increasingly more efficient and avoids creating many concurrent sockets like the UDP-based executor. You may still want to limit the number of (concurrent) queries in your application or you may be facing rate limitations and bans on the resolver end. For many common applications, you may want to avoid sending the same query multiple times when the first one is still pending, so you will likely want to use this in combination with a CoopExecutor like this: $executor = new CoopExecutor( new TimeoutExecutor( new TcpTransportExecutor($nameserver, $loop), 3.0, $loop ) ); Internally, this class uses PHP's TCP/IP sockets and does not take advantage of react/socket purely for organizational reasons to avoid a cyclic dependency between the two packages. Higher-level components should take advantage of the Socket component instead of reimplementing this socket logic from scratch. SelectiveTransportExecutor The SelectiveTransportExecutor class can be used to Send DNS queries over a UDP or TCP/IP stream transport. This class will automatically choose the correct transport protocol to send a DNS query to your DNS server. It will always try to send it over the more efficient UDP transport first. If this query yields a size related issue (truncated messages), it will retry over a streaming TCP/IP transport. For more advanced usages one can utilize this class directly. The following example looks up the IPv6 address for reactphp.org. $executor = new SelectiveTransportExecutor($udpExecutor, $tcpExecutor); $executor->query( new Query($name, Message::TYPE_AAAA, Message::CLASS_IN) )->then(function (Message $message) { foreach ($message->answers as $answer) { echo 'IPv6: ' . $answer->data . PHP_EOL; } }, 'printf'); Note that this executor only implements the logic to select the correct transport for the given DNS query. Implementing the correct transport logic, implementing timeouts and any retry logic is left up to the given executors, see also UdpTransportExecutor and TcpTransportExecutor for more details. Note that this executor is entirely async and as such allows you to execute any number of queries concurrently. You should probably limit the number of concurrent queries in your application or you're very likely going to face rate limitations and bans on the resolver end. For many common applications, you may want to avoid sending the same query multiple times when the first one is still pending, so you will likely want to use this in combination with a CoopExecutor like this: $executor = new CoopExecutor( new SelectiveTransportExecutor( $datagramExecutor, $streamExecutor ) ); HostsFileExecutor Note that the above UdpTransportExecutor class always performs an actual DNS query. If you also want to take entries from your hosts file into account, you may use this code: $hosts = \\React\\Dns\\Config\\HostsFile::loadFromPathBlocking(); $executor = new UdpTransportExecutor('8.8.8.8:53', $loop); $executor = new HostsFileExecutor($hosts, $executor); $executor->query( new Query('localhost', Message::TYPE_A, Message::CLASS_IN) ); Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/dns:^1.4 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. References RFC 1034 Domain Names - Concepts and Facilities RFC 1035 Domain Names - Implementation and Specification "},"3.Protocol-Components/Http.html":{"url":"3.Protocol-Components/Http.html","title":"Http","keywords":"","body":"HTTP Event-driven, streaming HTTP client and server implementation for ReactPHP. This HTTP library provides re-usable implementations for an HTTP client and server based on ReactPHP's Socket and EventLoop components. Its client component allows you to send any number of async HTTP/HTTPS requests concurrently. Its server component allows you to build plaintext HTTP and secure HTTPS servers that accept incoming HTTP requests from HTTP clients (such as web browsers). This library provides async, streaming means for all of this, so you can handle multiple concurrent HTTP requests without blocking. Table of contents Quickstart example Client Usage Request methods Promises Cancellation Timeouts Authentication Redirects Blocking Concurrency Streaming response Streaming request HTTP proxy SOCKS proxy SSH proxy Unix domain sockets Server Usage Server listen() Server Request Request parameters Query parameters Request body Streaming incoming request Request method Cookie parameters Invalid request Server Response Deferred response Streaming outgoing response Response length Invalid response Default response headers Middleware Custom middleware Third-Party Middleware API Browser get() post() head() patch() put() delete() request() requestStreaming() withTimeout() withFollowRedirects() withRejectErrorResponse() withBase() withProtocolVersion() withResponseBuffer() React\\Http\\Message Response ServerRequest ResponseException React\\Http\\Middleware StreamingRequestMiddleware LimitConcurrentRequestsMiddleware RequestBodyBufferMiddleware RequestBodyParserMiddleware Install Tests License Quickstart example Once installed, you can use the following code to access a HTTP webserver and send some simple HTTP GET requests: $loop = React\\EventLoop\\Factory::create(); $client = new React\\Http\\Browser($loop); $client->get('http://www.google.com/')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders(), (string)$response->getBody()); }); $loop->run(); This is an HTTP server which responds with Hello World! to every request. $loop = React\\EventLoop\\Factory::create(); $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); $socket = new React\\Socket\\Server(8080, $loop); $server->listen($socket); $loop->run(); See also the examples. Client Usage Request methods Most importantly, this project provides a Browser object that offers several methods that resemble the HTTP protocol methods: $browser->get($url, array $headers = array()); $browser->head($url, array $headers = array()); $browser->post($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->delete($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->put($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); $browser->patch($url, array $headers = array(), string|ReadableStreamInterface $contents = ''); Each of these methods requires a $url and some optional parameters to send an HTTP request. Each of these method names matches the respective HTTP request method, for example the get() method sends an HTTP GET request. You can optionally pass an associative array of additional $headers that will be sent with this HTTP request. Additionally, each method will automatically add a matching Content-Length request header if an outgoing request body is given and its size is known and non-empty. For an empty request body, if will only include a Content-Length: 0 request header if the request method usually expects a request body (only applies to POST, PUT and PATCH HTTP request methods). If you're using a streaming request body, it will default to using Transfer-Encoding: chunked unless you explicitly pass in a matching Content-Length request header. See also streaming request for more details. By default, all of the above methods default to sending requests using the HTTP/1.1 protocol version. If you want to explicitly use the legacy HTTP/1.0 protocol version, you can use the withProtocolVersion() method. If you want to use any other or even custom HTTP request method, you can use the request() method. Each of the above methods supports async operation and either fulfills with a PSR-7 ResponseInterface or rejects with an Exception. Please see the following chapter about promises for more details. Promises Sending requests is async (non-blocking), so you can actually send multiple requests in parallel. The Browser will respond to each request with a PSR-7 ResponseInterface message, the order is not guaranteed. Sending requests uses a Promise-based interface that makes it easy to react to when an HTTP request is completed (i.e. either successfully fulfilled or rejected with an error): $browser->get($url)->then( function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump('Response received', $response); }, function (Exception $error) { var_dump('There was an error', $error->getMessage()); } ); If this looks strange to you, you can also use the more traditional blocking API. Keep in mind that resolving the Promise with the full response message means the whole response body has to be kept in memory. This is easy to get started and works reasonably well for smaller responses (such as common HTML pages or RESTful or JSON API requests). You may also want to look into the streaming API: If you're dealing with lots of concurrent requests (100+) or If you want to process individual data chunks as they happen (without having to wait for the full response body) or If you're expecting a big response body size (1 MiB or more, for example when downloading binary files) or If you're unsure about the response body size (better be safe than sorry when accessing arbitrary remote HTTP endpoints and the response body size is unknown in advance). Cancellation The returned Promise is implemented in such a way that it can be cancelled when it is still pending. Cancelling a pending promise will reject its value with an Exception and clean up any underlying resources. $promise = $browser->get($url); $loop->addTimer(2.0, function () use ($promise) { $promise->cancel(); }); Timeouts This library uses a very efficient HTTP implementation, so most HTTP requests should usually be completed in mere milliseconds. However, when sending HTTP requests over an unreliable network (the internet), there are a number of things that can go wrong and may cause the request to fail after a time. As such, this library respects PHP's default_socket_timeout setting (default 60s) as a timeout for sending the outgoing HTTP request and waiting for a successful response and will otherwise cancel the pending request and reject its value with an Exception. Note that this timeout value covers creating the underlying transport connection, sending the HTTP request, receiving the HTTP response headers and its full response body and following any eventual redirects. See also redirects below to configure the number of redirects to follow (or disable following redirects altogether) and also streaming below to not take receiving large response bodies into account for this timeout. You can use the withTimeout() method to pass a custom timeout value in seconds like this: $browser = $browser->withTimeout(10.0); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // response received within 10 seconds maximum var_dump($response->getHeaders()); }); Similarly, you can use a bool false to not apply a timeout at all or use a bool true value to restore the default handling. See withTimeout() for more details. If you're using a streaming response body, the time it takes to receive the response body stream will not be included in the timeout. This allows you to keep this incoming stream open for a longer time, such as when downloading a very large stream or when streaming data over a long-lived connection. If you're using a streaming request body, the time it takes to send the request body stream will not be included in the timeout. This allows you to keep this outgoing stream open for a longer time, such as when uploading a very large stream. Note that this timeout handling applies to the higher-level HTTP layer. Lower layers such as socket and DNS may also apply (different) timeout values. In particular, the underlying socket connection uses the same default_socket_timeout setting to establish the underlying transport connection. To control this connection timeout behavior, you can inject a custom Connector like this: $browser = new React\\Http\\Browser( $loop, new React\\Socket\\Connector( $loop, array( 'timeout' => 5 ) ) ); Authentication This library supports HTTP Basic Authentication using the Authorization: Basic … request header or allows you to set an explicit Authorization request header. By default, this library does not include an outgoing Authorization request header. If the server requires authentication, if may return a 401 (Unauthorized) status code which will reject the request by default (see also the withRejectErrorResponse() method below). In order to pass authentication details, you can simply pass the username and password as part of the request URL like this: $promise = $browser->get('https://user:pass@example.com/api'); Note that special characters in the authentication details have to be percent-encoded, see also rawurlencode(). This example will automatically pass the base64-encoded authentication details using the outgoing Authorization: Basic … request header. If the HTTP endpoint you're talking to requires any other authentication scheme, you can also pass this header explicitly. This is common when using (RESTful) HTTP APIs that use OAuth access tokens or JSON Web Tokens (JWT): $token = 'abc123'; $promise = $browser->get( 'https://example.com/api', array( 'Authorization' => 'Bearer ' . $token ) ); When following redirects, the Authorization request header will never be sent to any remote hosts by default. When following a redirect where the Location response header contains authentication details, these details will be sent for following requests. See also redirects below. Redirects By default, this library follows any redirects and obeys 3xx (Redirection) status codes using the Location response header from the remote server. The promise will be fulfilled with the last response from the chain of redirects. $browser->get($url, $headers)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // the final response will end up here var_dump($response->getHeaders()); }); Any redirected requests will follow the semantics of the original request and will include the same request headers as the original request except for those listed below. If the original request contained a request body, this request body will never be passed to the redirected request. Accordingly, each redirected request will remove any Content-Length and Content-Type request headers. If the original request used HTTP authentication with an Authorization request header, this request header will only be passed as part of the redirected request if the redirected URL is using the same host. In other words, the Authorizaton request header will not be forwarded to other foreign hosts due to possible privacy/security concerns. When following a redirect where the Location response header contains authentication details, these details will be sent for following requests. You can use the withFollowRedirects() method to control the maximum number of redirects to follow or to return any redirect responses as-is and apply custom redirection logic like this: $browser = $browser->withFollowRedirects(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any redirects will now end up here var_dump($response->getHeaders()); }); See also withFollowRedirects() for more details. Blocking As stated above, this library provides you a powerful, async API by default. If, however, you want to integrate this into your traditional, blocking environment, you should look into also using clue/reactphp-block. The resulting blocking code could look something like this: use Clue\\React\\Block; $loop = React\\EventLoop\\Factory::create(); $browser = new React\\Http\\Browser($loop); $promise = $browser->get('http://example.com/'); try { $response = Block\\await($promise, $loop); // response successfully received } catch (Exception $e) { // an error occured while performing the request } Similarly, you can also process multiple requests concurrently and await an array of Response objects: $promises = array( $browser->get('http://example.com/'), $browser->get('http://www.example.org/'), ); $responses = Block\\awaitAll($promises, $loop); Please refer to clue/reactphp-block for more details. Keep in mind the above remark about buffering the whole response message in memory. As an alternative, you may also see one of the following chapters for the streaming API. Concurrency As stated above, this library provides you a powerful, async API. Being able to send a large number of requests at once is one of the core features of this project. For instance, you can easily send 100 requests concurrently while processing SQL queries at the same time. Remember, with great power comes great responsibility. Sending an excessive number of requests may either take up all resources on your side or it may even get you banned by the remote side if it sees an unreasonable number of requests from your side. // watch out if array contains many elements foreach ($urls as $url) { $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); } As a consequence, it's usually recommended to limit concurrency on the sending side to a reasonable value. It's common to use a rather small limit, as doing more than a dozen of things at once may easily overwhelm the receiving side. You can use clue/reactphp-mq as a lightweight in-memory queue to concurrently do many (but not too many) things at once: // wraps Browser in a Queue object that executes no more than 10 operations at once $q = new Clue\\React\\Mq\\Queue(10, null, function ($url) use ($browser) { return $browser->get($url); }); foreach ($urls as $url) { $q($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); } Additional requests that exceed the concurrency limit will automatically be enqueued until one of the pending requests completes. This integrates nicely with the existing Promise-based API. Please refer to clue/reactphp-mq for more details. This in-memory approach works reasonably well for some thousand outstanding requests. If you're processing a very large input list (think millions of rows in a CSV or NDJSON file), you may want to look into using a streaming approach instead. See clue/reactphp-flux for more details. Streaming response All of the above examples assume you want to store the whole response body in memory. This is easy to get started and works reasonably well for smaller responses. However, there are several situations where it's usually a better idea to use a streaming approach, where only small chunks have to be kept in memory: If you're dealing with lots of concurrent requests (100+) or If you want to process individual data chunks as they happen (without having to wait for the full response body) or If you're expecting a big response body size (1 MiB or more, for example when downloading binary files) or If you're unsure about the response body size (better be safe than sorry when accessing arbitrary remote HTTP endpoints and the response body size is unknown in advance). You can use the requestStreaming() method to send an arbitrary HTTP request and receive a streaming response. It uses the same HTTP message API, but does not buffer the response body in memory. It only processes the response body in small chunks as data is received and forwards this data through ReactPHP's Stream API. This works for (any number of) responses of arbitrary sizes. This means it resolves with a normal PSR-7 ResponseInterface, which can be used to access the response message parameters as usual. You can access the message body as usual, however it now also implements ReactPHP's ReadableStreamInterface as well as parts of the PSR-7 StreamInterface. $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { $body = $response->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); $body->on('data', function ($chunk) { echo $chunk; }); $body->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage() . PHP_EOL; }); $body->on('close', function () { echo '[DONE]' . PHP_EOL; }); }); See also the stream download benchmark example and the stream forwarding example. You can invoke the following methods on the message body: $body->on($event, $callback); $body->eof(); $body->isReadable(); $body->pipe(React\\Stream\\WritableStreamInterface $dest, array $options = array()); $body->close(); $body->pause(); $body->resume(); Because the message body is in a streaming state, invoking the following methods doesn't make much sense: $body->__toString(); // '' $body->detach(); // throws BadMethodCallException $body->getSize(); // null $body->tell(); // throws BadMethodCallException $body->isSeekable(); // false $body->seek(); // throws BadMethodCallException $body->rewind(); // throws BadMethodCallException $body->isWritable(); // false $body->write(); // throws BadMethodCallException $body->read(); // throws BadMethodCallException $body->getContents(); // throws BadMethodCallException Note how timeouts apply slightly differently when using streaming. In streaming mode, the timeout value covers creating the underlying transport connection, sending the HTTP request, receiving the HTTP response headers and following any eventual redirects. In particular, the timeout value does not take receiving (possibly large) response bodies into account. If you want to integrate the streaming response into a higher level API, then working with Promise objects that resolve with Stream objects is often inconvenient. Consider looking into also using react/promise-stream. The resulting streaming code could look something like this: use React\\Promise\\Stream; function download(Browser $browser, string $url): React\\Stream\\ReadableStreamInterface { return Stream\\unwrapReadable( $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { return $response->getBody(); }) ); } $stream = download($browser, $url); $stream->on('data', function ($data) { echo $data; }); See also the requestStreaming() method for more details. Streaming request Besides streaming the response body, you can also stream the request body. This can be useful if you want to send big POST requests (uploading files etc.) or process many outgoing streams at once. Instead of passing the body as a string, you can simply pass an instance implementing ReactPHP's ReadableStreamInterface to the request methods like this: $browser->post($url, array(), $stream)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { echo 'Successfully sent.'; }); If you're using a streaming request body (React\\Stream\\ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->post($url, array('Content-Length' => '11'), $body); If the streaming request body emits an error event or is explicitly closed without emitting a successful end event first, the request will automatically be closed and rejected. HTTP proxy You can also establish your outgoing connections through an HTTP CONNECT proxy server by adding a dependency to clue/reactphp-http-proxy. HTTP CONNECT proxy servers (also commonly known as \"HTTPS proxy\" or \"SSL proxy\") are commonly used to tunnel HTTPS traffic through an intermediary (\"proxy\"), to conceal the origin address (anonymity) or to circumvent address blocking (geoblocking). While many (public) HTTP CONNECT proxy servers often limit this to HTTPS port443 only, this can technically be used to tunnel any TCP/IP-based protocol, such as plain HTTP and TLS-encrypted HTTPS. $proxy = new Clue\\React\\HttpProxy\\ProxyConnector( 'http://127.0.0.1:8080', new React\\Socket\\Connector($loop) ); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); See also the HTTP CONNECT proxy example. SOCKS proxy You can also establish your outgoing connections through a SOCKS proxy server by adding a dependency to clue/reactphp-socks. The SOCKS proxy protocol family (SOCKS5, SOCKS4 and SOCKS4a) is commonly used to tunnel HTTP(S) traffic through an intermediary (\"proxy\"), to conceal the origin address (anonymity) or to circumvent address blocking (geoblocking). While many (public) SOCKS proxy servers often limit this to HTTP(S) port 80 and 443 only, this can technically be used to tunnel any TCP/IP-based protocol. $proxy = new Clue\\React\\Socks\\Client( 'socks://127.0.0.1:1080', new React\\Socket\\Connector($loop) ); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); See also the SOCKS proxy example. SSH proxy You can also establish your outgoing connections through an SSH server by adding a dependency to clue/reactphp-ssh-proxy. Secure Shell (SSH) is a secure network protocol that is most commonly used to access a login shell on a remote server. Its architecture allows it to use multiple secure channels over a single connection. Among others, this can also be used to create an \"SSH tunnel\", which is commonly used to tunnel HTTP(S) traffic through an intermediary (\"proxy\"), to conceal the origin address (anonymity) or to circumvent address blocking (geoblocking). This can be used to tunnel any TCP/IP-based protocol (HTTP, SMTP, IMAP etc.), allows you to access local services that are otherwise not accessible from the outside (database behind firewall) and as such can also be used for plain HTTP and TLS-encrypted HTTPS. $proxy = new Clue\\React\\SshProxy\\SshSocksConnector('me@localhost:22', $loop); $connector = new React\\Socket\\Connector($loop, array( 'tcp' => $proxy, 'dns' => false )); $browser = new React\\Http\\Browser($loop, $connector); See also the SSH proxy example. Unix domain sockets By default, this library supports transport over plaintext TCP/IP and secure TLS connections for the http:// and https:// URL schemes respectively. This library also supports Unix domain sockets (UDS) when explicitly configured. In order to use a UDS path, you have to explicitly configure the connector to override the destination URL so that the hostname given in the request URL will no longer be used to establish the connection: $connector = new React\\Socket\\FixedUriConnector( 'unix:///var/run/docker.sock', new React\\Socket\\UnixConnector($loop) ); $browser = new Browser($loop, $connector); $client->get('http://localhost/info')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders(), (string)$response->getBody()); }); See also the Unix Domain Sockets (UDS) example. Server Usage Server The React\\Http\\Server class is responsible for handling incoming connections and then processing each incoming HTTP request. When a complete HTTP request has been received, it will invoke the given request handler function. This request handler function needs to be passed to the constructor and will be invoked with the respective request object and expects a response object in return: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); Each incoming HTTP request message is always represented by the PSR-7 ServerRequestInterface, see also following request chapter for more details. Each outgoing HTTP response message is always represented by the PSR-7 ResponseInterface, see also following response chapter for more details. In order to start listening for any incoming connections, the Server needs to be attached to an instance of React\\Socket\\ServerInterface through the listen() method as described in the following chapter. In its most simple form, you can attach this to a React\\Socket\\Server in order to start a plaintext HTTP server like this: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('0.0.0.0:8080', $loop); $server->listen($socket); See also the listen() method and the hello world server example for more details. By default, the Server buffers and parses the complete incoming HTTP request in memory. It will invoke the given request handler function when the complete request headers and request body has been received. This means the request object passed to your request handler function will be fully compatible with PSR-7 (http-message). This provides sane defaults for 80% of the use cases and is the recommended way to use this library unless you're sure you know what you're doing. On the other hand, buffering complete HTTP requests in memory until they can be processed by your request handler function means that this class has to employ a number of limits to avoid consuming too much memory. In order to take the more advanced configuration out your hand, it respects setting from your php.ini to apply its default settings. This is a list of PHP settings this class respects with their respective default values: memory_limit 128M post_max_size 8M // capped at 64K enable_post_data_reading 1 max_input_nesting_level 64 max_input_vars 1000 file_uploads 1 upload_max_filesize 2M max_file_uploads 20 In particular, the post_max_size setting limits how much memory a single HTTP request is allowed to consume while buffering its request body. This needs to be limited because the server can process a large number of requests concurrently, so the server may potentially consume a large amount of memory otherwise. To support higher concurrency by default, this value is capped at 64K. If you assign a higher value, it will only allow 64K by default. If a request exceeds this limit, its request body will be ignored and it will be processed like a request with no request body at all. See below for explicit configuration to override this setting. By default, this class will try to avoid consuming more than half of your memory_limit for buffering multiple concurrent HTTP requests. As such, with the above default settings of 128M max, it will try to consume no more than 64M for buffering multiple concurrent HTTP requests. As a consequence, it will limit the concurrency to 1024 HTTP requests with the above defaults. It is imperative that you assign reasonable values to your PHP ini settings. It is usually recommended to not support buffering incoming HTTP requests with a large HTTP request body (e.g. large file uploads). If you want to increase this buffer size, you will have to also increase the total memory limit to allow for more concurrent requests (set memory_limit 512M or more) or explicitly limit concurrency. In order to override the above buffering defaults, you can configure the Server explicitly. You can use the LimitConcurrentRequestsMiddleware and RequestBodyBufferMiddleware (see below) to explicitly configure the total number of requests that can be handled at once like this: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); In this example, we allow processing up to 100 concurrent requests at once and each request can buffer up to 2M. This means you may have to keep a maximum of 200M of memory for incoming request body buffers. Accordingly, you need to adjust the memory_limit ini setting to allow for these buffers plus your actual application logic memory requirements (think 512M or more). Internally, this class automatically assigns these middleware handlers automatically when no StreamingRequestMiddleware is given. Accordingly, you can use this example to override all default settings to implement custom limits. As an alternative to buffering the complete request body in memory, you can also use a streaming approach where only small chunks of data have to be kept in memory: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), $handler ); In this case, it will invoke the request handler function once the HTTP request headers have been received, i.e. before receiving the potentially much larger HTTP request body. This means the request passed to your request handler function may not be fully compatible with PSR-7. This is specifically designed to help with more advanced use cases where you want to have full control over consuming the incoming HTTP request body and concurrency settings. See also streaming incoming request below for more details. listen() The listen(React\\Socket\\ServerInterface $socket): void method can be used to start listening for HTTP requests on the given socket server instance. The given React\\Socket\\ServerInterface is responsible for emitting the underlying streaming connections. This HTTP server needs to be attached to it in order to process any connections and pase incoming streaming data as incoming HTTP request messages. In its most common form, you can attach this to a React\\Socket\\Server in order to start a plaintext HTTP server like this: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('0.0.0.0:8080', $loop); $server->listen($socket); See also hello world server example for more details. This example will start listening for HTTP requests on the alternative HTTP port 8080 on all interfaces (publicly). As an alternative, it is very common to use a reverse proxy and let this HTTP server listen on the localhost (loopback) interface only by using the listen address 127.0.0.1:8080 instead. This way, you host your application(s) on the default HTTP port 80 and only route specific requests to this HTTP server. Likewise, it's usually recommended to use a reverse proxy setup to accept secure HTTPS requests on default HTTPS port 443 (TLS termination) and only route plaintext requests to this HTTP server. As an alternative, you can also accept secure HTTPS requests with this HTTP server by attaching this to a React\\Socket\\Server using a secure TLS listen address, a certificate file and optional passphrase like this: $server = new React\\Http\\Server($loop, $handler); $socket = new React\\Socket\\Server('tls://0.0.0.0:8443', $loop, array( 'local_cert' => __DIR__ . '/localhost.pem' )); $server->listen($socket); See also hello world HTTPS example for more details. Server Request As seen above, the Server class is responsible for handling incoming connections and then processing each incoming HTTP request. The request object will be processed once the request has been received by the client. This request object implements the PSR-7 ServerRequestInterface which in turn extends the PSR-7 RequestInterface and will be passed to the callback function like this. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = \"The method of the request is: \" . $request->getMethod(); $body .= \"The requested path is: \" . $request->getUri()->getPath(); return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); }); For more details about the request object, also check out the documentation of PSR-7 ServerRequestInterface and PSR-7 RequestInterface. Request parameters The getServerParams(): mixed[] method can be used to get server-side parameters similar to the $_SERVER variable. The following parameters are currently available: REMOTE_ADDR The IP address of the request sender REMOTE_PORT Port of the request sender SERVER_ADDR The IP address of the server SERVER_PORT The port of the server REQUEST_TIME Unix timestamp when the complete request header has been received, as integer similar to time() REQUEST_TIME_FLOAT Unix timestamp when the complete request header has been received, as float similar to microtime(true) HTTPS Set to 'on' if the request used HTTPS, otherwise it won't be set $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = \"Your IP is: \" . $request->getServerParams()['REMOTE_ADDR']; return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); }); See also whatsmyip server example. Advanced: Note that address parameters will not be set if you're listening on a Unix domain socket (UDS) path as this protocol lacks the concept of host/port. Query parameters The getQueryParams(): array method can be used to get the query parameters similiar to the $_GET variable. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $queryParams = $request->getQueryParams(); $body = 'The query parameter \"foo\" is not set. Click the following link '; $body .= 'to use query parameter in your request'; if (isset($queryParams['foo'])) { $body = 'The value of \"foo\" is: ' . htmlspecialchars($queryParams['foo']); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/html' ), $body ); }); The response in the above example will return a response body with a link. The URL contains the query parameter foo with the value bar. Use htmlentities like in this example to prevent Cross-Site Scripting (abbreviated as XSS). See also server query parameters example. Request body By default, the Server will buffer and parse the full request body in memory. This means the given request object includes the parsed request body and any file uploads. As an alternative to the default buffering logic, you can also use the StreamingRequestMiddleware. Jump to the next chapter to learn more about how to process a streaming incoming request. As stated above, each incoming HTTP request is always represented by the PSR-7 ServerRequestInterface. This interface provides several methods that are useful when working with the incoming request body as described below. The getParsedBody(): null|array|object method can be used to get the parsed request body, similar to PHP's $_POST variable. This method may return a (possibly nested) array structure with all body parameters or a null value if the request body could not be parsed. By default, this method will only return parsed data for requests using Content-Type: application/x-www-form-urlencoded or Content-Type: multipart/form-data request headers (commonly used for POST requests for HTML form submission data). $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $name = $request->getParsedBody()['name'] ?? 'anonymous'; return new React\\Http\\Message\\Response( 200, array(), \"Hello $name!\\n\" ); }); See also form upload example for more details. The getBody(): StreamInterface method can be used to get the raw data from this request body, similar to PHP's php://input stream. This method returns an instance of the request body represented by the PSR-7 StreamInterface. This is particularly useful when using a custom request body that will not otherwise be parsed by default, such as a JSON (Content-Type: application/json) or an XML (Content-Type: application/xml) request body (which is commonly used for POST, PUT or PATCH requests in JSON-based or RESTful/RESTish APIs). $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $data = json_decode((string)$request->getBody()); $name = $data->name ?? 'anonymous'; return new React\\Http\\Message\\Response( 200, array('Content-Type' => 'application/json'), json_encode(['message' => \"Hello $name!\"]) ); }); See also JSON API server example for more details. The getUploadedFiles(): array method can be used to get the uploaded files in this request, similar to PHP's $_FILES variable. This method returns a (possibly nested) array structure with all file uploads, each represented by the PSR-7 UploadedFileInterface. This array will only be filled when using the Content-Type: multipart/form-data request header (commonly used for POST requests for HTML file uploads). $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $files = $request->getUploadedFiles(); $name = isset($files['avatar']) ? $files['avatar']->getClientFilename() : 'nothing'; return new React\\Http\\Message\\Response( 200, array(), \"Uploaded $name\\n\" ); }); See also form upload server example for more details. The getSize(): ?int method can be used to get the size of the request body, similar to PHP's $_SERVER['CONTENT_LENGTH'] variable. This method returns the complete size of the request body measured in number of bytes as defined by the message boundaries. This value may be 0 if the request message does not contain a request body (such as a simple GET request). This method operates on the buffered request body, i.e. the request body size is always known, even when the request does not specify a Content-Length request header or when using Transfer-Encoding: chunked for HTTP/1.1 requests. Note: The Server automatically takes care of handling requests with the additional Expect: 100-continue request header. When HTTP/1.1 clients want to send a bigger request body, they MAY send only the request headers with an additional Expect: 100-continue request header and wait before sending the actual (large) message body. In this case the server will automatically send an intermediary HTTP/1.1 100 Continue response to the client. This ensures you will receive the request body without a delay as expected. Streaming incoming request If you're using the advanced StreamingRequestMiddleware, the request object will be processed once the request headers have been received. This means that this happens irrespective of (i.e. before) receiving the (potentially much larger) request body. Note that this is non-standard behavior considered advanced usage. Jump to the previous chapter to learn more about how to process a buffered request body. While this may be uncommon in the PHP ecosystem, this is actually a very powerful approach that gives you several advantages not otherwise possible: React to requests before receiving a large request body, such as rejecting an unauthenticated request or one that exceeds allowed message lengths (file uploads). Start processing parts of the request body before the remainder of the request body arrives or if the sender is slowly streaming data. Process a large request body without having to buffer anything in memory, such as accepting a huge file upload or possibly unlimited request body stream. The getBody(): StreamInterface method can be used to access the request body stream. In the streaming mode, this method returns a stream instance that implements both the PSR-7 StreamInterface and the ReactPHP ReadableStreamInterface. However, most of the PSR-7 StreamInterface methods have been designed under the assumption of being in control of a synchronous request body. Given that this does not apply to this server, the following PSR-7 StreamInterface methods are not used and SHOULD NOT be called: tell(), eof(), seek(), rewind(), write() and read(). If this is an issue for your use case and/or you want to access uploaded files, it's highly recommended to use a buffered request body or use the RequestBodyBufferMiddleware instead. The ReactPHP ReadableStreamInterface gives you access to the incoming request body as the individual chunks arrive: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = $request->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); return new React\\Promise\\Promise(function ($resolve, $reject) use ($body) { $bytes = 0; $body->on('data', function ($data) use (&$bytes) { $bytes += strlen($data); }); $body->on('end', function () use ($resolve, &$bytes){ $resolve(new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Received $bytes bytes\\n\" )); }); // an error occures e.g. on invalid chunked encoded data or an unexpected 'end' event $body->on('error', function (\\Exception $exception) use ($resolve, &$bytes) { $resolve(new React\\Http\\Message\\Response( 400, array( 'Content-Type' => 'text/plain' ), \"Encountered error after $bytes bytes: {$exception->getMessage()}\\n\" )); }); }); } ); The above example simply counts the number of bytes received in the request body. This can be used as a skeleton for buffering or processing the request body. See also streaming request server example for more details. The data event will be emitted whenever new data is available on the request body stream. The server also automatically takes care of decoding any incoming requests using Transfer-Encoding: chunked and will only emit the actual payload as data. The end event will be emitted when the request body stream terminates successfully, i.e. it was read until its expected end. The error event will be emitted in case the request stream contains invalid data for Transfer-Encoding: chunked or when the connection closes before the complete request stream has been received. The server will automatically stop reading from the connection and discard all incoming data instead of closing it. A response message can still be sent (unless the connection is already closed). A close event will be emitted after an error or end event. For more details about the request body stream, check out the documentation of ReactPHP ReadableStreamInterface. The getSize(): ?int method can be used to get the size of the request body, similar to PHP's $_SERVER['CONTENT_LENGTH'] variable. This method returns the complete size of the request body measured in number of bytes as defined by the message boundaries. This value may be 0 if the request message does not contain a request body (such as a simple GET request). This method operates on the streaming request body, i.e. the request body size may be unknown (null) when using Transfer-Encoding: chunked for HTTP/1.1 requests. $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $size = $request->getBody()->getSize(); if ($size === null) { $body = 'The request does not contain an explicit length.'; $body .= 'This example does not accept chunked transfer encoding.'; return new React\\Http\\Message\\Response( 411, array( 'Content-Type' => 'text/plain' ), $body ); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Request body size: \" . $size . \" bytes\\n\" ); } ); Note: The Server automatically takes care of handling requests with the additional Expect: 100-continue request header. When HTTP/1.1 clients want to send a bigger request body, they MAY send only the request headers with an additional Expect: 100-continue request header and wait before sending the actual (large) message body. In this case the server will automatically send an intermediary HTTP/1.1 100 Continue response to the client. This ensures you will receive the streaming request body without a delay as expected. Request method Note that the server supports any request method (including custom and non- standard ones) and all request-target formats defined in the HTTP specs for each respective method, including normal origin-form requests as well as proxy requests in absolute-form and authority-form. The getUri(): UriInterface method can be used to get the effective request URI which provides you access to individiual URI components. Note that (depending on the given request-target) certain URI components may or may not be present, for example the getPath(): string method will return an empty string for requests in asterisk-form or authority-form. Its getHost(): string method will return the host as determined by the effective request URI, which defaults to the local socket address if a HTTP/1.0 client did not specify one (i.e. no Host header). Its getScheme(): string method will return http or https depending on whether the request was made over a secure TLS connection to the target host. The Host header value will be sanitized to match this host component plus the port component only if it is non-standard for this URI scheme. You can use getMethod(): string and getRequestTarget(): string to check this is an accepted request and may want to reject other requests with an appropriate error code, such as 400 (Bad Request) or 405 (Method Not Allowed). The CONNECT method is useful in a tunneling setup (HTTPS proxy) and not something most HTTP servers would want to care about. Note that if you want to handle this method, the client MAY send a different request-target than the Host header value (such as removing default ports) and the request-target MUST take precendence when forwarding. Cookie parameters The getCookieParams(): string[] method can be used to get all cookies sent with the current request. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { $key = 'react\\php'; if (isset($request->getCookieParams()[$key])) { $body = \"Your cookie value is: \" . $request->getCookieParams()[$key]; return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $body ); } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain', 'Set-Cookie' => urlencode($key) . '=' . urlencode('test;more') ), \"Your cookie has been set.\" ); }); The above example will try to set a cookie on first access and will try to print the cookie value on all subsequent tries. Note how the example uses the urlencode() function to encode non-alphanumeric characters. This encoding is also used internally when decoding the name and value of cookies (which is in line with other implementations, such as PHP's cookie functions). See also cookie server example for more details. Invalid request The Server class supports both HTTP/1.1 and HTTP/1.0 request messages. If a client sends an invalid request message, uses an invalid HTTP protocol version or sends an invalid Transfer-Encoding request header value, the server will automatically send a 400 (Bad Request) HTTP error response to the client and close the connection. On top of this, it will emit an error event that can be used for logging purposes like this: $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; }); Note that the server will also emit an error event if you do not return a valid response object from your request handler function. See also invalid response for more details. Server Response The callback function passed to the constructor of the Server is responsible for processing the request and returning a response, which will be delivered to the client. This function MUST return an instance implementing PSR-7 ResponseInterface object or a ReactPHP Promise which resolves with a PSR-7 ResponseInterface object. This projects ships a Response class which implements the PSR-7 ResponseInterface. In its most simple form, you can use it like this: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); We use this Response class throughout our project examples, but feel free to use any other implementation of the PSR-7 ResponseInterface. See also the Response class for more details. Deferred response The example above returns the response directly, because it needs no time to be processed. Using a database, the file system or long calculations (in fact every action that will take >=1ms) to create your response, will slow down the server. To prevent this you SHOULD use a ReactPHP Promise. This example shows how such a long-term action could look like: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { return new Promise(function ($resolve, $reject) use ($loop) { $loop->addTimer(1.5, function() use ($resolve) { $response = new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello world\" ); $resolve($response); }); }); }); The above example will create a response after 1.5 second. This example shows that you need a promise, if your response needs time to created. The ReactPHP Promise will resolve in a Response object when the request body ends. If the client closes the connection while the promise is still pending, the promise will automatically be cancelled. The promise cancellation handler can be used to clean up any pending resources allocated in this case (if applicable). If a promise is resolved after the client closes, it will simply be ignored. Streaming outgoing response The Response class in this project supports to add an instance which implements the ReactPHP ReadableStreamInterface for the response body. So you are able stream data directly into the response body. Note that other implementations of the PSR-7 ResponseInterface may only support strings. $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { $stream = new ThroughStream(); $timer = $loop->addPeriodicTimer(0.5, function () use ($stream) { $stream->write(microtime(true) . PHP_EOL); }); $loop->addTimer(5, function() use ($loop, $timer, $stream) { $loop->cancelTimer($timer); $stream->end(); }); return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $stream ); }); The above example will emit every 0.5 seconds the current Unix timestamp with microseconds as float to the client and will end after 5 seconds. This is just a example you could use of the streaming, you could also send a big amount of data via little chunks or use it for body data that needs to calculated. If the request handler resolves with a response stream that is already closed, it will simply send an empty response body. If the client closes the connection while the stream is still open, the response stream will automatically be closed. If a promise is resolved with a streaming body after the client closes, the response stream will automatically be closed. The close event can be used to clean up any pending resources allocated in this case (if applicable). Note that special care has to be taken if you use a body stream instance that implements ReactPHP's DuplexStreamInterface (such as the ThroughStream in the above example). For most cases, this will simply only consume its readable side and forward (send) any data that is emitted by the stream, thus entirely ignoring the writable side of the stream. If however this is either a 101 (Switching Protocols) response or a 2xx (Successful) response to a CONNECT method, it will also write data to the writable side of the stream. This can be avoided by either rejecting all requests with the CONNECT method (which is what most normal origin HTTP servers would likely do) or or ensuring that only ever an instance of ReactPHP's ReadableStreamInterface is used. The 101 (Switching Protocols) response code is useful for the more advanced Upgrade requests, such as upgrading to the WebSocket protocol or implementing custom protocol logic that is out of scope of the HTTP specs and this HTTP library. If you want to handle the Upgrade: WebSocket header, you will likely want to look into using Ratchet instead. If you want to handle a custom protocol, you will likely want to look into the HTTP specs and also see examples #81 and #82 for more details. In particular, the 101 (Switching Protocols) response code MUST NOT be used unless you send an Upgrade response header value that is also present in the corresponding HTTP/1.1 Upgrade request header value. The server automatically takes care of sending a Connection: upgrade header value in this case, so you don't have to. The CONNECT method is useful in a tunneling setup (HTTPS proxy) and not something most origin HTTP servers would want to care about. The HTTP specs define an opaque \"tunneling mode\" for this method and make no use of the message body. For consistency reasons, this library uses a DuplexStreamInterface in the response body for tunneled application data. This implies that that a 2xx (Successful) response to a CONNECT request can in fact use a streaming response body for the tunneled application data, so that any raw data the client sends over the connection will be piped through the writable stream for consumption. Note that while the HTTP specs make no use of the request body for CONNECT requests, one may still be present. Normal request body processing applies here and the connection will only turn to \"tunneling mode\" after the request body has been processed (which should be empty in most cases). See also HTTP CONNECT server example for more details. Response length If the response body size is known, a Content-Length response header will be added automatically. This is the most common use case, for example when using a string response body like this: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), \"Hello World!\\n\" ); }); If the response body size is unknown, a Content-Length response header can not be added automatically. When using a streaming outgoing response without an explicit Content-Length response header, outgoing HTTP/1.1 response messages will automatically use Transfer-Encoding: chunked while legacy HTTP/1.0 response messages will contain the plain response body. If you know the length of your streaming response body, you MAY want to specify it explicitly like this: $server = new React\\Http\\Server($loop, function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($loop) { $stream = new ThroughStream(); $loop->addTimer(2.0, function () use ($stream) { $stream->end(\"Hello World!\\n\"); }); return new React\\Http\\Message\\Response( 200, array( 'Content-Length' => '13', 'Content-Type' => 'text/plain', ), $stream ); }); Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content) or 304 (Not Modified) status code will not include a message body as per the HTTP specs. This means that your callback does not have to take special care of this and any response body will simply be ignored. Similarly, any 2xx (Successful) response to a CONNECT request, any response with a 1xx (Informational) or 204 (No Content) status code will not include a Content-Length or Transfer-Encoding header as these do not apply to these messages. Note that a response to a HEAD request and any response with a 304 (Not Modified) status code MAY include these headers even though the message does not contain a response body, because these header would apply to the message if the same request would have used an (unconditional) GET. Invalid response As stated above, each outgoing HTTP response is always represented by the PSR-7 ResponseInterface. If your request handler function returns an invalid value or throws an unhandled Exception or Throwable, the server will automatically send a 500 (Internal Server Error) HTTP error response to the client. On top of this, it will emit an error event that can be used for logging purposes like this: $server->on('error', function (Exception $e) { echo 'Error: ' . $e->getMessage() . PHP_EOL; if ($e->getPrevious() !== null) { echo 'Previous: ' . $e->getPrevious()->getMessage() . PHP_EOL; } }); Note that the server will also emit an error event if the client sends an invalid HTTP request that never reaches your request handler function. See also invalid request for more details. Additionally, a streaming incoming request body can also emit an error event on the request body. The server will only send a very generic 500 (Interval Server Error) HTTP error response without any further details to the client if an unhandled error occurs. While we understand this might make initial debugging harder, it also means that the server does not leak any application details or stack traces to the outside by default. It is usually recommended to catch any Exception or Throwable within your request handler function or alternatively use a middleware to avoid this generic error handling and create your own HTTP response message instead. Default response headers When a response is returned from the request handler function, it will be processed by the Server and then sent back to the client. A Server: ReactPHP/1 response header will be added automatically. You can add a custom Server response header like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Server' => 'PHP/3' ) ); }); If you do not want to send this Sever response header at all (such as when you don't want to expose the underlying server software), you can use an empty string value like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Server' => '' ) ); }); A Date response header will be added automatically with the current system date and time if none is given. You can add a custom Date response header like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Date' => gmdate('D, d M Y H:i:s \\G\\M\\T') ) ); }); If you do not want to send this Date response header at all (such as when you don't have an appropriate clock to rely on), you can use an empty string value like this: $server = new React\\Http\\Server($loop, function (ServerRequestInterface $request) { return new React\\Http\\Message\\Response( 200, array( 'Date' => '' ) ); }); The Server class will automatically add the protocol version of the request, so you don't have to. For instance, if the client sends the request using the HTTP/1.1 protocol version, the response message will also use the same protocol version, no matter what version is returned from the request handler function. Note that persistent connections (Connection: keep-alive) are currently not supported. As such, HTTP/1.1 response messages will automatically include a Connection: close header, irrespective of what header values are passed explicitly. Middleware As documented above, the Server accepts a single request handler argument that is responsible for processing an incoming HTTP request and then creating and returning an outgoing HTTP response. Many common use cases involve validating, processing, manipulating the incoming HTTP request before passing it to the final business logic request handler. As such, this project supports the concept of middleware request handlers. Custom middleware A middleware request handler is expected to adhere the following rules: It is a valid callable. It accepts an instance implementing PSR-7 ServerRequestInterface as first argument and an optional callable as second argument. It returns either: An instance implementing PSR-7 ResponseInterface for direct consumption. Any promise which can be consumed by Promise\\resolve() resolving to a PSR-7 ResponseInterface for deferred consumption. It MAY throw an Exception (or return a rejected promise) in order to signal an error condition and abort the chain. It calls $next($request) to continue processing the next middleware request handler or returns explicitly without calling $next to abort the chain. The $next request handler (recursively) invokes the next request handler from the chain with the same logic as above and returns (or throws) as above. The $request may be modified prior to calling $next($request) to change the incoming request the next middleware operates on. The $next return value may be consumed to modify the outgoing response. The $next request handler MAY be called more than once if you want to implement custom \"retry\" logic etc. Note that this very simple definition allows you to use either anonymous functions or any classes that use the magic __invoke() method. This allows you to easily create custom middleware request handlers on the fly or use a class based approach to ease using existing middleware implementations. While this project does provide the means to use middleware implementations, it does not aim to define how middleware implementations should look like. We realize that there's a vivid ecosystem of middleware implementations and ongoing effort to standardize interfaces between these with PSR-15 (HTTP Server Request Handlers) and support this goal. As such, this project only bundles a few middleware implementations that are required to match PHP's request behavior (see below) and otherwise actively encourages Third-Party Middleware implementations. In order to use middleware request handlers, simply pass an array with all callables as defined above to the Server. The following example adds a middleware request handler that adds the current time to the request as a header (Request-Time) and a final request handler that always returns a 200 code without a body: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $request = $request->withHeader('Request-Time', time()); return $next($request); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response(200); } ); Note how the middleware request handler and the final request handler have a very simple (and similar) interface. The only difference is that the final request handler does not receive a $next handler. Similarly, you can use the result of the $next middleware request handler function to modify the outgoing response. Note that as per the above documentation, the $next middleware request handler may return a PSR-7 ResponseInterface directly or one wrapped in a promise for deferred resolution. In order to simplify handling both paths, you can simply wrap this in a Promise\\resolve() call like this: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $promise = React\\Promise\\resolve($next($request)); return $promise->then(function (ResponseInterface $response) { return $response->withHeader('Content-Type', 'text/html'); }); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { return new React\\Http\\Message\\Response(200); } ); Note that the $next middleware request handler may also throw an Exception (or return a rejected promise) as described above. The previous example does not catch any exceptions and would thus signal an error condition to the Server. Alternatively, you can also catch any Exception to implement custom error handling logic (or logging etc.) by wrapping this in a Promise like this: $server = new React\\Http\\Server( $loop, function (Psr\\Http\\Message\\ServerRequestInterface $request, callable $next) { $promise = new React\\Promise\\Promise(function ($resolve) use ($next, $request) { $resolve($next($request)); }); return $promise->then(null, function (Exception $e) { return new React\\Http\\Message\\Response( 500, array(), 'Internal error: ' . $e->getMessage() ); }); }, function (Psr\\Http\\Message\\ServerRequestInterface $request) { if (mt_rand(0, 1) === 1) { throw new RuntimeException('Database error'); } return new React\\Http\\Message\\Response(200); } ); Third-Party Middleware While this project does provide the means to use middleware implementations (see above), it does not aim to define how middleware implementations should look like. We realize that there's a vivid ecosystem of middleware implementations and ongoing effort to standardize interfaces between these with PSR-15 (HTTP Server Request Handlers) and support this goal. As such, this project only bundles a few middleware implementations that are required to match PHP's request behavior (see middleware implementations) and otherwise actively encourages third-party middleware implementations. While we would love to support PSR-15 directly in react/http, we understand that this interface does not specifically target async APIs and as such does not take advantage of promises for deferred responses. The gist of this is that where PSR-15 enforces a PSR-7 ResponseInterface return value, we also accept a PromiseInterface. As such, we suggest using the external PSR-15 middleware adapter that uses on the fly monkey patching of these return values which makes using most PSR-15 middleware possible with this package without any changes required. Other than that, you can also use the above middleware definition to create custom middleware. A non-exhaustive list of third-party middleware can be found at the middleware wiki. If you build or know a custom middleware, make sure to let the world know and feel free to add it to this list. API Browser The React\\Http\\Browser is responsible for sending HTTP requests to your HTTP server and keeps track of pending incoming HTTP responses. It also registers everything with the main EventLoop. $loop = React\\EventLoop\\Factory::create(); $browser = new React\\Http\\Browser($loop); If you need custom connector settings (DNS resolution, TLS parameters, timeouts, proxy servers etc.), you can explicitly pass a custom instance of the ConnectorInterface: $connector = new React\\Socket\\Connector($loop, array( 'dns' => '127.0.0.1', 'tcp' => array( 'bindto' => '192.168.10.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ) )); $browser = new React\\Http\\Browser($loop, $connector); Note that the browser class is final and shouldn't be extended, it is likely to be marked final in a future release. get() The get(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP GET request. $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); See also GET request client example. post() The post(string $url, array $headers = array(), string|ReadableStreamInterface $contents = ''): PromiseInterface method can be used to send an HTTP POST request. $browser->post( $url, [ 'Content-Type' => 'application/json' ], json_encode($data) )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump(json_decode((string)$response->getBody())); }); See also POST JSON client example. This method is also commonly used to submit HTML form data: $data = [ 'user' => 'Alice', 'password' => 'secret' ]; $browser->post( $url, [ 'Content-Type' => 'application/x-www-form-urlencoded' ], http_build_query($data) ); This method will automatically add a matching Content-Length request header if the outgoing request body is a string. If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->post($url, array('Content-Length' => '11'), $body); head() The head(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP HEAD request. $browser->head($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump($response->getHeaders()); }); patch() The patch(string $url, array $headers = array(), string|ReadableStreamInterface $contents = ''): PromiseInterface method can be used to send an HTTP PATCH request. $browser->patch( $url, [ 'Content-Type' => 'application/json' ], json_encode($data) )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump(json_decode((string)$response->getBody())); }); This method will automatically add a matching Content-Length request header if the outgoing request body is a string. If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->patch($url, array('Content-Length' => '11'), $body); put() The put(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP PUT request. $browser->put( $url, [ 'Content-Type' => 'text/xml' ], $xml->asXML() )->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); See also PUT XML client example. This method will automatically add a matching Content-Length request header if the outgoing request body is a string. If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->put($url, array('Content-Length' => '11'), $body); delete() The delete(string $url, array $headers = array()): PromiseInterface method can be used to send an HTTP DELETE request. $browser->delete($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); request() The request(string $method, string $url, array $headers = array(), string|ReadableStreamInterface $body = ''): PromiseInterface method can be used to send an arbitrary HTTP request. The preferred way to send an HTTP request is by using the above request methods, for example the get() method to send an HTTP GET request. As an alternative, if you want to use a custom HTTP request method, you can use this method: $browser->request('OPTIONS', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { var_dump((string)$response->getBody()); }); This method will automatically add a matching Content-Length request header if the size of the outgoing request body is known and non-empty. For an empty request body, if will only include a Content-Length: 0 request header if the request method usually expects a request body (only applies to POST, PUT and PATCH). If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->request('POST', $url, array('Content-Length' => '11'), $body); requestStreaming() The requestStreaming(string $method, string $url, array $headers = array(), string|ReadableStreamInterface $body = ''): PromiseInterface method can be used to send an arbitrary HTTP request and receive a streaming response without buffering the response body. The preferred way to send an HTTP request is by using the above request methods, for example the get() method to send an HTTP GET request. Each of these methods will buffer the whole response body in memory by default. This is easy to get started and works reasonably well for smaller responses. In some situations, it's a better idea to use a streaming approach, where only small chunks have to be kept in memory. You can use this method to send an arbitrary HTTP request and receive a streaming response. It uses the same HTTP message API, but does not buffer the response body in memory. It only processes the response body in small chunks as data is received and forwards this data through ReactPHP's Stream API. This works for (any number of) responses of arbitrary sizes. $browser->requestStreaming('GET', $url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { $body = $response->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); $body->on('data', function ($chunk) { echo $chunk; }); $body->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage() . PHP_EOL; }); $body->on('close', function () { echo '[DONE]' . PHP_EOL; }); }); See also ReactPHP's ReadableStreamInterface and the streaming response for more details, examples and possible use-cases. This method will automatically add a matching Content-Length request header if the size of the outgoing request body is known and non-empty. For an empty request body, if will only include a Content-Length: 0 request header if the request method usually expects a request body (only applies to POST, PUT and PATCH). If you're using a streaming request body (ReadableStreamInterface), it will default to using Transfer-Encoding: chunked or you have to explicitly pass in a matching Content-Length request header like so: $body = new React\\Stream\\ThroughStream(); $loop->addTimer(1.0, function () use ($body) { $body->end(\"hello world\"); }); $browser->requestStreaming('POST', $url, array('Content-Length' => '11'), $body); withTimeout() The withTimeout(bool|number $timeout): Browser method can be used to change the maximum timeout used for waiting for pending requests. You can pass in the number of seconds to use as a new timeout value: $browser = $browser->withTimeout(10.0); You can pass in a bool false to disable any timeouts. In this case, requests can stay pending forever: $browser = $browser->withTimeout(false); You can pass in a bool true to re-enable default timeout handling. This will respects PHP's default_socket_timeout setting (default 60s): $browser = $browser->withTimeout(true); See also timeouts for more details about timeout handling. Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given timeout value applied. withFollowRedirects() The withFollowRedirects(bool|int $followRedirects): Browser method can be used to change how HTTP redirects will be followed. You can pass in the maximum number of redirects to follow: $browser = $browser->withFollowRedirects(5); The request will automatically be rejected when the number of redirects is exceeded. You can pass in a 0 to reject the request for any redirects encountered: $browser = $browser->withFollowRedirects(0); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // only non-redirected responses will now end up here var_dump($response->getHeaders()); }); You can pass in a bool false to disable following any redirects. In this case, requests will resolve with the redirection response instead of following the Location response header: $browser = $browser->withFollowRedirects(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any redirects will now end up here var_dump($response->getHeaderLine('Location')); }); You can pass in a bool true to re-enable default redirect handling. This defaults to following a maximum of 10 redirects: $browser = $browser->withFollowRedirects(true); See also redirects for more details about redirect handling. Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given redirect setting applied. withRejectErrorResponse() The withRejectErrorResponse(bool $obeySuccessCode): Browser method can be used to change whether non-successful HTTP response status codes (4xx and 5xx) will be rejected. You can pass in a bool false to disable rejecting incoming responses that use a 4xx or 5xx response status code. In this case, requests will resolve with the response message indicating an error condition: $browser = $browser->withRejectErrorResponse(false); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any HTTP response will now end up here var_dump($response->getStatusCode(), $response->getReasonPhrase()); }); You can pass in a bool true to re-enable default status code handling. This defaults to rejecting any response status codes in the 4xx or 5xx range with a ResponseException: $browser = $browser->withRejectErrorResponse(true); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // any successful HTTP response will now end up here var_dump($response->getStatusCode(), $response->getReasonPhrase()); }, function (Exception $e) { if ($e instanceof React\\Http\\Message\\ResponseException) { // any HTTP response error message will now end up here $response = $e->getResponse(); var_dump($response->getStatusCode(), $response->getReasonPhrase()); } else { var_dump($e->getMessage()); } }); Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given setting applied. withBase() The withBase(string|null $baseUrl): Browser method can be used to change the base URL used to resolve relative URLs to. If you configure a base URL, any requests to relative URLs will be processed by first resolving this relative to the given absolute base URL. This supports resolving relative path references (like ../ etc.). This is particularly useful for (RESTful) API calls where all endpoints (URLs) are located under a common base URL. $browser = $browser->withBase('http://api.example.com/v3/'); // will request http://api.example.com/v3/users $browser->get('users')->then(…); You can pass in a null base URL to return a new instance that does not use a base URL: $browser = $browser->withBase(null); Accordingly, any requests using relative URLs to a browser that does not use a base URL can not be completed and will be rejected without sending a request. This method will throw an InvalidArgumentException if the given $baseUrl argument is not a valid URL. Notice that the Browser is an immutable object, i.e. the withBase() method actually returns a new Browser instance with the given base URL applied. withProtocolVersion() The withProtocolVersion(string $protocolVersion): Browser method can be used to change the HTTP protocol version that will be used for all subsequent requests. All the above request methods default to sending requests as HTTP/1.1. This is the preferred HTTP protocol version which also provides decent backwards-compatibility with legacy HTTP/1.0 servers. As such, there should rarely be a need to explicitly change this protocol version. If you want to explicitly use the legacy HTTP/1.0 protocol version, you can use this method: $browser = $browser->withProtocolVersion('1.0'); $browser->get($url)->then(…); Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the new protocol version applied. withResponseBuffer() The withResponseBuffer(int $maximumSize): Browser method can be used to change the maximum size for buffering a response body. The preferred way to send an HTTP request is by using the above request methods, for example the get() method to send an HTTP GET request. Each of these methods will buffer the whole response body in memory by default. This is easy to get started and works reasonably well for smaller responses. By default, the response body buffer will be limited to 16 MiB. If the response body exceeds this maximum size, the request will be rejected. You can pass in the maximum number of bytes to buffer: $browser = $browser->withResponseBuffer(1024 * 1024); $browser->get($url)->then(function (Psr\\Http\\Message\\ResponseInterface $response) { // response body will not exceed 1 MiB var_dump($response->getHeaders(), (string) $response->getBody()); }); Note that the response body buffer has to be kept in memory for each pending request until its transfer is completed and it will only be freed after a pending request is fulfilled. As such, increasing this maximum buffer size to allow larger response bodies is usually not recommended. Instead, you can use the requestStreaming() method to receive responses with arbitrary sizes without buffering. Accordingly, this maximum buffer size setting has no effect on streaming responses. Notice that the Browser is an immutable object, i.e. this method actually returns a new Browser instance with the given setting applied. React\\Http\\Message Response The React\\Http\\Message\\Response class can be used to represent an outgoing server response message. $response = new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/html' ), \"Hello world!\\n\" ); This class implements the PSR-7 ResponseInterface which in turn extends the PSR-7 MessageInterface. Internally, this implementation builds on top of an existing incoming response message and only adds required streaming support. This base class is considered an implementation detail that may change in the future. ServerRequest The React\\Http\\Message\\ServerRequest class can be used to respresent an incoming server request message. This class implements the PSR-7 ServerRequestInterface which extends the PSR-7 RequestInterface which in turn extends the PSR-7 MessageInterface. This is mostly used internally to represent each incoming request message. Likewise, you can also use this class in test cases to test how your web application reacts to certain HTTP requests. Internally, this implementation builds on top of an existing outgoing request message and only adds required server methods. This base class is considered an implementation detail that may change in the future. ResponseException The React\\Http\\Message\\ResponseException is an Exception sub-class that will be used to reject a request promise if the remote server returns a non-success status code (anything but 2xx or 3xx). You can control this behavior via the withRejectErrorResponse() method. The getCode(): int method can be used to return the HTTP response status code. The getResponse(): ResponseInterface method can be used to access its underlying response object. React\\Http\\Middleware StreamingRequestMiddleware The React\\Http\\Middleware\\StreamingRequestMiddleware can be used to process incoming requests with a streaming request body (without buffering). This allows you to process requests of any size without buffering the request body in memory. Instead, it will represent the request body as a ReadableStreamInterface that emit chunks of incoming data as it is received: $server = new React\\Http\\Server(array( new React\\Http\\Middleware\\StreamingRequestMiddleware(), function (Psr\\Http\\Message\\ServerRequestInterface $request) { $body = $request->getBody(); assert($body instanceof Psr\\Http\\Message\\StreamInterface); assert($body instanceof React\\Stream\\ReadableStreamInterface); return new React\\Promise\\Promise(function ($resolve) use ($body) { $bytes = 0; $body->on('data', function ($chunk) use (&$bytes) { $bytes += \\count($chunk); }); $body->on('close', function () use (&$bytes, $resolve) { $resolve(new React\\Http\\Message\\Response( 200, [], \"Received $bytes bytes\\n\" )); }); }); } )); See also streaming incoming request for more details. Additionally, this middleware can be used in combination with the LimitConcurrentRequestsMiddleware and RequestBodyBufferMiddleware (see below) to explicitly configure the total number of requests that can be handled at once: $server = new React\\Http\\Server(array( new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler )); Internally, this class is used as a \"marker\" to not trigger the default request buffering behavior in the Server. It does not implement any logic on its own. LimitConcurrentRequestsMiddleware The React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware can be used to limit how many next handlers can be executed concurrently. If this middleware is invoked, it will check if the number of pending handlers is below the allowed limit and then simply invoke the next handler and it will return whatever the next handler returns (or throws). If the number of pending handlers exceeds the allowed limit, the request will be queued (and its streaming body will be paused) and it will return a pending promise. Once a pending handler returns (or throws), it will pick the oldest request from this queue and invokes the next handler (and its streaming body will be resumed). The following example shows how this middleware can be used to ensure no more than 10 handlers will be invoked at once: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(10), $handler ); Similarly, this middleware is often used in combination with the RequestBodyBufferMiddleware (see below) to limit the total number of requests that can be buffered at once: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); More sophisticated examples include limiting the total number of requests that can be buffered at once and then ensure the actual request handler only processes one request after another without any concurrency: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(2 * 1024 * 1024), // 2 MiB per request new React\\Http\\Middleware\\RequestBodyParserMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(1), // only execute 1 handler (no concurrency) $handler ); RequestBodyBufferMiddleware One of the built-in middleware is the React\\Http\\Middleware\\RequestBodyBufferMiddleware which can be used to buffer the whole incoming request body in memory. This can be useful if full PSR-7 compatibility is needed for the request handler and the default streaming request body handling is not needed. The constructor accepts one optional argument, the maximum request body size. When one isn't provided it will use post_max_size (default 8 MiB) from PHP's configuration. (Note that the value from your matching SAPI will be used, which is the CLI configuration in most cases.) Any incoming request that has a request body that exceeds this limit will be accepted, but its request body will be discarded (empty request body). This is done in order to avoid having to keep an incoming request with an excessive size (for example, think of a 2 GB file upload) in memory. This allows the next middleware handler to still handle this request, but it will see an empty request body. This is similar to PHP's default behavior, where the body will not be parsed if this limit is exceeded. However, unlike PHP's default behavior, the raw request body is not available via php://input. The RequestBodyBufferMiddleware will buffer requests with bodies of known size (i.e. with Content-Length header specified) as well as requests with bodies of unknown size (i.e. with Transfer-Encoding: chunked header). All requests will be buffered in memory until the request body end has been reached and then call the next middleware handler with the complete, buffered request. Similarly, this will immediately invoke the next middleware handler for requests that have an empty request body (such as a simple GET request) and requests that are already buffered (such as due to another middleware). Note that the given buffer size limit is applied to each request individually. This means that if you allow a 2 MiB limit and then receive 1000 concurrent requests, up to 2000 MiB may be allocated for these buffers alone. As such, it's highly recommended to use this along with the LimitConcurrentRequestsMiddleware (see above) to limit the total number of concurrent requests. Usage: $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(16 * 1024 * 1024), // 16 MiB function (Psr\\Http\\Message\\ServerRequestInterface $request) { // The body from $request->getBody() is now fully available without the need to stream it return new React\\Http\\Message\\Response(200); }, ); RequestBodyParserMiddleware The React\\Http\\Middleware\\RequestBodyParserMiddleware takes a fully buffered request body (generally from RequestBodyBufferMiddleware), and parses the form values and file uploads from the incoming HTTP request body. This middleware handler takes care of applying values from HTTP requests that use Content-Type: application/x-www-form-urlencoded or Content-Type: multipart/form-data to resemble PHP's default superglobals $_POST and $_FILES. Instead of relying on these superglobals, you can use the $request->getParsedBody() and $request->getUploadedFiles() methods as defined by PSR-7. Accordingly, each file upload will be represented as instance implementing the PSR-7 UploadedFileInterface. Due to its blocking nature, the moveTo() method is not available and throws a RuntimeException instead. You can use $contents = (string)$file->getStream(); to access the file contents and persist this to your favorite data store. $handler = function (Psr\\Http\\Message\\ServerRequestInterface $request) { // If any, parsed form fields are now available from $request->getParsedBody() $body = $request->getParsedBody(); $name = isset($body['name']) ? $body['name'] : 'unnamed'; $files = $request->getUploadedFiles(); $avatar = isset($files['avatar']) ? $files['avatar'] : null; if ($avatar instanceof Psr\\Http\\Message\\UploadedFileInterface) { if ($avatar->getError() === UPLOAD_ERR_OK) { $uploaded = $avatar->getSize() . ' bytes'; } elseif ($avatar->getError() === UPLOAD_ERR_INI_SIZE) { $uploaded = 'file too large'; } else { $uploaded = 'with error'; } } else { $uploaded = 'nothing'; } return new React\\Http\\Message\\Response( 200, array( 'Content-Type' => 'text/plain' ), $name . ' uploaded ' . $uploaded ); }; $server = new React\\Http\\Server( $loop, new React\\Http\\Middleware\\StreamingRequestMiddleware(), new React\\Http\\Middleware\\LimitConcurrentRequestsMiddleware(100), // 100 concurrent buffering handlers new React\\Http\\Middleware\\RequestBodyBufferMiddleware(16 * 1024 * 1024), // 16 MiB new React\\Http\\Middleware\\RequestBodyParserMiddleware(), $handler ); See also form upload server example for more details. By default, this middleware respects the upload_max_filesize (default 2M) ini setting. Files that exceed this limit will be rejected with an UPLOAD_ERR_INI_SIZE error. You can control the maximum filesize for each individual file upload by explicitly passing the maximum filesize in bytes as the first parameter to the constructor like this: new React\\Http\\Middleware\\RequestBodyParserMiddleware(8 * 1024 * 1024); // 8 MiB limit per file By default, this middleware respects the file_uploads (default 1) and max_file_uploads (default 20) ini settings. These settings control if any and how many files can be uploaded in a single request. If you upload more files in a single request, additional files will be ignored and the getUploadedFiles() method returns a truncated array. Note that upload fields left blank on submission do not count towards this limit. You can control the maximum number of file uploads per request by explicitly passing the second parameter to the constructor like this: new React\\Http\\Middleware\\RequestBodyParserMiddleware(10 * 1024, 100); // 100 files with 10 KiB each Note that this middleware handler simply parses everything that is already buffered in the request body. It is imperative that the request body is buffered by a prior middleware handler as given in the example above. This previous middleware handler is also responsible for rejecting incoming requests that exceed allowed message sizes (such as big file uploads). The RequestBodyBufferMiddleware used above simply discards excessive request bodies, resulting in an empty body. If you use this middleware without buffering first, it will try to parse an empty (streaming) body and may thus assume an empty data structure. See also RequestBodyBufferMiddleware for more details. PHP's MAX_FILE_SIZE hidden field is respected by this middleware. Files that exceed this limit will be rejected with an UPLOAD_ERR_FORM_SIZE error. This middleware respects the max_input_vars (default 1000) and max_input_nesting_level (default 64) ini settings. Note that this middleware ignores the enable_post_data_reading (default 1) ini setting because it makes little sense to respect here and is left up to higher-level implementations. If you want to respect this setting, you have to check its value and effectively avoid using this middleware entirely. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/http:^1.2 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"3.Protocol-Components/HttpClient.html":{"url":"3.Protocol-Components/HttpClient.html","title":"HttpClient","keywords":"","body":"Deprecation notice This package has now been migrated over to react/http and only exists for BC reasons. $ composer require react/http If you've previously used this package, upgrading may take a moment or two. The new API has been updated to use Promises and PSR-7 message abstractions. This means it's now more powerful and easier to use than ever: // old $client = new React\\HttpClient\\Client($loop); $request = $client->request('GET', 'https://example.com/'); $request->on('response', function ($response) { $response->on('data', function ($chunk) { echo $chunk; }); }); $request->end(); // new $browser = new React\\Http\\Browser($loop); $browser->get('https://example.com/')->then(function (Psr\\Http\\Message\\ResponseInterface $response) { echo $response->getBody(); }); See react/http for more details. The below documentation applies to the last release of this package. Further development will take place in the updated react/http, so you're highly recommended to upgrade as soon as possible. Deprecated HttpClient Event-driven, streaming HTTP client for ReactPHP. Table of Contents Basic usage Client Example Advanced usage Unix domain sockets Install Tests License Basic usage Client The Client is responsible for communicating with HTTP servers, managing the connection state and sending your HTTP requests. It also registers everything with the main EventLoop. $loop = React\\EventLoop\\Factory::create(); $client = new Client($loop); If you need custom connector settings (DNS resolution, TLS parameters, timeouts, proxy servers etc.), you can explicitly pass a custom instance of the ConnectorInterface: $connector = new \\React\\Socket\\Connector($loop, array( 'dns' => '127.0.0.1', 'tcp' => array( 'bindto' => '192.168.10.1:0' ), 'tls' => array( 'verify_peer' => false, 'verify_peer_name' => false ) )); $client = new Client($loop, $connector); The request(string $method, string $uri, array $headers = array(), string $version = '1.0'): Request method can be used to prepare new Request objects. The optional $headers parameter can be used to pass additional request headers. You can use an associative array (key=value) or an array for each header value (key=values). The Request will automatically include an appropriate Host, User-Agent: react/alpha and Connection: close header if applicable. You can pass custom header values or use an empty array to omit any of these. The Request#write(string $data) method can be used to write data to the request body. Data will be buffered until the underlying connection is established, at which point buffered data will be sent and all further data will be passed to the underlying connection immediately. The Request#end(?string $data = null) method can be used to finish sending the request. You may optionally pass a last request body data chunk that will be sent just like a write() call. Calling this method finalizes the outgoing request body (which may be empty). Data will be buffered until the underlying connection is established, at which point buffered data will be sent and all further data will be ignored. The Request#close() method can be used to forefully close sending the request. Unlike the end() method, this method discards any buffers and closes the underlying connection if it is already established or cancels the pending connection attempt otherwise. Request implements WritableStreamInterface, so a Stream can be piped to it. Interesting events emitted by Request: response: The response headers were received from the server and successfully parsed. The first argument is a Response instance. drain: The outgoing buffer drained and the response is ready to accept more data for the next write() call. error: An error occurred, an Exception is passed as first argument. If the response emits an error event, this will also be emitted here. close: The request is closed. If an error occurred, this event will be preceeded by an error event. For a successful response, this will be emitted only once the response emits the close event. Response implements ReadableStreamInterface. Interesting events emitted by Response: data: Passes a chunk of the response body as first argument. When a response encounters a chunked encoded response it will parse it transparently for the user and removing the Transfer-Encoding header. error: An error occurred, an Exception is passed as first argument. This will also be forwarded to the request and emit an error event there. end: The response has been fully received. close: The response is closed. If an error occured, this event will be preceeded by an error event. This will also be forwarded to the request and emit a close event there. Example request('GET', 'https://github.com/'); $request->on('response', function ($response) { $response->on('data', function ($chunk) { echo $chunk; }); $response->on('end', function() { echo 'DONE'; }); }); $request->on('error', function (\\Exception $e) { echo $e; }); $request->end(); $loop->run(); See also the examples. Advanced Usage Unix domain sockets By default, this library supports transport over plaintext TCP/IP and secure TLS connections for the http:// and https:// URI schemes respectively. This library also supports Unix domain sockets (UDS) when explicitly configured. In order to use a UDS path, you have to explicitly configure the connector to override the destination URI so that the hostname given in the request URI will no longer be used to establish the connection: $connector = new FixedUriConnector( 'unix:///var/run/docker.sock', new UnixConnector($loop) ); $client = new Client($loop, $connector); $request = $client->request('GET', 'http://localhost/info'); See also example #11. Install The recommended way to install this library is through Composer. New to Composer? This will install the latest supported version: $ composer require react/http-client:^0.5.10 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit The test suite also contains a number of functional integration tests that send test HTTP requests against the online service http://httpbin.org and thus rely on a stable internet connection. If you do not want to run these, they can simply be skipped like this: $ php vendor/bin/phpunit --exclude-group internet License MIT, see LICENSE file. "},"4.Utility-Components/Cache.html":{"url":"4.Utility-Components/Cache.html","title":"Cache","keywords":"","body":"Cache Async, Promise-based cache interface for ReactPHP. The cache component provides a Promise-based CacheInterface and an in-memory ArrayCache implementation of that. This allows consumers to type hint against the interface and third parties to provide alternate implementations. This project is heavily inspired by PSR-16: Common Interface for Caching Libraries, but uses an interface more suited for async, non-blocking applications. Table of Contents Usage CacheInterface get() set() delete() getMultiple() setMultiple() deleteMultiple() clear() has() ArrayCache Common usage Fallback get Fallback-get-and-set Install Tests License Usage CacheInterface The CacheInterface describes the main interface of this component. This allows consumers to type hint against the interface and third parties to provide alternate implementations. get() The get(string $key, mixed $default = null): PromiseInterface method can be used to retrieve an item from the cache. This method will resolve with the cached value on success or with the given $default value when no item can be found or when an error occurs. Similarly, an expired cache item (once the time-to-live is expired) is considered a cache miss. $cache ->get('foo') ->then('var_dump'); This example fetches the value of the key foo and passes it to the var_dump function. You can use any of the composition provided by promises. set() The set(string $key, mixed $value, ?float $ttl = null): PromiseInterface method can be used to store an item in the cache. This method will resolve with true on success or false when an error occurs. If the cache implementation has to go over the network to store it, it may take a while. The optional $ttl parameter sets the maximum time-to-live in seconds for this cache item. If this parameter is omitted (or null), the item will stay in the cache for as long as the underlying implementation supports. Trying to access an expired cache item results in a cache miss, see also get(). $cache->set('foo', 'bar', 60); This example eventually sets the value of the key foo to bar. If it already exists, it is overridden. This interface does not enforce any particular TTL resolution, so special care may have to be taken if you rely on very high precision with millisecond accuracy or below. Cache implementations SHOULD work on a best effort basis and SHOULD provide at least second accuracy unless otherwise noted. Many existing cache implementations are known to provide microsecond or millisecond accuracy, but it's generally not recommended to rely on this high precision. This interface suggests that cache implementations SHOULD use a monotonic time source if available. Given that a monotonic time source is only available as of PHP 7.3 by default, cache implementations MAY fall back to using wall-clock time. While this does not affect many common use cases, this is an important distinction for programs that rely on a high time precision or on systems that are subject to discontinuous time adjustments (time jumps). This means that if you store a cache item with a TTL of 30s and then adjust your system time forward by 20s, the cache item SHOULD still expire in 30s. delete() The delete(string $key): PromiseInterface method can be used to delete an item from the cache. This method will resolve with true on success or false when an error occurs. When no item for $key is found in the cache, it also resolves to true. If the cache implementation has to go over the network to delete it, it may take a while. $cache->delete('foo'); This example eventually deletes the key foo from the cache. As with set(), this may not happen instantly and a promise is returned to provide guarantees whether or not the item has been removed from cache. getMultiple() The getMultiple(string[] $keys, mixed $default = null): PromiseInterface method can be used to retrieve multiple cache items by their unique keys. This method will resolve with an array of cached values on success or with the given $default value when an item can not be found or when an error occurs. Similarly, an expired cache item (once the time-to-live is expired) is considered a cache miss. $cache->getMultiple(array('name', 'age'))->then(function (array $values) { $name = $values['name'] ?? 'User'; $age = $values['age'] ?? 'n/a'; echo $name . ' is ' . $age . PHP_EOL; }); This example fetches the cache items for the name and age keys and prints some example output. You can use any of the composition provided by promises. setMultiple() The setMultiple(array $values, ?float $ttl = null): PromiseInterface method can be used to persist a set of key => value pairs in the cache, with an optional TTL. This method will resolve with true on success or false when an error occurs. If the cache implementation has to go over the network to store it, it may take a while. The optional $ttl parameter sets the maximum time-to-live in seconds for these cache items. If this parameter is omitted (or null), these items will stay in the cache for as long as the underlying implementation supports. Trying to access an expired cache items results in a cache miss, see also getMultiple(). $cache->setMultiple(array('foo' => 1, 'bar' => 2), 60); This example eventually sets the list of values - the key foo to 1 value and the key bar to 2. If some of the keys already exist, they are overridden. deleteMultiple() The setMultiple(string[] $keys): PromiseInterface method can be used to delete multiple cache items in a single operation. This method will resolve with true on success or false when an error occurs. When no items for $keys are found in the cache, it also resolves to true. If the cache implementation has to go over the network to delete it, it may take a while. $cache->deleteMultiple(array('foo', 'bar, 'baz')); This example eventually deletes keys foo, bar and baz from the cache. As with setMultiple(), this may not happen instantly and a promise is returned to provide guarantees whether or not the item has been removed from cache. clear() The clear(): PromiseInterface method can be used to wipe clean the entire cache. This method will resolve with true on success or false when an error occurs. If the cache implementation has to go over the network to delete it, it may take a while. $cache->clear(); This example eventually deletes all keys from the cache. As with deleteMultiple(), this may not happen instantly and a promise is returned to provide guarantees whether or not all the items have been removed from cache. has() The has(string $key): PromiseInterface method can be used to determine whether an item is present in the cache. This method will resolve with true on success or false when no item can be found or when an error occurs. Similarly, an expired cache item (once the time-to-live is expired) is considered a cache miss. $cache ->has('foo') ->then('var_dump'); This example checks if the value of the key foo is set in the cache and passes the result to the var_dump function. You can use any of the composition provided by promises. NOTE: It is recommended that has() is only to be used for cache warming type purposes and not to be used within your live applications operations for get/set, as this method is subject to a race condition where your has() will return true and immediately after, another script can remove it making the state of your app out of date. ArrayCache The ArrayCache provides an in-memory implementation of the CacheInterface. $cache = new ArrayCache(); $cache->set('foo', 'bar'); Its constructor accepts an optional ?int $limit parameter to limit the maximum number of entries to store in the LRU cache. If you add more entries to this instance, it will automatically take care of removing the one that was least recently used (LRU). For example, this snippet will overwrite the first value and only store the last two entries: $cache = new ArrayCache(2); $cache->set('foo', '1'); $cache->set('bar', '2'); $cache->set('baz', '3'); This cache implementation is known to rely on wall-clock time to schedule future cache expiration times when using any version before PHP 7.3, because a monotonic time source is only available as of PHP 7.3 (hrtime()). While this does not affect many common use cases, this is an important distinction for programs that rely on a high time precision or on systems that are subject to discontinuous time adjustments (time jumps). This means that if you store a cache item with a TTL of 30s on PHP set() for more details. Common usage Fallback get A common use case of caches is to attempt fetching a cached value and as a fallback retrieve it from the original data source if not found. Here is an example of that: $cache ->get('foo') ->then(function ($result) { if ($result === null) { return getFooFromDb(); } return $result; }) ->then('var_dump'); First an attempt is made to retrieve the value of foo. A callback function is registered that will call getFooFromDb when the resulting value is null. getFooFromDb is a function (can be any PHP callable) that will be called if the key does not exist in the cache. getFooFromDb can handle the missing key by returning a promise for the actual value from the database (or any other data source). As a result, this chain will correctly fall back, and provide the value in both cases. Fallback get and set To expand on the fallback get example, often you want to set the value on the cache after fetching it from the data source. $cache ->get('foo') ->then(function ($result) { if ($result === null) { return $this->getAndCacheFooFromDb(); } return $result; }) ->then('var_dump'); public function getAndCacheFooFromDb() { return $this->db ->get('foo') ->then(array($this, 'cacheFooFromDb')); } public function cacheFooFromDb($foo) { $this->cache->set('foo', $foo); return $foo; } By using chaining you can easily conditionally cache the value if it is fetched from the database. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/cache:^1.1 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/ChildProcess.html":{"url":"4.Utility-Components/ChildProcess.html","title":"ChildProcess","keywords":"","body":"Child Process Event-driven library for executing child processes with ReactPHP. This library integrates Program Execution with the EventLoop. Child processes launched may be signaled and will emit an exit event upon termination. Additionally, process I/O streams (i.e. STDIN, STDOUT, STDERR) are exposed as Streams. Table of contents Quickstart example Process Stream Properties Command Termination Custom pipes Sigchild Compatibility Windows Compatibility Install Tests License Quickstart example $loop = React\\EventLoop\\Factory::create(); $process = new React\\ChildProcess\\Process('echo foo'); $process->start($loop); $process->stdout->on('data', function ($chunk) { echo $chunk; }); $process->on('exit', function($exitCode, $termSignal) { echo 'Process exited with code ' . $exitCode . PHP_EOL; }); $loop->run(); See also the examples. Process Stream Properties Once a process is started, its I/O streams will be constructed as instances of React\\Stream\\ReadableStreamInterface and React\\Stream\\WritableStreamInterface. Before start() is called, these properties are not set. Once a process terminates, the streams will become closed but not unset. Following common Unix conventions, this library will start each child process with the three pipes matching the standard I/O streams as given below by default. You can use the named references for common use cases or access these as an array with all three pipes. $stdin or $pipes[0] is a WritableStreamInterface $stdout or $pipes[1] is a ReadableStreamInterface $stderr or $pipes[2] is a ReadableStreamInterface Note that this default configuration may be overridden by explicitly passing custom pipes, in which case they may not be set or be assigned different values. In particular, note that Windows support is limited in that it doesn't support non-blocking STDIO pipes. The $pipes array will always contain references to all pipes as configured and the standard I/O references will always be set to reference the pipes matching the above conventions. See custom pipes for more details. Because each of these implement the underlying ReadableStreamInterface or WritableStreamInterface, you can use any of their events and methods as usual: $process = new Process($command); $process->start($loop); $process->stdout->on('data', function ($chunk) { echo $chunk; }); $process->stdout->on('end', function () { echo 'ended'; }); $process->stdout->on('error', function (Exception $e) { echo 'error: ' . $e->getMessage(); }); $process->stdout->on('close', function () { echo 'closed'; }); $process->stdin->write($data); $process->stdin->end($data = null); // … For more details, see the ReadableStreamInterface and WritableStreamInterface. Command The Process class allows you to pass any kind of command line string: $process = new Process('echo test'); $process->start($loop); The command line string usually consists of a whitespace-separated list with your main executable bin and any number of arguments. Special care should be taken to escape or quote any arguments, escpecially if you pass any user input along. Likewise, keep in mind that especially on Windows, it is rather common to have path names containing spaces and other special characters. If you want to run a binary like this, you will have to ensure this is quoted as a single argument using escapeshellarg() like this: $bin = 'C:\\\\Program files (x86)\\\\PHP\\\\php.exe'; $file = 'C:\\\\Users\\\\me\\\\Desktop\\\\Application\\\\main.php'; $process = new Process(escapeshellarg($bin) . ' ' . escapeshellarg($file)); $process->start($loop); By default, PHP will launch processes by wrapping the given command line string in a sh command on Unix, so that the first example will actually execute sh -c echo test under the hood on Unix. On Windows, it will not launch processes by wrapping them in a shell. This is a very useful feature because it does not only allow you to pass single commands, but actually allows you to pass any kind of shell command line and launch multiple sub-commands using command chains (with &&, ||, ; and others) and allows you to redirect STDIO streams (with 2>&1 and family). This can be used to pass complete command lines and receive the resulting STDIO streams from the wrapping shell command like this: $process = new Process('echo run && demo || echo failed'); $process->start($loop); Note that Windows support is limited in that it doesn't support STDIO streams at all and also that processes will not be run in a wrapping shell by default. If you want to run a shell built-in function such as echo hello or sleep 10, you may have to prefix your command line with an explicit shell like cmd /c echo hello. In other words, the underlying shell is responsible for managing this command line and launching the individual sub-commands and connecting their STDIO streams as appropriate. This implies that the Process class will only receive the resulting STDIO streams from the wrapping shell, which will thus contain the complete input/output with no way to discern the input/output of single sub-commands. If you want to discern the output of single sub-commands, you may want to implement some higher-level protocol logic, such as printing an explicit boundary between each sub-command like this: $process = new Process('cat first && echo --- && cat second'); $process->start($loop); As an alternative, considering launching one process at a time and listening on its exit event to conditionally start the next process in the chain. This will give you an opportunity to configure the subsequent process I/O streams: $first = new Process('cat first'); $first->start($loop); $first->on('exit', function () use ($loop) { $second = new Process('cat second'); $second->start($loop); }); Keep in mind that PHP uses the shell wrapper for ALL command lines on Unix. While this may seem reasonable for more complex command lines, this actually also applies to running the most simple single command: $process = new Process('yes'); $process->start($loop); This will actually spawn a command hierarchy similar to this on Unix: 5480 … \\_ php example.php 5481 … \\_ sh -c yes 5482 … \\_ yes This means that trying to get the underlying process PID or sending signals will actually target the wrapping shell, which may not be the desired result in many cases. If you do not want this wrapping shell process to show up, you can simply prepend the command string with exec on Unix platforms, which will cause the wrapping shell process to be replaced by our process: $process = new Process('exec yes'); $process->start($loop); This will show a resulting command hierarchy similar to this: 5480 … \\_ php example.php 5481 … \\_ yes This means that trying to get the underlying process PID and sending signals will now target the actual command as expected. Note that in this case, the command line will not be run in a wrapping shell. This implies that when using exec, there's no way to pass command lines such as those containing command chains or redirected STDIO streams. As a rule of thumb, most commands will likely run just fine with the wrapping shell. If you pass a complete command line (or are unsure), you SHOULD most likely keep the wrapping shell. If you're running on Unix and you want to pass an invidual command only, you MAY want to consider prepending the command string with exec to avoid the wrapping shell. Termination The exit event will be emitted whenever the process is no longer running. Event listeners will receive the exit code and termination signal as two arguments: $process = new Process('sleep 10'); $process->start($loop); $process->on('exit', function ($code, $term) { if ($term === null) { echo 'exit with code ' . $code . PHP_EOL; } else { echo 'terminated with signal ' . $term . PHP_EOL; } }); Note that $code is null if the process has terminated, but the exit code could not be determined (for example sigchild compatibility was disabled). Similarly, $term is null unless the process has terminated in response to an uncaught signal sent to it. This is not a limitation of this project, but actual how exit codes and signals are exposed on POSIX systems, for more details see also here. It's also worth noting that process termination depends on all file descriptors being closed beforehand. This means that all process pipes will emit a close event before the exit event and that no more data events will arrive after the exit event. Accordingly, if either of these pipes is in a paused state (pause() method or internally due to a pipe() call), this detection may not trigger. The terminate(?int $signal = null): bool method can be used to send the process a signal (SIGTERM by default). Depending on which signal you send to the process and whether it has a signal handler registered, this can be used to either merely signal a process or even forcefully terminate it. $process->terminate(SIGUSR1); Keep the above section in mind if you want to forcefully terminate a process. If your process spawn sub-processes or implicitly uses the wrapping shell mentioned above, its file descriptors may be inherited to child processes and terminating the main process may not necessarily terminate the whole process tree. It is highly suggested that you explicitly close() all process pipes accordingly when terminating a process: $process = new Process('sleep 10'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { foreach ($process->pipes as $pipe) { $pipe->close(); } $process->terminate(); }); For many simple programs these seamingly complicated steps can also be avoided by prefixing the command line with exec to avoid the wrapping shell and its inherited process pipes as mentioned above. $process = new Process('exec sleep 10'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { $process->terminate(); }); Many command line programs also wait for data on STDIN and terminate cleanly when this pipe is closed. For example, the following can be used to \"soft-close\" a cat process: $process = new Process('cat'); $process->start($loop); $loop->addTimer(2.0, function () use ($process) { $process->stdin->end(); }); While process pipes and termination may seem confusing to newcomers, the above properties actually allow some fine grained control over process termination, such as first trying a soft-close and then applying a force-close after a timeout. Custom pipes Following common Unix conventions, this library will start each child process with the three pipes matching the standard I/O streams by default. For more advanced use cases it may be useful to pass in custom pipes, such as explicitly passing additional file descriptors (FDs) or overriding default process pipes. Note that passing custom pipes is considered advanced usage and requires a more in-depth understanding of Unix file descriptors and how they are inherited to child processes and shared in multi-processing applications. If you do not want to use the default standard I/O pipes, you can explicitly pass an array containing the file descriptor specification to the constructor like this: $fds = array( // standard I/O pipes for stdin/stdout/stderr 0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'w'), // example FDs for files or open resources 4 => array('file', '/dev/null', 'r'), 6 => fopen('log.txt','a'), 8 => STDERR, // example FDs for sockets 10 => fsockopen('localhost', 8080), 12 => stream_socket_server('tcp://0.0.0.0:4711') ); $process = new Process($cmd, null, null, $fds); $process->start($loop); Unless your use case has special requirements that demand otherwise, you're highly recommended to (at least) pass in the standard I/O pipes as given above. The file descriptor specification accepts arguments in the exact same format as the underlying proc_open() function. Once the process is started, the $pipes array will always contain references to all pipes as configured and the standard I/O references will always be set to reference the pipes matching common Unix conventions. This library supports any number of pipes and additional file descriptors, but many common applications being run as a child process will expect that the parent process properly assigns these file descriptors. Sigchild Compatibility Internally, this project uses a work-around to improve compatibility when PHP has been compiled with the --enable-sigchild option. This should not affect most installations as this configure option is not used by default and many distributions (such as Debian and Ubuntu) are known to not use this by default. Some installations that use Oracle OCI8 may use this configure option to circumvent defunct processes. When PHP has been compiled with the --enable-sigchild option, a child process' exit code cannot be reliably determined via proc_close() or proc_get_status(). To work around this, we execute the child process with an additional pipe and use that to retrieve its exit code. This work-around incurs some overhead, so we only trigger this when necessary and when we detect that PHP has been compiled with the --enable-sigchild option. Because PHP does not provide a way to reliably detect this option, we try to inspect output of PHP's configure options from the phpinfo() function. The static setSigchildEnabled(bool $sigchild): void method can be used to explicitly enable or disable this behavior like this: // advanced: not recommended by default Process::setSigchildEnabled(true); Note that all processes instantiated after this method call will be affected. If this work-around is disabled on an affected PHP installation, the exit event may receive null instead of the actual exit code as described above. Similarly, some distributions are known to omit the configure options from phpinfo(), so automatic detection may fail to enable this work-around in some cases. You may then enable this explicitly as given above. Note: The original functionality was taken from Symfony's Process compoment. Windows Compatibility Due to platform constraints, this library provides only limited support for spawning child processes on Windows. In particular, PHP does not allow accessing standard I/O pipes without blocking. As such, this project will not allow constructing a child process with the default process pipes and will instead throw a LogicException on Windows by default: // throws LogicException on Windows $process = new Process('ping example.com'); $process->start($loop); There are a number of alternatives and workarounds as detailed below if you want to run a child process on Windows, each with its own set of pros and cons: This package does work on Windows Subsystem for Linux (or WSL) without issues. When you are in control over how your application is deployed, we recommend installing WSL when you want to run this package on Windows. If you only care about the exit code of a child process to check if its execution was successful, you can use custom pipes to omit any standard I/O pipes like this: $process = new Process('ping example.com', null, null, array()); $process->start($loop); $process->on('exit', function ($exitcode) { echo 'exit with ' . $exitcode . PHP_EOL; }); Similarly, this is also useful if your child process communicates over sockets with remote servers or even your parent process using the Socket component. This is usually considered the best alternative if you have control over how your child process communicates with the parent process. If you only care about command output after the child process has been executed, you can use custom pipes to configure file handles to be passed to the child process instead of pipes like this: $process = new Process('ping example.com', null, null, array( array('file', 'nul', 'r'), $stdout = tmpfile(), array('file', 'nul', 'w') )); $process->start($loop); $process->on('exit', function ($exitcode) use ($stdout) { echo 'exit with ' . $exitcode . PHP_EOL; // rewind to start and then read full file (demo only, this is blocking). // reading from shared file is only safe if you have some synchronization in place // or after the child process has terminated. rewind($stdout); echo stream_get_contents($stdout); fclose($stdout); }); Note that this example uses tmpfile()/fopen() for illustration purposes only. This should not be used in a truly async program because the filesystem is inherently blocking and each call could potentially take several seconds. See also the Filesystem component as an alternative. If you want to access command output as it happens in a streaming fashion, you can use redirection to spawn an additional process to forward your standard I/O streams to a socket and use custom pipes to omit any actual standard I/O pipes like this: $server = new React\\Socket\\Server('127.0.0.1:0', $loop); $server->on('connection', function (React\\Socket\\ConnectionInterface $connection) { $connection->on('data', function ($chunk) { echo $chunk; }); }); $command = 'ping example.com | foobar ' . escapeshellarg($server->getAddress()); $process = new Process($command, null, null, array()); $process->start($loop); $process->on('exit', function ($exitcode) use ($server) { $server->close(); echo 'exit with ' . $exitcode . PHP_EOL; }); Note how this will spawn another fictional foobar helper program to consume the standard output from the actual child process. This is in fact similar to the above recommendation of using socket connections in the child process, but in this case does not require modification of the actual child process. In this example, the fictional foobar helper program can be implemented by simply consuming all data from standard input and forwarding it to a socket connection like this: $socket = stream_socket_client($argv[1]); do { fwrite($socket, $data = fread(STDIN, 8192)); } while (isset($data[0])); Accordingly, this example can also be run with plain PHP without having to rely on any external helper program like this: $code = '$s=stream_socket_client($argv[1]);do{fwrite($s,$d=fread(STDIN, 8192));}while(isset($d[0]));'; $command = 'ping example.com | php -r ' . escapeshellarg($code) . ' ' . escapeshellarg($server->getAddress()); $process = new Process($command, null, null, array()); $process->start($loop); See also example #23. Note that this is for illustration purposes only and you may want to implement some proper error checks and/or socket verification in actual production use if you do not want to risk other processes connecting to the server socket. In this case, we suggest looking at the excellent createprocess-windows. Additionally, note that the command given to the Process will be passed to the underlying Windows-API (CreateProcess) as-is and the process will not be launched in a wrapping shell by default. In particular, this means that shell built-in functions such as echo hello or sleep 10 may have to be prefixed with an explicit shell command like this: $process = new Process('cmd /c echo hello', null, null, $pipes); $process->start($loop); Install The recommended way to install this library is through Composer. New to Composer? This will install the latest supported version: $ composer require react/child-process:^0.6.1 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. See above note for limited Windows Compatibility. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/PromiseStream.html":{"url":"4.Utility-Components/PromiseStream.html","title":"PromiseStream","keywords":"","body":"PromiseStream The missing link between Promise-land and Stream-land for ReactPHP. Table of Contents Usage buffer() first() all() unwrapReadable() unwrapWritable() Install Tests License Usage This lightweight library consists only of a few simple functions. All functions reside under the React\\Promise\\Stream namespace. The below examples assume you use an import statement similar to this: use React\\Promise\\Stream; Stream\\buffer(…); Alternatively, you can also refer to them with their fully-qualified name: \\React\\Promise\\Stream\\buffer(…); buffer() The buffer(ReadableStreamInterface $stream, ?int $maxLength = null): PromiseInterface function can be used to create a Promise which resolves with the stream data buffer. $stream = accessSomeJsonStream(); Stream\\buffer($stream)->then(function ($contents) { var_dump(json_decode($contents)); }); The promise will resolve with all data chunks concatenated once the stream closes. The promise will resolve with an empty string if the stream is already closed. The promise will reject if the stream emits an error. The promise will reject if it is cancelled. The optional $maxLength argument defaults to no limit. In case the maximum length is given and the stream emits more data before the end, the promise will be rejected with an \\OverflowException. $stream = accessSomeToLargeStream(); Stream\\buffer($stream, 1024)->then(function ($contents) { var_dump(json_decode($contents)); }, function ($error) { // Reaching here when the stream buffer goes above the max size, // in this example that is 1024 bytes, // or when the stream emits an error. }); first() The first(ReadableStreamInterface|WritableStreamInterface $stream, string $event = 'data'): PromiseInterface function can be used to create a Promise which resolves once the given event triggers for the first time. $stream = accessSomeJsonStream(); Stream\\first($stream)->then(function ($chunk) { echo 'The first chunk arrived: ' . $chunk; }); The promise will resolve with whatever the first event emitted or null if the event does not pass any data. If you do not pass a custom event name, then it will wait for the first \"data\" event and resolve with a string containing the first data chunk. The promise will reject if the stream emits an error – unless you're waiting for the \"error\" event, in which case it will resolve. The promise will reject once the stream closes – unless you're waiting for the \"close\" event, in which case it will resolve. The promise will reject if the stream is already closed. The promise will reject if it is cancelled. all() The all(ReadableStreamInterface|WritableStreamInterface $stream, string $event = 'data'): PromiseInterface function can be used to create a Promise which resolves with an array of all the event data. $stream = accessSomeJsonStream(); Stream\\all($stream)->then(function ($chunks) { echo 'The stream consists of ' . count($chunks) . ' chunk(s)'; }); The promise will resolve with an array of whatever all events emitted or null if the events do not pass any data. If you do not pass a custom event name, then it will wait for all the \"data\" events and resolve with an array containing all the data chunks. The promise will resolve with an array once the stream closes. The promise will resolve with an empty array if the stream is already closed. The promise will reject if the stream emits an error. The promise will reject if it is cancelled. unwrapReadable() The unwrapReadable(PromiseInterface $promise): ReadableStreamInterface function can be used to unwrap a Promise which resolves with a ReadableStreamInterface. This function returns a readable stream instance (implementing ReadableStreamInterface) right away which acts as a proxy for the future promise resolution. Once the given Promise resolves with a ReadableStreamInterface, its data will be piped to the output stream. //$promise = someFunctionWhichResolvesWithAStream(); $promise = startDownloadStream($uri); $stream = Stream\\unwrapReadable($promise); $stream->on('data', function ($data) { echo $data; }); $stream->on('end', function () { echo 'DONE'; }); If the given promise is either rejected or fulfilled with anything but an instance of ReadableStreamInterface, then the output stream will emit an error event and close: $promise = startDownloadStream($invalidUri); $stream = Stream\\unwrapReadable($promise); $stream->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage(); }); The given $promise SHOULD be pending, i.e. it SHOULD NOT be fulfilled or rejected at the time of invoking this function. If the given promise is already settled and does not resolve with an instance of ReadableStreamInterface, then you will not be able to receive the error event. You can close() the resulting stream at any time, which will either try to cancel() the pending promise or try to close() the underlying stream. $promise = startDownloadStream($uri); $stream = Stream\\unwrapReadable($promise); $loop->addTimer(2.0, function () use ($stream) { $stream->close(); }); unwrapWritable() The unwrapWritable(PromiseInterface $promise): WritableStreamInterface function can be used to unwrap a Promise which resolves with a WritableStreamInterface. This function returns a writable stream instance (implementing WritableStreamInterface) right away which acts as a proxy for the future promise resolution. Any writes to this instance will be buffered in memory for when the promise resolves. Once the given Promise resolves with a WritableStreamInterface, any data you have written to the proxy will be forwarded transparently to the inner stream. //$promise = someFunctionWhichResolvesWithAStream(); $promise = startUploadStream($uri); $stream = Stream\\unwrapWritable($promise); $stream->write('hello'); $stream->end('world'); $stream->on('close', function () { echo 'DONE'; }); If the given promise is either rejected or fulfilled with anything but an instance of WritableStreamInterface, then the output stream will emit an error event and close: $promise = startUploadStream($invalidUri); $stream = Stream\\unwrapWritable($promise); $stream->on('error', function (Exception $error) { echo 'Error: ' . $error->getMessage(); }); The given $promise SHOULD be pending, i.e. it SHOULD NOT be fulfilled or rejected at the time of invoking this function. If the given promise is already settled and does not resolve with an instance of WritableStreamInterface, then you will not be able to receive the error event. You can close() the resulting stream at any time, which will either try to cancel() the pending promise or try to close() the underlying stream. $promise = startUploadStream($uri); $stream = Stream\\unwrapWritable($promise); $loop->addTimer(2.0, function () use ($stream) { $stream->close(); }); Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/promise-stream:^1.2 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "},"4.Utility-Components/PromiseTimer.html":{"url":"4.Utility-Components/PromiseTimer.html","title":"PromiseTimer","keywords":"","body":"PromiseTimer A trivial implementation of timeouts for Promises, built on top of ReactPHP. Table of contents Usage timeout() Timeout cancellation Cancellation handler Input cancellation Output cancellation Collections resolve() Resolve cancellation reject() Reject cancellation TimeoutException Install Tests License Usage This lightweight library consists only of a few simple functions. All functions reside under the React\\Promise\\Timer namespace. The below examples assume you use an import statement similar to this: use React\\Promise\\Timer; Timer\\timeout(…); Alternatively, you can also refer to them with their fully-qualified name: \\React\\Promise\\Timer\\timeout(…); timeout() The timeout(PromiseInterface $promise, $time, LoopInterface $loop) function can be used to cancel operations that take too long. You need to pass in an input $promise that represents a pending operation and timeout parameters. It returns a new Promise with the following resolution behavior: If the input $promise resolves before $time seconds, resolve the resulting promise with its fulfillment value. If the input $promise rejects before $time seconds, reject the resulting promise with its rejection value. If the input $promise does not settle before $time seconds, cancel the operation and reject the resulting promise with a TimeoutException. Internally, the given $time value will be used to start a timer that will cancel the pending operation once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. If the input $promise is already settled, then the resulting promise will resolve or reject immediately without starting a timer at all. A common use case for handling only resolved values looks like this: $promise = accessSomeRemoteResource(); Timer\\timeout($promise, 10.0, $loop)->then(function ($value) { // the operation finished within 10.0 seconds }); A more complete example could look like this: $promise = accessSomeRemoteResource(); Timer\\timeout($promise, 10.0, $loop)->then( function ($value) { // the operation finished within 10.0 seconds }, function ($error) { if ($error instanceof Timer\\TimeoutException) { // the operation has failed due to a timeout } else { // the input operation has failed due to some other error } } ); Or if you're using react/promise v2.2.0 or up: Timer\\timeout($promise, 10.0, $loop) ->then(function ($value) { // the operation finished within 10.0 seconds }) ->otherwise(function (Timer\\TimeoutException $error) { // the operation has failed due to a timeout }) ->otherwise(function ($error) { // the input operation has failed due to some other error }) ; Timeout cancellation As discussed above, the timeout() function will cancel the underlying operation if it takes too long. This means that you can be sure the resulting promise will then be rejected with a TimeoutException. However, what happens to the underlying input $promise is a bit more tricky: Once the timer fires, we will try to call $promise->cancel() on the input $promise which in turn invokes its cancellation handler. This means that it's actually up the input $promise to handle cancellation support. A common use case involves cleaning up any resources like open network sockets or file handles or terminating external processes or timers. If the given input $promise does not support cancellation, then this is a NO-OP. This means that while the resulting promise will still be rejected, the underlying input $promise may still be pending and can hence continue consuming resources. See the following chapter for more details on the cancellation handler. Cancellation handler For example, an implementation for the above operation could look like this: function accessSomeRemoteResource() { return new Promise( function ($resolve, $reject) use (&$socket) { // this will be called once the promise is created // a common use case involves opening any resources and eventually resolving $socket = createSocket(); $socket->on('data', function ($data) use ($resolve) { $resolve($data); }); }, function ($resolve, $reject) use (&$socket) { // this will be called once calling `cancel()` on this promise // a common use case involves cleaning any resources and then rejecting $socket->close(); $reject(new \\RuntimeException('Operation cancelled')); } ); } In this example, calling $promise->cancel() will invoke the registered cancellation handler which then closes the network socket and rejects the Promise instance. If no cancellation handler is passed to the Promise constructor, then invoking its cancel() method it is effectively a NO-OP. This means that it may still be pending and can hence continue consuming resources. For more details on the promise cancellation, please refer to the Promise documentation. Input cancellation Irrespective of the timeout handling, you can also explicitly cancel() the input $promise at any time. This means that the timeout() handling does not affect cancellation of the input $promise, as demonstrated in the following example: $promise = accessSomeRemoteResource(); $timeout = Timer\\timeout($promise, 10.0, $loop); $promise->cancel(); The registered cancellation handler is responsible for handling the cancel() call: A described above, a common use involves resource cleanup and will then reject the Promise. If the input $promise is being rejected, then the timeout will be aborted and the resulting promise will also be rejected. If the input $promise is still pending, then the timout will continue running until the timer expires. The same happens if the input $promise does not register a cancellation handler. Output cancellation Similarily, you can also explicitly cancel() the resulting promise like this: $promise = accessSomeRemoteResource(); $timeout = Timer\\timeout($promise, 10.0, $loop); $timeout->cancel(); Note how this looks very similar to the above input cancellation example. Accordingly, it also behaves very similar. Calling cancel() on the resulting promise will merely try to cancel() the input $promise. This means that we do not take over responsibility of the outcome and it's entirely up to the input $promise to handle cancellation support. The registered cancellation handler is responsible for handling the cancel() call: As described above, a common use involves resource cleanup and will then reject the Promise. If the input $promise is being rejected, then the timeout will be aborted and the resulting promise will also be rejected. If the input $promise is still pending, then the timout will continue running until the timer expires. The same happens if the input $promise does not register a cancellation handler. To re-iterate, note that calling cancel() on the resulting promise will merely try to cancel the input $promise only. It is then up to the cancellation handler of the input promise to settle the promise. If the input promise is still pending when the timeout occurs, then the normal timeout cancellation handling will trigger, effectively rejecting the output promise with a TimeoutException. This is done for consistency with the timeout cancellation handling and also because it is assumed this is often used like this: $timeout = Timer\\timeout(accessSomeRemoteResource(), 10.0, $loop); $timeout->cancel(); As described above, this example works as expected and cleans up any resources allocated for the input $promise. Note that if the given input $promise does not support cancellation, then this is a NO-OP. This means that while the resulting promise will still be rejected after the timeout, the underlying input $promise may still be pending and can hence continue consuming resources. Collections If you want to wait for multiple promises to resolve, you can use the normal promise primitives like this: $promises = array( accessSomeRemoteResource(), accessSomeRemoteResource(), accessSomeRemoteResource() ); $promise = \\React\\Promise\\all($promises); Timer\\timeout($promise, 10, $loop)->then(function ($values) { // *all* promises resolved }); The applies to all promise collection primitives alike, i.e. all(), race(), any(), some() etc. For more details on the promise primitives, please refer to the Promise documentation. resolve() The resolve($time, LoopInterface $loop) function can be used to create a new Promise that resolves in $time seconds with the $time as the fulfillment value. Timer\\resolve(1.5, $loop)->then(function ($time) { echo 'Thanks for waiting ' . $time . ' seconds' . PHP_EOL; }); Internally, the given $time value will be used to start a timer that will resolve the promise once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. Resolve cancellation You can explicitly cancel() the resulting timer promise at any time: $timer = Timer\\resolve(2.0, $loop); $timer->cancel(); This will abort the timer and reject with a RuntimeException. reject() The reject($time, LoopInterface $loop) function can be used to create a new Promise which rejects in $time seconds with a TimeoutException. Timer\\reject(2.0, $loop)->then(null, function (TimeoutException $e) { echo 'Rejected after ' . $e->getTimeout() . ' seconds ' . PHP_EOL; }); Internally, the given $time value will be used to start a timer that will reject the promise once it triggers. This implies that if you pass a really small (or negative) value, it will still start a timer and will thus trigger at the earliest possible time in the future. This function complements the resolve() function and can be used as a basic building block for higher-level promise consumers. Reject cancellation You can explicitly cancel() the resulting timer promise at any time: $timer = Timer\\reject(2.0, $loop); $timer->cancel(); This will abort the timer and reject with a RuntimeException. TimeoutException The TimeoutException extends PHP's built-in RuntimeException. The getTimeout() method can be used to get the timeout value in seconds. Install The recommended way to install this library is through Composer. New to Composer? This project follows SemVer. This will install the latest supported version: $ composer require react/promise-timer:^1.6 See also the CHANGELOG for details about version upgrades. This project aims to run on any platform and thus does not require any PHP extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM. It's highly recommended to use PHP 7+ for this project. Tests To run the test suite, you first need to clone this repo and then install all dependencies through Composer: $ composer install To run the test suite, go to the project root and run: $ php vendor/bin/phpunit License MIT, see LICENSE file. "}}