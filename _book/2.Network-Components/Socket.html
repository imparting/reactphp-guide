
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Socket · ReactPHP 中文文档</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Imparting">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-toggle-chapters/toggle.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-comscore/test.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../3.Protocol-Components/Dns.html" />
    
    
    <link rel="prev" href="Datagram.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    简介
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">1.核心组件</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../1.Core-Components/EventLoop.html">
            
                <a href="../1.Core-Components/EventLoop.html">
            
                    
                    EventLoop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../1.Core-Components/Promise.html">
            
                <a href="../1.Core-Components/Promise.html">
            
                    
                    Promise
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../1.Core-Components/Stream.html">
            
                <a href="../1.Core-Components/Stream.html">
            
                    
                    Stream
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">2.网络组件</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="Datagram.html">
            
                <a href="Datagram.html">
            
                    
                    Datagram
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.2" data-path="Socket.html">
            
                <a href="Socket.html">
            
                    
                    Socket
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">3.协议组件</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../3.Protocol-Components/Dns.html">
            
                <a href="../3.Protocol-Components/Dns.html">
            
                    
                    Dns
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="../3.Protocol-Components/Http.html">
            
                <a href="../3.Protocol-Components/Http.html">
            
                    
                    Http
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="../3.Protocol-Components/HttpClient.html">
            
                <a href="../3.Protocol-Components/HttpClient.html">
            
                    
                    HttpClient
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">4.实用组件</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../4.Utility-Components/Cache.html">
            
                <a href="../4.Utility-Components/Cache.html">
            
                    
                    Cache
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="../4.Utility-Components/ChildProcess.html">
            
                <a href="../4.Utility-Components/ChildProcess.html">
            
                    
                    ChildProcess
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3" data-path="../4.Utility-Components/PromiseStream.html">
            
                <a href="../4.Utility-Components/PromiseStream.html">
            
                    
                    PromiseStream
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.4" data-path="../4.Utility-Components/PromiseTimer.html">
            
                <a href="../4.Utility-Components/PromiseTimer.html">
            
                    
                    PromiseTimer
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Socket</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="socket">Socket</h1>
<p><a href="https://travis-ci.org/reactphp/socket" target="_blank"><img src="https://travis-ci.org/reactphp/socket.svg?branch=master" alt="Build Status"></a></p>
<p>Async, streaming plaintext TCP/IP and secure TLS socket server and client
connections for <a href="https://reactphp.org/" target="_blank">ReactPHP</a>.</p>
<p>The socket library provides re-usable interfaces for a socket-layer
server and client based on the <a href="https://github.com/reactphp/event-loop" target="_blank"><code>EventLoop</code></a>
and <a href="https://github.com/reactphp/stream" target="_blank"><code>Stream</code></a> components.
Its server component allows you to build networking servers that accept incoming
connections from networking clients (such as an HTTP server).
Its client component allows you to build networking clients that establish
outgoing connections to networking servers (such as an HTTP or database client).
This library provides async, streaming means for all of this, so you can
handle multiple concurrent connections without blocking.</p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#quickstart-example">Quickstart example</a></li>
<li><a href="#connection-usage">Connection usage</a><ul>
<li><a href="#connectioninterface">ConnectionInterface</a><ul>
<li><a href="#getremoteaddress">getRemoteAddress()</a></li>
<li><a href="#getlocaladdress">getLocalAddress()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#server-usage">Server usage</a><ul>
<li><a href="#serverinterface">ServerInterface</a><ul>
<li><a href="#connection-event">connection event</a></li>
<li><a href="#error-event">error event</a></li>
<li><a href="#getaddress">getAddress()</a></li>
<li><a href="#pause">pause()</a></li>
<li><a href="#resume">resume()</a></li>
<li><a href="#close">close()</a></li>
</ul>
</li>
<li><a href="#server">Server</a></li>
<li><a href="#advanced-server-usage">Advanced server usage</a><ul>
<li><a href="#tcpserver">TcpServer</a></li>
<li><a href="#secureserver">SecureServer</a></li>
<li><a href="#unixserver">UnixServer</a></li>
<li><a href="#limitingserver">LimitingServer</a><ul>
<li><a href="#getconnections">getConnections()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#client-usage">Client usage</a><ul>
<li><a href="#connectorinterface">ConnectorInterface</a><ul>
<li><a href="#connect">connect()</a></li>
</ul>
</li>
<li><a href="#connector">Connector</a></li>
<li><a href="#advanced-client-usage">Advanced client usage</a><ul>
<li><a href="#tcpconnector">TcpConnector</a></li>
<li><a href="#happyeyeballsconnector">HappyEyeBallsConnector</a></li>
<li><a href="#dnsconnector">DnsConnector</a></li>
<li><a href="#secureconnector">SecureConnector</a></li>
<li><a href="#timeoutconnector">TimeoutConnector</a></li>
<li><a href="#unixconnector">UnixConnector</a></li>
<li><a href="#fixeduriconnector">FixUriConnector</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#install">Install</a></li>
<li><a href="#tests">Tests</a></li>
<li><a href="#license">License</a></li>
</ul>
<h2 id="quickstart-example">Quickstart example</h2>
<p>Here is a server that closes the connection if you send it anything:</p>
<pre><code class="lang-php">$loop = React\EventLoop\Factory::create();
$socket = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;127.0.0.1:8080&apos;</span>, $loop);

$socket-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&quot;Hello &quot;</span> . $connection-&gt;getRemoteAddress() . <span class="hljs-string">&quot;!\n&quot;</span>);
    $connection-&gt;write(<span class="hljs-string">&quot;Welcome to this amazing server!\n&quot;</span>);
    $connection-&gt;write(<span class="hljs-string">&quot;Here&apos;s a tip: don&apos;t say anything.\n&quot;</span>);

    $connection-&gt;on(<span class="hljs-string">&apos;data&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($data)</span> <span class="hljs-title">use</span> <span class="hljs-params">($connection)</span> </span>{
        $connection-&gt;close();
    });
});

$loop-&gt;run();
</code></pre>
<p>See also the <a href="examples">examples</a>.</p>
<p>Here&apos;s a client that outputs the output of said server and then attempts to
send it a string:</p>
<pre><code class="lang-php">$loop = React\EventLoop\Factory::create();
$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop);

$connector-&gt;connect(<span class="hljs-string">&apos;127.0.0.1:8080&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> <span class="hljs-title">use</span> <span class="hljs-params">($loop)</span> </span>{
    $connection-&gt;pipe(<span class="hljs-keyword">new</span> React\Stream\WritableResourceStream(STDOUT, $loop));
    $connection-&gt;write(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);
});

$loop-&gt;run();
</code></pre>
<h2 id="connection-usage">Connection usage</h2>
<h3 id="connectioninterface">ConnectionInterface</h3>
<p>The <code>ConnectionInterface</code> is used to represent any incoming and outgoing
connection, such as a normal TCP/IP connection.</p>
<p>An incoming or outgoing connection is a duplex stream (both readable and
writable) that implements React&apos;s
<a href="https://github.com/reactphp/stream#duplexstreaminterface" target="_blank"><code>DuplexStreamInterface</code></a>.
It contains additional properties for the local and remote address (client IP)
where this connection has been established to/from.</p>
<p>Most commonly, instances implementing this <code>ConnectionInterface</code> are emitted
by all classes implementing the <a href="#serverinterface"><code>ServerInterface</code></a> and
used by all classes implementing the <a href="#connectorinterface"><code>ConnectorInterface</code></a>.</p>
<p>Because the <code>ConnectionInterface</code> implements the underlying
<a href="https://github.com/reactphp/stream#duplexstreaminterface" target="_blank"><code>DuplexStreamInterface</code></a>
you can use any of its events and methods as usual:</p>
<pre><code class="lang-php">$connection-&gt;on(<span class="hljs-string">&apos;data&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($chunk)</span> </span>{
    <span class="hljs-keyword">echo</span> $chunk;
});

$connection-&gt;on(<span class="hljs-string">&apos;end&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;ended&apos;</span>;
});

$connection-&gt;on(<span class="hljs-string">&apos;error&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Exception $e)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;error: &apos;</span> . $e-&gt;getMessage();
});

$connection-&gt;on(<span class="hljs-string">&apos;close&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;closed&apos;</span>;
});

$connection-&gt;write($data);
$connection-&gt;end($data = <span class="hljs-keyword">null</span>);
$connection-&gt;close();
<span class="hljs-comment">// &#x2026;</span>
</code></pre>
<p>For more details, see the
<a href="https://github.com/reactphp/stream#duplexstreaminterface" target="_blank"><code>DuplexStreamInterface</code></a>.</p>
<h4 id="getremoteaddress">getRemoteAddress()</h4>
<p>The <code>getRemoteAddress(): ?string</code> method returns the full remote address
(URI) where this connection has been established with.</p>
<pre><code class="lang-php">$address = $connection-&gt;getRemoteAddress();
<span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Connection with &apos;</span> . $address . PHP_EOL;
</code></pre>
<p>If the remote address can not be determined or is unknown at this time (such as
after the connection has been closed), it MAY return a <code>NULL</code> value instead.</p>
<p>Otherwise, it will return the full address (URI) as a string value, such
as <code>tcp://127.0.0.1:8080</code>, <code>tcp://[::1]:80</code>, <code>tls://127.0.0.1:443</code>,
<code>unix://example.sock</code> or <code>unix:///path/to/example.sock</code>.
Note that individual URI components are application specific and depend
on the underlying transport protocol.</p>
<p>If this is a TCP/IP based connection and you only want the remote IP, you may
use something like this:</p>
<pre><code class="lang-php">$address = $connection-&gt;getRemoteAddress();
$ip = trim(parse_url($address, PHP_URL_HOST), <span class="hljs-string">&apos;[]&apos;</span>);
<span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Connection with &apos;</span> . $ip . PHP_EOL;
</code></pre>
<h4 id="getlocaladdress">getLocalAddress()</h4>
<p>The <code>getLocalAddress(): ?string</code> method returns the full local address
(URI) where this connection has been established with.</p>
<pre><code class="lang-php">$address = $connection-&gt;getLocalAddress();
<span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Connection with &apos;</span> . $address . PHP_EOL;
</code></pre>
<p>If the local address can not be determined or is unknown at this time (such as
after the connection has been closed), it MAY return a <code>NULL</code> value instead.</p>
<p>Otherwise, it will return the full address (URI) as a string value, such
as <code>tcp://127.0.0.1:8080</code>, <code>tcp://[::1]:80</code>, <code>tls://127.0.0.1:443</code>,
<code>unix://example.sock</code> or <code>unix:///path/to/example.sock</code>.
Note that individual URI components are application specific and depend
on the underlying transport protocol.</p>
<p>This method complements the <a href="#getremoteaddress"><code>getRemoteAddress()</code></a> method,
so they should not be confused.</p>
<p>If your <code>TcpServer</code> instance is listening on multiple interfaces (e.g. using
the address <code>0.0.0.0</code>), you can use this method to find out which interface
actually accepted this connection (such as a public or local interface).</p>
<p>If your system has multiple interfaces (e.g. a WAN and a LAN interface),
you can use this method to find out which interface was actually
used for this connection.</p>
<h2 id="server-usage">Server usage</h2>
<h3 id="serverinterface">ServerInterface</h3>
<p>The <code>ServerInterface</code> is responsible for providing an interface for accepting
incoming streaming connections, such as a normal TCP/IP connection.</p>
<p>Most higher-level components (such as a HTTP server) accept an instance
implementing this interface to accept incoming streaming connections.
This is usually done via dependency injection, so it&apos;s fairly simple to actually
swap this implementation against any other implementation of this interface.
This means that you SHOULD typehint against this interface instead of a concrete
implementation of this interface.</p>
<p>Besides defining a few methods, this interface also implements the
<a href="https://github.com/igorw/evenement" target="_blank"><code>EventEmitterInterface</code></a>
which allows you to react to certain events.</p>
<h4 id="connection-event">connection event</h4>
<p>The <code>connection</code> event will be emitted whenever a new connection has been
established, i.e. a new client connects to this server socket:</p>
<pre><code class="lang-php">$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;new connection&apos;</span> . PHP_EOL;
});
</code></pre>
<p>See also the <a href="#connectioninterface"><code>ConnectionInterface</code></a> for more details
about handling the incoming connection.</p>
<h4 id="error-event">error event</h4>
<p>The <code>error</code> event will be emitted whenever there&apos;s an error accepting a new
connection from a client.</p>
<pre><code class="lang-php">$server-&gt;on(<span class="hljs-string">&apos;error&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Exception $e)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;error: &apos;</span> . $e-&gt;getMessage() . PHP_EOL;
});
</code></pre>
<p>Note that this is not a fatal error event, i.e. the server keeps listening for
new connections even after this event.</p>
<h4 id="getaddress">getAddress()</h4>
<p>The <code>getAddress(): ?string</code> method can be used to
return the full address (URI) this server is currently listening on.</p>
<pre><code class="lang-php">$address = $server-&gt;getAddress();
<span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Server listening on &apos;</span> . $address . PHP_EOL;
</code></pre>
<p>If the address can not be determined or is unknown at this time (such as
after the socket has been closed), it MAY return a <code>NULL</code> value instead.</p>
<p>Otherwise, it will return the full address (URI) as a string value, such
as <code>tcp://127.0.0.1:8080</code>, <code>tcp://[::1]:80</code>, <code>tls://127.0.0.1:443</code>
<code>unix://example.sock</code> or <code>unix:///path/to/example.sock</code>.
Note that individual URI components are application specific and depend
on the underlying transport protocol.</p>
<p>If this is a TCP/IP based server and you only want the local port, you may
use something like this:</p>
<pre><code class="lang-php">$address = $server-&gt;getAddress();
$port = parse_url($address, PHP_URL_PORT);
<span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Server listening on port &apos;</span> . $port . PHP_EOL;
</code></pre>
<h4 id="pause">pause()</h4>
<p>The <code>pause(): void</code> method can be used to
pause accepting new incoming connections.</p>
<p>Removes the socket resource from the EventLoop and thus stop accepting
new connections. Note that the listening socket stays active and is not
closed.</p>
<p>This means that new incoming connections will stay pending in the
operating system backlog until its configurable backlog is filled.
Once the backlog is filled, the operating system may reject further
incoming connections until the backlog is drained again by resuming
to accept new connections.</p>
<p>Once the server is paused, no futher <code>connection</code> events SHOULD
be emitted.</p>
<pre><code class="lang-php">$server-&gt;pause();

$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, assertShouldNeverCalled());
</code></pre>
<p>This method is advisory-only, though generally not recommended, the
server MAY continue emitting <code>connection</code> events.</p>
<p>Unless otherwise noted, a successfully opened server SHOULD NOT start
in paused state.</p>
<p>You can continue processing events by calling <code>resume()</code> again.</p>
<p>Note that both methods can be called any number of times, in particular
calling <code>pause()</code> more than once SHOULD NOT have any effect.
Similarly, calling this after <code>close()</code> is a NO-OP.</p>
<h4 id="resume">resume()</h4>
<p>The <code>resume(): void</code> method can be used to
resume accepting new incoming connections.</p>
<p>Re-attach the socket resource to the EventLoop after a previous <code>pause()</code>.</p>
<pre><code class="lang-php">$server-&gt;pause();

$loop-&gt;addTimer(<span class="hljs-number">1.0</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> <span class="hljs-title">use</span> <span class="hljs-params">($server)</span> </span>{
    $server-&gt;resume();
});
</code></pre>
<p>Note that both methods can be called any number of times, in particular
calling <code>resume()</code> without a prior <code>pause()</code> SHOULD NOT have any effect.
Similarly, calling this after <code>close()</code> is a NO-OP.</p>
<h4 id="close">close()</h4>
<p>The <code>close(): void</code> method can be used to
shut down this listening socket.</p>
<p>This will stop listening for new incoming connections on this socket.</p>
<pre><code class="lang-php"><span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Shutting down server socket&apos;</span> . PHP_EOL;
$server-&gt;close();
</code></pre>
<p>Calling this method more than once on the same instance is a NO-OP.</p>
<h3 id="server">Server</h3>
<p>The <code>Server</code> class is the main class in this package that implements the
<a href="#serverinterface"><code>ServerInterface</code></a> and allows you to accept incoming
streaming connections, such as plaintext TCP/IP or secure TLS connection streams.
Connections can also be accepted on Unix domain sockets.</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-number">8080</span>, $loop);
</code></pre>
<p>As above, the <code>$uri</code> parameter can consist of only a port, in which case the
server will default to listening on the localhost address <code>127.0.0.1</code>,
which means it will not be reachable from outside of this system.</p>
<p>In order to use a random port assignment, you can use the port <code>0</code>:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-number">0</span>, $loop);
$address = $server-&gt;getAddress();
</code></pre>
<p>In order to change the host the socket is listening on, you can provide an IP
address through the first parameter provided to the constructor, optionally
preceded by the <code>tcp://</code> scheme:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;192.168.0.1:8080&apos;</span>, $loop);
</code></pre>
<p>If you want to listen on an IPv6 address, you MUST enclose the host in square
brackets:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;[::1]:8080&apos;</span>, $loop);
</code></pre>
<p>To listen on a Unix domain socket (UDS) path, you MUST prefix the URI with the
<code>unix://</code> scheme:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;unix:///tmp/server.sock&apos;</span>, $loop);
</code></pre>
<p>If the given URI is invalid, does not contain a port, any other scheme or if it
contains a hostname, it will throw an <code>InvalidArgumentException</code>:</p>
<pre><code class="lang-php"><span class="hljs-comment">// throws InvalidArgumentException due to missing port</span>
$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;127.0.0.1&apos;</span>, $loop);
</code></pre>
<p>If the given URI appears to be valid, but listening on it fails (such as if port
is already in use or port below 1024 may require root access etc.), it will
throw a <code>RuntimeException</code>:</p>
<pre><code class="lang-php">$first = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-number">8080</span>, $loop);

<span class="hljs-comment">// throws RuntimeException because port is already in use</span>
$second = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-number">8080</span>, $loop);
</code></pre>
<blockquote>
<p>Note that these error conditions may vary depending on your system and/or
  configuration.
  See the exception message and code for more details about the actual error
  condition.</p>
</blockquote>
<p>Optionally, you can specify <a href="https://www.php.net/manual/en/context.socket.php" target="_blank">TCP socket context options</a>
for the underlying stream socket resource like this:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;[::1]:8080&apos;</span>, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tcp&apos;</span> =&gt; <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&apos;backlog&apos;</span> =&gt; <span class="hljs-number">200</span>,
        <span class="hljs-string">&apos;so_reuseport&apos;</span> =&gt; <span class="hljs-keyword">true</span>,
        <span class="hljs-string">&apos;ipv6_v6only&apos;</span> =&gt; <span class="hljs-keyword">true</span>
    )
));
</code></pre>
<blockquote>
<p>Note that available <a href="https://www.php.net/manual/en/context.socket.php" target="_blank">socket context options</a>,
  their defaults and effects of changing these may vary depending on your system
  and/or PHP version.
  Passing unknown context options has no effect.
  The <code>backlog</code> context option defaults to <code>511</code> unless given explicitly.
  For BC reasons, you can also pass the TCP socket context options as a simple
  array without wrapping this in another array under the <code>tcp</code> key.</p>
</blockquote>
<p>You can start a secure TLS (formerly known as SSL) server by simply prepending
the <code>tls://</code> URI scheme.
Internally, it will wait for plaintext TCP/IP connections and then performs a
TLS handshake for each connection.
It thus requires valid <a href="https://www.php.net/manual/en/context.ssl.php" target="_blank">TLS context options</a>,
which in its most basic form may look something like this if you&apos;re using a
PEM encoded certificate file:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;tls://127.0.0.1:8080&apos;</span>, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tls&apos;</span> =&gt; <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&apos;local_cert&apos;</span> =&gt; <span class="hljs-string">&apos;server.pem&apos;</span>
    )
));
</code></pre>
<blockquote>
<p>Note that the certificate file will not be loaded on instantiation but when an
  incoming connection initializes its TLS context.
  This implies that any invalid certificate file paths or contents will only cause
  an <code>error</code> event at a later time.</p>
</blockquote>
<p>If your private key is encrypted with a passphrase, you have to specify it
like this:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;tls://127.0.0.1:8000&apos;</span>, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tls&apos;</span> =&gt; <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&apos;local_cert&apos;</span> =&gt; <span class="hljs-string">&apos;server.pem&apos;</span>,
        <span class="hljs-string">&apos;passphrase&apos;</span> =&gt; <span class="hljs-string">&apos;secret&apos;</span>
    )
));
</code></pre>
<p>By default, this server supports TLSv1.0+ and excludes support for legacy
SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you
want to negotiate with the remote side:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\Server(<span class="hljs-string">&apos;tls://127.0.0.1:8000&apos;</span>, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tls&apos;</span> =&gt; <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&apos;local_cert&apos;</span> =&gt; <span class="hljs-string">&apos;server.pem&apos;</span>,
        <span class="hljs-string">&apos;crypto_method&apos;</span> =&gt; STREAM_CRYPTO_METHOD_TLSv1_2_SERVER
    )
));
</code></pre>
<blockquote>
<p>Note that available <a href="https://www.php.net/manual/en/context.ssl.php" target="_blank">TLS context options</a>,
  their defaults and effects of changing these may vary depending on your system
  and/or PHP version.
  The outer context array allows you to also use <code>tcp</code> (and possibly more)
  context options at the same time.
  Passing unknown context options has no effect.
  If you do not use the <code>tls://</code> scheme, then passing <code>tls</code> context options
  has no effect.</p>
</blockquote>
<p>Whenever a client connects, it will emit a <code>connection</code> event with a connection
instance implementing <a href="#connectioninterface"><code>ConnectionInterface</code></a>:</p>
<pre><code class="lang-php">$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Plaintext connection from &apos;</span> . $connection-&gt;getRemoteAddress() . PHP_EOL;

    $connection-&gt;write(<span class="hljs-string">&apos;hello there!&apos;</span> . PHP_EOL);
    &#x2026;
});
</code></pre>
<p>See also the <a href="#serverinterface"><code>ServerInterface</code></a> for more details.</p>
<blockquote>
<p>Note that the <code>Server</code> class is a concrete implementation for TCP/IP sockets.
  If you want to typehint in your higher-level protocol implementation, you SHOULD
  use the generic <a href="#serverinterface"><code>ServerInterface</code></a> instead.</p>
</blockquote>
<h3 id="advanced-server-usage">Advanced server usage</h3>
<h4 id="tcpserver">TcpServer</h4>
<p>The <code>TcpServer</code> class implements the <a href="#serverinterface"><code>ServerInterface</code></a> and
is responsible for accepting plaintext TCP/IP connections.</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-number">8080</span>, $loop);
</code></pre>
<p>As above, the <code>$uri</code> parameter can consist of only a port, in which case the
server will default to listening on the localhost address <code>127.0.0.1</code>,
which means it will not be reachable from outside of this system.</p>
<p>In order to use a random port assignment, you can use the port <code>0</code>:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-number">0</span>, $loop);
$address = $server-&gt;getAddress();
</code></pre>
<p>In order to change the host the socket is listening on, you can provide an IP
address through the first parameter provided to the constructor, optionally
preceded by the <code>tcp://</code> scheme:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-string">&apos;192.168.0.1:8080&apos;</span>, $loop);
</code></pre>
<p>If you want to listen on an IPv6 address, you MUST enclose the host in square
brackets:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-string">&apos;[::1]:8080&apos;</span>, $loop);
</code></pre>
<p>If the given URI is invalid, does not contain a port, any other scheme or if it
contains a hostname, it will throw an <code>InvalidArgumentException</code>:</p>
<pre><code class="lang-php"><span class="hljs-comment">// throws InvalidArgumentException due to missing port</span>
$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-string">&apos;127.0.0.1&apos;</span>, $loop);
</code></pre>
<p>If the given URI appears to be valid, but listening on it fails (such as if port
is already in use or port below 1024 may require root access etc.), it will
throw a <code>RuntimeException</code>:</p>
<pre><code class="lang-php">$first = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-number">8080</span>, $loop);

<span class="hljs-comment">// throws RuntimeException because port is already in use</span>
$second = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-number">8080</span>, $loop);
</code></pre>
<blockquote>
<p>Note that these error conditions may vary depending on your system and/or
configuration.
See the exception message and code for more details about the actual error
condition.</p>
</blockquote>
<p>Optionally, you can specify <a href="https://www.php.net/manual/en/context.socket.php" target="_blank">socket context options</a>
for the underlying stream socket resource like this:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-string">&apos;[::1]:8080&apos;</span>, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;backlog&apos;</span> =&gt; <span class="hljs-number">200</span>,
    <span class="hljs-string">&apos;so_reuseport&apos;</span> =&gt; <span class="hljs-keyword">true</span>,
    <span class="hljs-string">&apos;ipv6_v6only&apos;</span> =&gt; <span class="hljs-keyword">true</span>
));
</code></pre>
<blockquote>
<p>Note that available <a href="https://www.php.net/manual/en/context.socket.php" target="_blank">socket context options</a>,
their defaults and effects of changing these may vary depending on your system
and/or PHP version.
Passing unknown context options has no effect.
The <code>backlog</code> context option defaults to <code>511</code> unless given explicitly.</p>
</blockquote>
<p>Whenever a client connects, it will emit a <code>connection</code> event with a connection
instance implementing <a href="#connectioninterface"><code>ConnectionInterface</code></a>:</p>
<pre><code class="lang-php">$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Plaintext connection from &apos;</span> . $connection-&gt;getRemoteAddress() . PHP_EOL;

    $connection-&gt;write(<span class="hljs-string">&apos;hello there!&apos;</span> . PHP_EOL);
    &#x2026;
});
</code></pre>
<p>See also the <a href="#serverinterface"><code>ServerInterface</code></a> for more details.</p>
<h4 id="secureserver">SecureServer</h4>
<p>The <code>SecureServer</code> class implements the <a href="#serverinterface"><code>ServerInterface</code></a>
and is responsible for providing a secure TLS (formerly known as SSL) server.</p>
<p>It does so by wrapping a <a href="#tcpserver"><code>TcpServer</code></a> instance which waits for plaintext
TCP/IP connections and then performs a TLS handshake for each connection.
It thus requires valid <a href="https://www.php.net/manual/en/context.ssl.php" target="_blank">TLS context options</a>,
which in its most basic form may look something like this if you&apos;re using a
PEM encoded certificate file:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-number">8000</span>, $loop);
$server = <span class="hljs-keyword">new</span> React\Socket\SecureServer($server, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;local_cert&apos;</span> =&gt; <span class="hljs-string">&apos;server.pem&apos;</span>
));
</code></pre>
<blockquote>
<p>Note that the certificate file will not be loaded on instantiation but when an
incoming connection initializes its TLS context.
This implies that any invalid certificate file paths or contents will only cause
an <code>error</code> event at a later time.</p>
</blockquote>
<p>If your private key is encrypted with a passphrase, you have to specify it
like this:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-number">8000</span>, $loop);
$server = <span class="hljs-keyword">new</span> React\Socket\SecureServer($server, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;local_cert&apos;</span> =&gt; <span class="hljs-string">&apos;server.pem&apos;</span>,
    <span class="hljs-string">&apos;passphrase&apos;</span> =&gt; <span class="hljs-string">&apos;secret&apos;</span>
));
</code></pre>
<p>By default, this server supports TLSv1.0+ and excludes support for legacy
SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you
want to negotiate with the remote side:</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\TcpServer(<span class="hljs-number">8000</span>, $loop);
$server = <span class="hljs-keyword">new</span> React\Socket\SecureServer($server, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;local_cert&apos;</span> =&gt; <span class="hljs-string">&apos;server.pem&apos;</span>,
    <span class="hljs-string">&apos;crypto_method&apos;</span> =&gt; STREAM_CRYPTO_METHOD_TLSv1_2_SERVER
));
</code></pre>
<blockquote>
<p>Note that available <a href="https://www.php.net/manual/en/context.ssl.php" target="_blank">TLS context options</a>,
their defaults and effects of changing these may vary depending on your system
and/or PHP version.
Passing unknown context options has no effect.</p>
</blockquote>
<p>Whenever a client completes the TLS handshake, it will emit a <code>connection</code> event
with a connection instance implementing <a href="#connectioninterface"><code>ConnectionInterface</code></a>:</p>
<pre><code class="lang-php">$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Secure connection from&apos;</span> . $connection-&gt;getRemoteAddress() . PHP_EOL;

    $connection-&gt;write(<span class="hljs-string">&apos;hello there!&apos;</span> . PHP_EOL);
    &#x2026;
});
</code></pre>
<p>Whenever a client fails to perform a successful TLS handshake, it will emit an
<code>error</code> event and then close the underlying TCP/IP connection:</p>
<pre><code class="lang-php">$server-&gt;on(<span class="hljs-string">&apos;error&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Exception $e)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;Error&apos;</span> . $e-&gt;getMessage() . PHP_EOL;
});
</code></pre>
<p>See also the <a href="#serverinterface"><code>ServerInterface</code></a> for more details.</p>
<p>Note that the <code>SecureServer</code> class is a concrete implementation for TLS sockets.
If you want to typehint in your higher-level protocol implementation, you SHOULD
use the generic <a href="#serverinterface"><code>ServerInterface</code></a> instead.</p>
<blockquote>
<p>Advanced usage: Despite allowing any <code>ServerInterface</code> as first parameter,
you SHOULD pass a <code>TcpServer</code> instance as first parameter, unless you
know what you&apos;re doing.
Internally, the <code>SecureServer</code> has to set the required TLS context options on
the underlying stream resources.
These resources are not exposed through any of the interfaces defined in this
package, but only through the internal <code>Connection</code> class.
The <code>TcpServer</code> class is guaranteed to emit connections that implement
the <code>ConnectionInterface</code> and uses the internal <code>Connection</code> class in order to
expose these underlying resources.
If you use a custom <code>ServerInterface</code> and its <code>connection</code> event does not
meet this requirement, the <code>SecureServer</code> will emit an <code>error</code> event and
then close the underlying connection.</p>
</blockquote>
<h4 id="unixserver">UnixServer</h4>
<p>The <code>UnixServer</code> class implements the <a href="#serverinterface"><code>ServerInterface</code></a> and
is responsible for accepting connections on Unix domain sockets (UDS).</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\UnixServer(<span class="hljs-string">&apos;/tmp/server.sock&apos;</span>, $loop);
</code></pre>
<p>As above, the <code>$uri</code> parameter can consist of only a socket path or socket path
prefixed by the <code>unix://</code> scheme.</p>
<p>If the given URI appears to be valid, but listening on it fails (such as if the
socket is already in use or the file not accessible etc.), it will throw a
<code>RuntimeException</code>:</p>
<pre><code class="lang-php">$first = <span class="hljs-keyword">new</span> React\Socket\UnixServer(<span class="hljs-string">&apos;/tmp/same.sock&apos;</span>, $loop);

<span class="hljs-comment">// throws RuntimeException because socket is already in use</span>
$second = <span class="hljs-keyword">new</span> React\Socket\UnixServer(<span class="hljs-string">&apos;/tmp/same.sock&apos;</span>, $loop);
</code></pre>
<blockquote>
<p>Note that these error conditions may vary depending on your system and/or
  configuration.
  In particular, Zend PHP does only report &quot;Unknown error&quot; when the UDS path
  already exists and can not be bound. You may want to check <code>is_file()</code> on the
  given UDS path to report a more user-friendly error message in this case.
  See the exception message and code for more details about the actual error
  condition.</p>
</blockquote>
<p>Whenever a client connects, it will emit a <code>connection</code> event with a connection
instance implementing <a href="#connectioninterface"><code>ConnectionInterface</code></a>:</p>
<pre><code class="lang-php">$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&apos;New connection&apos;</span> . PHP_EOL;

    $connection-&gt;write(<span class="hljs-string">&apos;hello there!&apos;</span> . PHP_EOL);
    &#x2026;
});
</code></pre>
<p>See also the <a href="#serverinterface"><code>ServerInterface</code></a> for more details.</p>
<h4 id="limitingserver">LimitingServer</h4>
<p>The <code>LimitingServer</code> decorator wraps a given <code>ServerInterface</code> and is responsible
for limiting and keeping track of open connections to this server instance.</p>
<p>Whenever the underlying server emits a <code>connection</code> event, it will check its
limits and then either</p>
<ul>
<li>keep track of this connection by adding it to the list of
open connections and then forward the <code>connection</code> event</li>
<li>or reject (close) the connection when its limits are exceeded and will
forward an <code>error</code> event instead.</li>
</ul>
<p>Whenever a connection closes, it will remove this connection from the list of
open connections.</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\LimitingServer($server, <span class="hljs-number">100</span>);
$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;hello there!&apos;</span> . PHP_EOL);
    &#x2026;
});
</code></pre>
<p>See also the <a href="examples">second example</a> for more details.</p>
<p>You have to pass a maximum number of open connections to ensure
the server will automatically reject (close) connections once this limit
is exceeded. In this case, it will emit an <code>error</code> event to inform about
this and no <code>connection</code> event will be emitted.</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\LimitingServer($server, <span class="hljs-number">100</span>);
$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;hello there!&apos;</span> . PHP_EOL);
    &#x2026;
});
</code></pre>
<p>You MAY pass a <code>null</code> limit in order to put no limit on the number of
open connections and keep accepting new connection until you run out of
operating system resources (such as open file handles). This may be
useful if you do not want to take care of applying a limit but still want
to use the <code>getConnections()</code> method.</p>
<p>You can optionally configure the server to pause accepting new
connections once the connection limit is reached. In this case, it will
pause the underlying server and no longer process any new connections at
all, thus also no longer closing any excessive connections.
The underlying operating system is responsible for keeping a backlog of
pending connections until its limit is reached, at which point it will
start rejecting further connections.
Once the server is below the connection limit, it will continue consuming
connections from the backlog and will process any outstanding data on
each connection.
This mode may be useful for some protocols that are designed to wait for
a response message (such as HTTP), but may be less useful for other
protocols that demand immediate responses (such as a &quot;welcome&quot; message in
an interactive chat).</p>
<pre><code class="lang-php">$server = <span class="hljs-keyword">new</span> React\Socket\LimitingServer($server, <span class="hljs-number">100</span>, <span class="hljs-keyword">true</span>);
$server-&gt;on(<span class="hljs-string">&apos;connection&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;hello there!&apos;</span> . PHP_EOL);
    &#x2026;
});
</code></pre>
<h5 id="getconnections">getConnections()</h5>
<p>The <code>getConnections(): ConnectionInterface[]</code> method can be used to
return an array with all currently active connections.</p>
<pre><code class="lang-php"><span class="hljs-keyword">foreach</span> ($server-&gt;getConnection() <span class="hljs-keyword">as</span> $connection) {
    $connection-&gt;write(<span class="hljs-string">&apos;Hi!&apos;</span>);
}
</code></pre>
<h2 id="client-usage">Client usage</h2>
<h3 id="connectorinterface">ConnectorInterface</h3>
<p>The <code>ConnectorInterface</code> is responsible for providing an interface for
establishing streaming connections, such as a normal TCP/IP connection.</p>
<p>This is the main interface defined in this package and it is used throughout
React&apos;s vast ecosystem.</p>
<p>Most higher-level components (such as HTTP, database or other networking
service clients) accept an instance implementing this interface to create their
TCP/IP connection to the underlying networking service.
This is usually done via dependency injection, so it&apos;s fairly simple to actually
swap this implementation against any other implementation of this interface.</p>
<p>The interface only offers a single method:</p>
<h4 id="connect">connect()</h4>
<p>The <code>connect(string $uri): PromiseInterface&lt;ConnectionInterface,Exception&gt;</code> method
can be used to create a streaming connection to the given remote address.</p>
<p>It returns a <a href="https://github.com/reactphp/promise" target="_blank">Promise</a> which either
fulfills with a stream implementing <a href="#connectioninterface"><code>ConnectionInterface</code></a>
on success or rejects with an <code>Exception</code> if the connection is not successful:</p>
<pre><code class="lang-php">$connector-&gt;connect(<span class="hljs-string">&apos;google.com:443&apos;</span>)-&gt;then(
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
        <span class="hljs-comment">// connection successfully established</span>
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Exception $error)</span> </span>{
        <span class="hljs-comment">// failed to connect due to $error</span>
    }
);
</code></pre>
<p>See also <a href="#connectioninterface"><code>ConnectionInterface</code></a> for more details.</p>
<p>The returned Promise MUST be implemented in such a way that it can be
cancelled when it is still pending. Cancelling a pending promise MUST
reject its value with an <code>Exception</code>. It SHOULD clean up any underlying
resources and references as applicable:</p>
<pre><code class="lang-php">$promise = $connector-&gt;connect($uri);

$promise-&gt;cancel();
</code></pre>
<h3 id="connector">Connector</h3>
<p>The <code>Connector</code> class is the main class in this package that implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and allows you to create streaming connections.</p>
<p>You can use this connector to create any kind of streaming connections, such
as plaintext TCP/IP, secure TLS or local Unix connection streams.</p>
<p>It binds to the main event loop and can be used like this:</p>
<pre><code class="lang-php">$loop = React\EventLoop\Factory::create();
$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop);

$connector-&gt;connect($uri)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});

$loop-&gt;run();
</code></pre>
<p>In order to create a plaintext TCP/IP connection, you can simply pass a host
and port combination like this:</p>
<pre><code class="lang-php">$connector-&gt;connect(<span class="hljs-string">&apos;www.google.com:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<blockquote>
<p>If you do no specify a URI scheme in the destination URI, it will assume
  <code>tcp://</code> as a default and establish a plaintext TCP/IP connection.
  Note that TCP/IP connections require a host and port part in the destination
  URI like above, all other URI components are optional.</p>
</blockquote>
<p>In order to create a secure TLS connection, you can use the <code>tls://</code> URI scheme
like this:</p>
<pre><code class="lang-php">$connector-&gt;connect(<span class="hljs-string">&apos;tls://www.google.com:443&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<p>In order to create a local Unix domain socket connection, you can use the
<code>unix://</code> URI scheme like this:</p>
<pre><code class="lang-php">$connector-&gt;connect(<span class="hljs-string">&apos;unix:///tmp/demo.sock&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<blockquote>
<p>The <a href="#getremoteaddress"><code>getRemoteAddress()</code></a> method will return the target
  Unix domain socket (UDS) path as given to the <code>connect()</code> method, including
  the <code>unix://</code> scheme, for example <code>unix:///tmp/demo.sock</code>.
  The <a href="#getlocaladdress"><code>getLocalAddress()</code></a> method will most likely return a
  <code>null</code> value as this value is not applicable to UDS connections here.</p>
</blockquote>
<p>Under the hood, the <code>Connector</code> is implemented as a <em>higher-level facade</em>
for the lower-level connectors implemented in this package. This means it
also shares all of their features and implementation details.
If you want to typehint in your higher-level protocol implementation, you SHOULD
use the generic <a href="#connectorinterface"><code>ConnectorInterface</code></a> instead.</p>
<p>As of <code>v1.4.0</code>, the <code>Connector</code> class defaults to using the
<a href="https://en.wikipedia.org/wiki/Happy_Eyeballs" target="_blank">happy eyeballs algorithm</a> to
automatically connect over IPv4 or IPv6 when a hostname is given.
This automatically attempts to connect using both IPv4 and IPv6 at the same time
(preferring IPv6), thus avoiding the usual problems faced by users with imperfect
IPv6 connections or setups.
If you want to revert to the old behavior of only doing an IPv4 lookup and
only attempt a single IPv4 connection, you can set up the <code>Connector</code> like this:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;happy_eyeballs&apos;</span> =&gt; <span class="hljs-keyword">false</span>
));
</code></pre>
<p>Similarly, you can also affect the default DNS behavior as follows.
The <code>Connector</code> class will try to detect your system DNS settings (and uses
Google&apos;s public DNS server <code>8.8.8.8</code> as a fallback if unable to determine your
system settings) to resolve all public hostnames into underlying IP addresses by
default.
If you explicitly want to use a custom DNS server (such as a local DNS relay or
a company wide DNS server), you can set up the <code>Connector</code> like this:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;dns&apos;</span> =&gt; <span class="hljs-string">&apos;127.0.1.1&apos;</span>
));

$connector-&gt;connect(<span class="hljs-string">&apos;localhost:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<p>If you do not want to use a DNS resolver at all and want to connect to IP
addresses only, you can also set up your <code>Connector</code> like this:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;dns&apos;</span> =&gt; <span class="hljs-keyword">false</span>
));

$connector-&gt;connect(<span class="hljs-string">&apos;127.0.0.1:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<p>Advanced: If you need a custom DNS <code>React\Dns\Resolver\ResolverInterface</code> instance, you
can also set up your <code>Connector</code> like this:</p>
<pre><code class="lang-php">$dnsResolverFactory = <span class="hljs-keyword">new</span> React\Dns\Resolver\Factory();
$resolver = $dnsResolverFactory-&gt;createCached(<span class="hljs-string">&apos;127.0.1.1&apos;</span>, $loop);

$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;dns&apos;</span> =&gt; $resolver
));

$connector-&gt;connect(<span class="hljs-string">&apos;localhost:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<p>By default, the <code>tcp://</code> and <code>tls://</code> URI schemes will use timeout value that
respects your <code>default_socket_timeout</code> ini setting (which defaults to 60s).
If you want a custom timeout value, you can simply pass this like this:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;timeout&apos;</span> =&gt; <span class="hljs-number">10.0</span>
));
</code></pre>
<p>Similarly, if you do not want to apply a timeout at all and let the operating
system handle this, you can pass a boolean flag like this:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;timeout&apos;</span> =&gt; <span class="hljs-keyword">false</span>
));
</code></pre>
<p>By default, the <code>Connector</code> supports the <code>tcp://</code>, <code>tls://</code> and <code>unix://</code>
URI schemes. If you want to explicitly prohibit any of these, you can simply
pass boolean flags like this:</p>
<pre><code class="lang-php"><span class="hljs-comment">// only allow secure TLS connections</span>
$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tcp&apos;</span> =&gt; <span class="hljs-keyword">false</span>,
    <span class="hljs-string">&apos;tls&apos;</span> =&gt; <span class="hljs-keyword">true</span>,
    <span class="hljs-string">&apos;unix&apos;</span> =&gt; <span class="hljs-keyword">false</span>,
));

$connector-&gt;connect(<span class="hljs-string">&apos;tls://google.com:443&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<p>The <code>tcp://</code> and <code>tls://</code> also accept additional context options passed to
the underlying connectors.
If you want to explicitly pass additional context options, you can simply
pass arrays of context options like this:</p>
<pre><code class="lang-php"><span class="hljs-comment">// allow insecure TLS connections</span>
$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tcp&apos;</span> =&gt; <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&apos;bindto&apos;</span> =&gt; <span class="hljs-string">&apos;192.168.0.1:0&apos;</span>
    ),
    <span class="hljs-string">&apos;tls&apos;</span> =&gt; <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&apos;verify_peer&apos;</span> =&gt; <span class="hljs-keyword">false</span>,
        <span class="hljs-string">&apos;verify_peer_name&apos;</span> =&gt; <span class="hljs-keyword">false</span>
    ),
));

$connector-&gt;connect(<span class="hljs-string">&apos;tls://localhost:443&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<p>By default, this connector supports TLSv1.0+ and excludes support for legacy
SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you
want to negotiate with the remote side:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tls&apos;</span> =&gt; <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&apos;crypto_method&apos;</span> =&gt; STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT
    )
));
</code></pre>
<blockquote>
<p>For more details about context options, please refer to the PHP documentation
  about <a href="https://www.php.net/manual/en/context.socket.php" target="_blank">socket context options</a>
  and <a href="https://www.php.net/manual/en/context.ssl.php" target="_blank">SSL context options</a>.</p>
</blockquote>
<p>Advanced: By default, the <code>Connector</code> supports the <code>tcp://</code>, <code>tls://</code> and
<code>unix://</code> URI schemes.
For this, it sets up the required connector classes automatically.
If you want to explicitly pass custom connectors for any of these, you can simply
pass an instance implementing the <code>ConnectorInterface</code> like this:</p>
<pre><code class="lang-php">$dnsResolverFactory = <span class="hljs-keyword">new</span> React\Dns\Resolver\Factory();
$resolver = $dnsResolverFactory-&gt;createCached(<span class="hljs-string">&apos;127.0.1.1&apos;</span>, $loop);
$tcp = <span class="hljs-keyword">new</span> React\Socket\HappyEyeBallsConnector($loop, <span class="hljs-keyword">new</span> React\Socket\TcpConnector($loop), $resolver);

$tls = <span class="hljs-keyword">new</span> React\Socket\SecureConnector($tcp, $loop);

$unix = <span class="hljs-keyword">new</span> React\Socket\UnixConnector($loop);

$connector = <span class="hljs-keyword">new</span> React\Socket\Connector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;tcp&apos;</span> =&gt; $tcp,
    <span class="hljs-string">&apos;tls&apos;</span> =&gt; $tls,
    <span class="hljs-string">&apos;unix&apos;</span> =&gt; $unix,

    <span class="hljs-string">&apos;dns&apos;</span> =&gt; <span class="hljs-keyword">false</span>,
    <span class="hljs-string">&apos;timeout&apos;</span> =&gt; <span class="hljs-keyword">false</span>,
));

$connector-&gt;connect(<span class="hljs-string">&apos;google.com:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});
</code></pre>
<blockquote>
<p>Internally, the <code>tcp://</code> connector will always be wrapped by the DNS resolver,
  unless you disable DNS like in the above example. In this case, the <code>tcp://</code>
  connector receives the actual hostname instead of only the resolved IP address
  and is thus responsible for performing the lookup.
  Internally, the automatically created <code>tls://</code> connector will always wrap the
  underlying <code>tcp://</code> connector for establishing the underlying plaintext
  TCP/IP connection before enabling secure TLS mode. If you want to use a custom
  underlying <code>tcp://</code> connector for secure TLS connections only, you may
  explicitly pass a <code>tls://</code> connector like above instead.
  Internally, the <code>tcp://</code> and <code>tls://</code> connectors will always be wrapped by
  <code>TimeoutConnector</code>, unless you disable timeouts like in the above example.</p>
</blockquote>
<h3 id="advanced-client-usage">Advanced client usage</h3>
<h4 id="tcpconnector">TcpConnector</h4>
<p>The <code>TcpConnector</code> class implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and allows you to create plaintext
TCP/IP connections to any IP-port-combination:</p>
<pre><code class="lang-php">$tcpConnector = <span class="hljs-keyword">new</span> React\Socket\TcpConnector($loop);

$tcpConnector-&gt;connect(<span class="hljs-string">&apos;127.0.0.1:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});

$loop-&gt;run();
</code></pre>
<p>See also the <a href="examples">examples</a>.</p>
<p>Pending connection attempts can be cancelled by cancelling its pending promise like so:</p>
<pre><code class="lang-php">$promise = $tcpConnector-&gt;connect(<span class="hljs-string">&apos;127.0.0.1:80&apos;</span>);

$promise-&gt;cancel();
</code></pre>
<p>Calling <code>cancel()</code> on a pending promise will close the underlying socket
resource, thus cancelling the pending TCP/IP connection, and reject the
resulting promise.</p>
<p>You can optionally pass additional
<a href="https://www.php.net/manual/en/context.socket.php" target="_blank">socket context options</a>
to the constructor like this:</p>
<pre><code class="lang-php">$tcpConnector = <span class="hljs-keyword">new</span> React\Socket\TcpConnector($loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;bindto&apos;</span> =&gt; <span class="hljs-string">&apos;192.168.0.1:0&apos;</span>
));
</code></pre>
<p>Note that this class only allows you to connect to IP-port-combinations.
If the given URI is invalid, does not contain a valid IP address and port
or contains any other scheme, it will reject with an
<code>InvalidArgumentException</code>:</p>
<p>If the given URI appears to be valid, but connecting to it fails (such as if
the remote host rejects the connection etc.), it will reject with a
<code>RuntimeException</code>.</p>
<p>If you want to connect to hostname-port-combinations, see also the following chapter.</p>
<blockquote>
<p>Advanced usage: Internally, the <code>TcpConnector</code> allocates an empty <em>context</em>
resource for each stream resource.
If the destination URI contains a <code>hostname</code> query parameter, its value will
be used to set up the TLS peer name.
This is used by the <code>SecureConnector</code> and <code>DnsConnector</code> to verify the peer
name and can also be used if you want a custom TLS peer name.</p>
</blockquote>
<h4 id="happyeyeballsconnector">HappyEyeBallsConnector</h4>
<p>The <code>HappyEyeBallsConnector</code> class implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and allows you to create plaintext
TCP/IP connections to any hostname-port-combination. Internally it implements the 
happy eyeballs algorithm from <a href="https://tools.ietf.org/html/rfc6555" target="_blank"><code>RFC6555</code></a> and 
<a href="https://tools.ietf.org/html/rfc8305" target="_blank"><code>RFC8305</code></a> to support IPv6 and IPv4 hostnames.</p>
<p>It does so by decorating a given <code>TcpConnector</code> instance so that it first
looks up the given domain name via DNS (if applicable) and then establishes the
underlying TCP/IP connection to the resolved target IP address.</p>
<p>Make sure to set up your DNS resolver and underlying TCP connector like this:</p>
<pre><code class="lang-php">$dnsResolverFactory = <span class="hljs-keyword">new</span> React\Dns\Resolver\Factory();
$dns = $dnsResolverFactory-&gt;createCached(<span class="hljs-string">&apos;8.8.8.8&apos;</span>, $loop);

$dnsConnector = <span class="hljs-keyword">new</span> React\Socket\HappyEyeBallsConnector($loop, $tcpConnector, $dns);

$dnsConnector-&gt;connect(<span class="hljs-string">&apos;www.google.com:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});

$loop-&gt;run();
</code></pre>
<p>See also the <a href="examples">examples</a>.</p>
<p>Pending connection attempts can be cancelled by cancelling its pending promise like so:</p>
<pre><code class="lang-php">$promise = $dnsConnector-&gt;connect(<span class="hljs-string">&apos;www.google.com:80&apos;</span>);

$promise-&gt;cancel();
</code></pre>
<p>Calling <code>cancel()</code> on a pending promise will cancel the underlying DNS lookups
and/or the underlying TCP/IP connection(s) and reject the resulting promise.</p>
<blockquote>
<p>Advanced usage: Internally, the <code>HappyEyeBallsConnector</code> relies on a <code>Resolver</code> to
look up the IP addresses for the given hostname.
It will then replace the hostname in the destination URI with this IP&apos;s and
append a <code>hostname</code> query parameter and pass this updated URI to the underlying
connector. 
The Happy Eye Balls algorithm describes looking the IPv6 and IPv4 address for 
the given hostname so this connector sends out two DNS lookups for the A and 
AAAA records. It then uses all IP addresses (both v6 and v4) and tries to 
connect to all of them with a 50ms interval in between. Alterating between IPv6 
and IPv4 addresses. When a connection is established all the other DNS lookups 
and connection attempts are cancelled.</p>
</blockquote>
<h4 id="dnsconnector">DnsConnector</h4>
<p>The <code>DnsConnector</code> class implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and allows you to create plaintext
TCP/IP connections to any hostname-port-combination.</p>
<p>It does so by decorating a given <code>TcpConnector</code> instance so that it first
looks up the given domain name via DNS (if applicable) and then establishes the
underlying TCP/IP connection to the resolved target IP address.</p>
<p>Make sure to set up your DNS resolver and underlying TCP connector like this:</p>
<pre><code class="lang-php">$dnsResolverFactory = <span class="hljs-keyword">new</span> React\Dns\Resolver\Factory();
$dns = $dnsResolverFactory-&gt;createCached(<span class="hljs-string">&apos;8.8.8.8&apos;</span>, $loop);

$dnsConnector = <span class="hljs-keyword">new</span> React\Socket\DnsConnector($tcpConnector, $dns);

$dnsConnector-&gt;connect(<span class="hljs-string">&apos;www.google.com:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&apos;...&apos;</span>);
    $connection-&gt;end();
});

$loop-&gt;run();
</code></pre>
<p>See also the <a href="examples">examples</a>.</p>
<p>Pending connection attempts can be cancelled by cancelling its pending promise like so:</p>
<pre><code class="lang-php">$promise = $dnsConnector-&gt;connect(<span class="hljs-string">&apos;www.google.com:80&apos;</span>);

$promise-&gt;cancel();
</code></pre>
<p>Calling <code>cancel()</code> on a pending promise will cancel the underlying DNS lookup
and/or the underlying TCP/IP connection and reject the resulting promise.</p>
<blockquote>
<p>Advanced usage: Internally, the <code>DnsConnector</code> relies on a <code>React\Dns\Resolver\ResolverInterface</code>
to look up the IP address for the given hostname.
It will then replace the hostname in the destination URI with this IP and
append a <code>hostname</code> query parameter and pass this updated URI to the underlying
connector.
The underlying connector is thus responsible for creating a connection to the
target IP address, while this query parameter can be used to check the original
hostname and is used by the <code>TcpConnector</code> to set up the TLS peer name.
If a <code>hostname</code> is given explicitly, this query parameter will not be modified,
which can be useful if you want a custom TLS peer name.</p>
</blockquote>
<h4 id="secureconnector">SecureConnector</h4>
<p>The <code>SecureConnector</code> class implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and allows you to create secure
TLS (formerly known as SSL) connections to any hostname-port-combination.</p>
<p>It does so by decorating a given <code>DnsConnector</code> instance so that it first
creates a plaintext TCP/IP connection and then enables TLS encryption on this
stream.</p>
<pre><code class="lang-php">$secureConnector = <span class="hljs-keyword">new</span> React\Socket\SecureConnector($dnsConnector, $loop);

$secureConnector-&gt;connect(<span class="hljs-string">&apos;www.google.com:443&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&quot;GET / HTTP/1.0\r\nHost: www.google.com\r\n\r\n&quot;</span>);
    ...
});

$loop-&gt;run();
</code></pre>
<p>See also the <a href="examples">examples</a>.</p>
<p>Pending connection attempts can be cancelled by cancelling its pending promise like so:</p>
<pre><code class="lang-php">$promise = $secureConnector-&gt;connect(<span class="hljs-string">&apos;www.google.com:443&apos;</span>);

$promise-&gt;cancel();
</code></pre>
<p>Calling <code>cancel()</code> on a pending promise will cancel the underlying TCP/IP
connection and/or the SSL/TLS negotiation and reject the resulting promise.</p>
<p>You can optionally pass additional
<a href="https://www.php.net/manual/en/context.ssl.php" target="_blank">SSL context options</a>
to the constructor like this:</p>
<pre><code class="lang-php">$secureConnector = <span class="hljs-keyword">new</span> React\Socket\SecureConnector($dnsConnector, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;verify_peer&apos;</span> =&gt; <span class="hljs-keyword">false</span>,
    <span class="hljs-string">&apos;verify_peer_name&apos;</span> =&gt; <span class="hljs-keyword">false</span>
));
</code></pre>
<p>By default, this connector supports TLSv1.0+ and excludes support for legacy
SSLv2/SSLv3. As of PHP 5.6+ you can also explicitly choose the TLS version you
want to negotiate with the remote side:</p>
<pre><code class="lang-php">$secureConnector = <span class="hljs-keyword">new</span> React\Socket\SecureConnector($dnsConnector, $loop, <span class="hljs-keyword">array</span>(
    <span class="hljs-string">&apos;crypto_method&apos;</span> =&gt; STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT
));
</code></pre>
<blockquote>
<p>Advanced usage: Internally, the <code>SecureConnector</code> relies on setting up the
required <em>context options</em> on the underlying stream resource.
It should therefor be used with a <code>TcpConnector</code> somewhere in the connector
stack so that it can allocate an empty <em>context</em> resource for each stream
resource and verify the peer name.
Failing to do so may result in a TLS peer name mismatch error or some hard to
trace race conditions, because all stream resources will use a single, shared
<em>default context</em> resource otherwise.</p>
</blockquote>
<h4 id="timeoutconnector">TimeoutConnector</h4>
<p>The <code>TimeoutConnector</code> class implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and allows you to add timeout
handling to any existing connector instance.</p>
<p>It does so by decorating any given <a href="#connectorinterface"><code>ConnectorInterface</code></a>
instance and starting a timer that will automatically reject and abort any
underlying connection attempt if it takes too long.</p>
<pre><code class="lang-php">$timeoutConnector = <span class="hljs-keyword">new</span> React\Socket\TimeoutConnector($connector, <span class="hljs-number">3.0</span>, $loop);

$timeoutConnector-&gt;connect(<span class="hljs-string">&apos;google.com:80&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    <span class="hljs-comment">// connection succeeded within 3.0 seconds</span>
});
</code></pre>
<p>See also any of the <a href="examples">examples</a>.</p>
<p>Pending connection attempts can be cancelled by cancelling its pending promise like so:</p>
<pre><code class="lang-php">$promise = $timeoutConnector-&gt;connect(<span class="hljs-string">&apos;google.com:80&apos;</span>);

$promise-&gt;cancel();
</code></pre>
<p>Calling <code>cancel()</code> on a pending promise will cancel the underlying connection
attempt, abort the timer and reject the resulting promise.</p>
<h4 id="unixconnector">UnixConnector</h4>
<p>The <code>UnixConnector</code> class implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and allows you to connect to
Unix domain socket (UDS) paths like this:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\UnixConnector($loop);

$connector-&gt;connect(<span class="hljs-string">&apos;/tmp/demo.sock&apos;</span>)-&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(React\Socket\ConnectionInterface $connection)</span> </span>{
    $connection-&gt;write(<span class="hljs-string">&quot;HELLO\n&quot;</span>);
});

$loop-&gt;run();
</code></pre>
<p>Connecting to Unix domain sockets is an atomic operation, i.e. its promise will
settle (either resolve or reject) immediately.
As such, calling <code>cancel()</code> on the resulting promise has no effect.</p>
<blockquote>
<p>The <a href="#getremoteaddress"><code>getRemoteAddress()</code></a> method will return the target
  Unix domain socket (UDS) path as given to the <code>connect()</code> method, prepended
  with the <code>unix://</code> scheme, for example <code>unix:///tmp/demo.sock</code>.
  The <a href="#getlocaladdress"><code>getLocalAddress()</code></a> method will most likely return a
  <code>null</code> value as this value is not applicable to UDS connections here.</p>
</blockquote>
<h4 id="fixeduriconnector">FixedUriConnector</h4>
<p>The <code>FixedUriConnector</code> class implements the
<a href="#connectorinterface"><code>ConnectorInterface</code></a> and decorates an existing Connector
to always use a fixed, preconfigured URI.</p>
<p>This can be useful for consumers that do not support certain URIs, such as
when you want to explicitly connect to a Unix domain socket (UDS) path
instead of connecting to a default address assumed by an higher-level API:</p>
<pre><code class="lang-php">$connector = <span class="hljs-keyword">new</span> React\Socket\FixedUriConnector(
    <span class="hljs-string">&apos;unix:///var/run/docker.sock&apos;</span>,
    <span class="hljs-keyword">new</span> React\Socket\UnixConnector($loop)
);

<span class="hljs-comment">// destination will be ignored, actually connects to Unix domain socket</span>
$promise = $connector-&gt;connect(<span class="hljs-string">&apos;localhost:80&apos;</span>);
</code></pre>
<h2 id="install">Install</h2>
<p>The recommended way to install this library is <a href="https://getcomposer.org" target="_blank">through Composer</a>.
<a href="https://getcomposer.org/doc/00-intro.md" target="_blank">New to Composer?</a></p>
<p>This project follows <a href="https://semver.org/" target="_blank">SemVer</a>.
This will install the latest supported version:</p>
<pre><code class="lang-bash">$ composer require react/socket:^1.6
</code></pre>
<p>See also the <a href="CHANGELOG.md">CHANGELOG</a> for details about version upgrades.</p>
<p>This project aims to run on any platform and thus does not require any PHP
extensions and supports running on legacy PHP 5.3 through current PHP 7+ and HHVM.
It&apos;s <em>highly recommended to use PHP 7+</em> for this project, partly due to its vast
performance improvements and partly because legacy PHP versions require several
workarounds as described below.</p>
<p>Secure TLS connections received some major upgrades starting with PHP 5.6, with
the defaults now being more secure, while older versions required explicit
context options.
This library does not take responsibility over these context options, so it&apos;s
up to consumers of this library to take care of setting appropriate context
options as described above.</p>
<p>PHP &lt; 7.3.3 (and PHP &lt; 7.2.15) suffers from a bug where feof() might
block with 100% CPU usage on fragmented TLS records.
We try to work around this by always consuming the complete receive
buffer at once to avoid stale data in TLS buffers. This is known to
work around high CPU usage for well-behaving peers, but this may
cause very large data chunks for high throughput scenarios. The buggy
behavior can still be triggered due to network I/O buffers or
malicious peers on affected versions, upgrading is highly recommended.</p>
<p>PHP &lt; 7.1.4 (and PHP &lt; 7.0.18) suffers from a bug when writing big
chunks of data over TLS streams at once.
We try to work around this by limiting the write chunk size to 8192
bytes for older PHP versions only.
This is only a work-around and has a noticable performance penalty on
affected versions.</p>
<p>This project also supports running on HHVM.
Note that really old HHVM &lt; 3.8 does not support secure TLS connections, as it
lacks the required <code>stream_socket_enable_crypto()</code> function.
As such, trying to create a secure TLS connections on affected versions will
return a rejected promise instead.
This issue is also covered by our test suite, which will skip related tests
on affected versions.</p>
<h2 id="tests">Tests</h2>
<p>To run the test suite, you first need to clone this repo and then install all
dependencies <a href="https://getcomposer.org" target="_blank">through Composer</a>:</p>
<pre><code class="lang-bash">$ composer install
</code></pre>
<p>To run the test suite, go to the project root and run:</p>
<pre><code class="lang-bash">$ php vendor/bin/phpunit
</code></pre>
<p>The test suite also contains a number of functional integration tests that rely
on a stable internet connection.
If you do not want to run these, they can simply be skipped like this:</p>
<pre><code class="lang-bash">$ php vendor/bin/phpunit --exclude-group internet
</code></pre>
<h2 id="license">License</h2>
<p>MIT, see <a href="LICENSE">LICENSE file</a>.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Datagram.html" class="navigation navigation-prev " aria-label="Previous page: Datagram">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../3.Protocol-Components/Dns.html" class="navigation navigation-next " aria-label="Next page: Dns">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Socket","level":"3.2","depth":1,"next":{"title":"Dns","level":"4.1","depth":1,"path":"3.Protocol-Components/Dns.md","ref":"3.Protocol-Components/Dns.md","articles":[]},"previous":{"title":"Datagram","level":"3.1","depth":1,"path":"2.Network-Components/Datagram.md","ref":"2.Network-Components/Datagram.md","articles":[]},"dir":"ltr"},"config":{"plugins":["- summary","toggle-chapters","theme-comscore","highlight","search-plus","livereload"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"livereload":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"theme-comscore":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"toggle-chapters":{},"search-plus":{}},"theme":"default","author":"Imparting","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"ReactPHP 中文文档","language":"zh-hans","gitbook":"*","description":"ReactPHP是PHP中用于事件驱动编程的底层库。它的核心是一个事件循环，在此基础上它提供了底层实用程序，例如：流抽象、异步DNS解析器、网络客户端/服务器、HTTP客户端/服务器以及与进程通信。第三方库可以使用这些组件创建异步网络客户端/服务器等。","theme-default":{"showLevel":true}},"file":{"path":"2.Network-Components/Socket.md","mtime":"2021-01-27T06:26:04.231Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2021-02-01T08:31:40.529Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-toggle-chapters/toggle.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
        
    

    </body>
</html>

